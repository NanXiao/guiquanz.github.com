<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>os/unix/ngx_freebsd_rfork_thread.c - src</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

code {
    font-family: consolas, monospace;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
  <h3>os/unix/ngx_freebsd_rfork_thread.c - src</h3>
   <a href="../index.html"> Table of Contents </a>
 <h4>Global variables defined</h4>
 <ul>
<li><a href="#L52">errno0</a></li>
<li><a href="#L53">errnos</a></li>
<li><a href="#L41">last_stack</a></li>
<li><a href="#L44">max_threads</a></li>
<li><a href="#L35">ngx_freebsd_kern_usrstack</a></li>
<li><a href="#L36">ngx_thread_stack_size</a></li>
<li><a href="#L48">ngx_tls</a></li>
<li><a href="#L46">nkeys</a></li>
<li><a href="#L43">nthreads</a></li>
<li><a href="#L39">rz_size</a></li>
<li><a href="#L47">tids</a></li>
<li><a href="#L40">usable_stack_size</a></li>
</ul>
 <h4>Functions defined</h4>
 <ul>
<li><a href="#L56">__error</a></li>
<li><a href="#L78">_spinlock</a></li>
<li><a href="#L114">_spinunlock</a></li>
<li><a href="#L610">ngx_cond_destroy</a></li>
<li><a href="#L591">ngx_cond_init</a></li>
<li><a href="#L727">ngx_cond_signal</a></li>
<li><a href="#L622">ngx_cond_wait</a></li>
<li><a href="#L123">ngx_create_thread</a></li>
<li><a href="#L183">ngx_init_threads</a></li>
<li><a href="#L356">ngx_mutex_destroy</a></li>
<li><a href="#L368">ngx_mutex_dolock</a></li>
<li><a href="#L314">ngx_mutex_init</a></li>
<li><a href="#L499">ngx_mutex_unlock</a></li>
<li><a href="#L289">ngx_thread_key_create</a></li>
<li><a href="#L274">ngx_thread_self</a></li>
<li><a href="#L302">ngx_thread_set_tls</a></li>
</ul>
 <h4>Source code</h4>

  <code><ol><li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copyright (C) Igor Sysoev<br/></li>
<li></span><span class="Comment"> * Copyright (C) Nginx, Inc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;ngx_config.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;ngx_core.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The threads implementation uses the rfork(RFPROC|RFTHREAD|RFMEM) syscall<br/></li>
<li></span><span class="Comment"> * to create threads.&nbsp; All threads use the stacks of the same size mmap()ed<br/></li>
<li></span><span class="Comment"> * below the <a href="../../core/nginx.c.html#L202" title="core/nginx.c:202">main</a> stack.&nbsp; Thus the current thread id is determined via<br/></li>
<li></span><span class="Comment"> * the stack pointer value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The mutex implementation uses the <a href="ngx_gcc_atomic_amd64.h.html#L37" title="os/unix/ngx_gcc_atomic_amd64.h:37">ngx_atomic_cmp_set</a>() operation<br/></li>
<li></span><span class="Comment"> * to acquire a mutex and the SysV semaphore to wait on a mutex and to wake up<br/></li>
<li></span><span class="Comment"> * the waiting threads.&nbsp; The light mutex does not use semaphore, so after<br/></li>
<li></span><span class="Comment"> * spinning in the lock the thread calls sched_yield().&nbsp; However the light<br/></li>
<li></span><span class="Comment"> * mutexes are intended to be used with the &quot;trylock&quot; operation only.<br/></li>
<li></span><span class="Comment"> * The SysV semop() is a cheap syscall, particularly if it has little sembuf's<br/></li>
<li></span><span class="Comment"> * and does not use SEM_UNDO.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The condition variable implementation uses the signal #64.<br/></li>
<li></span><span class="Comment"> * The signal handler is SIG_IGN so the kill() is a cheap syscall.<br/></li>
<li></span><span class="Comment"> * The thread waits a signal in kevent().&nbsp; The use of the EVFILT_SIGNAL<br/></li>
<li></span><span class="Comment"> * is safe since FreeBSD 4.10-STABLE.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This threads implementation currently works on i386 (486+) and amd64<br/></li>
<li></span><span class="Comment"> * platforms only.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L35">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">ngx_freebsd_kern_usrstack</span>;<br/></li>
<li><a id="L36">&#x200c;</a><span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">ngx_thread_stack_size</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L39">&#x200c;</a><span class="Type">static</span> <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="linkable">rz_size</span>;<br/></li>
<li><a id="L40">&#x200c;</a><span class="Type">static</span> <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="linkable">usable_stack_size</span>;<br/></li>
<li><a id="L41">&#x200c;</a><span class="Type">static</span> <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *<span class="linkable">last_stack</span>;<br/></li>
<li><br/></li>
<li><a id="L43">&#x200c;</a><span class="Type">static</span> <a href="../../core/ngx_config.h.html#L79" title="core/ngx_config.h:79">ngx_uint_t</a>&nbsp; &nbsp;&nbsp; <span class="linkable">nthreads</span>;<br/></li>
<li><a id="L44">&#x200c;</a><span class="Type">static</span> <a href="../../core/ngx_config.h.html#L79" title="core/ngx_config.h:79">ngx_uint_t</a>&nbsp; &nbsp;&nbsp; <span class="linkable">max_threads</span>;<br/></li>
<li><br/></li>
<li><a id="L46">&#x200c;</a><span class="Type">static</span> <a href="../../core/ngx_config.h.html#L79" title="core/ngx_config.h:79">ngx_uint_t</a>&nbsp; &nbsp;&nbsp; <span class="linkable">nkeys</span>;<br/></li>
<li><a id="L47">&#x200c;</a><span class="Type">static</span> <a href="ngx_thread.h.html#L27" title="os/unix/ngx_thread.h:27">ngx_tid_t</a>&nbsp; &nbsp;&nbsp; *<span class="linkable">tids</span>;&nbsp; &nbsp; &nbsp; <span class="Comment">/* the threads <span class="linkable">tids</span> array */<br/></li>
<li><a id="L48">&#x200c;</a></span><span class="Type">void</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; **<span class="linkable">ngx_tls</span>;&nbsp;&nbsp; <span class="Comment">/* the threads tls's array */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* the thread-safe libc errno */<br/></li>
<li></span><br/></li>
<li><a id="L52">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp;&nbsp; <span class="linkable">errno0</span>;&nbsp;&nbsp; <span class="Comment">/* the <a href="../../core/nginx.c.html#L202" title="core/nginx.c:202">main</a> thread's errno */<br/></li>
<li><a id="L53">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; *<span class="linkable">errnos</span>;&nbsp;&nbsp; <span class="Comment">/* the threads errno's array */<br/></li>
<li></span><br/></li>
<li><span class="Type">int</span> *<br/></li>
<li><a id="L56">&#x200c;</a><span class="linkable">__error</span>()<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; tid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tid = <a href="ngx_freebsd_rfork_thread.h.html#L60" title="os/unix/ngx_freebsd_rfork_thread.h:60">ngx_gettid</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tid ? &amp;<a href="#L53" title="os/unix/ngx_freebsd_rfork_thread.c:53">errnos</a>[tid - <span class="Constant">1</span>] : &amp;<a href="#L52" title="os/unix/ngx_freebsd_rfork_thread.c:52">errno0</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * __isthreaded enables the spinlocks in some libc functions, i.e. in malloc()<br/></li>
<li></span><span class="Comment"> * and some other places.&nbsp; Nevertheless we protect our malloc()/free() calls<br/></li>
<li></span><span class="Comment"> * by own mutex that is more efficient than the spinlock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L78" title="os/unix/ngx_freebsd_rfork_thread.c:78">_spinlock</a>() is a weak referenced stub in src/lib/libc/gen/_spinlock_stub.c<br/></li>
<li></span><span class="Comment"> * that does nothing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">extern</span> <span class="Type">int</span>&nbsp; __isthreaded;<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L78">&#x200c;</a></span><span class="linkable">_spinlock</span>(<a href="ngx_atomic.h.html#L25" title="os/unix/ngx_atomic.h:25">ngx_atomic_t</a> *lock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../core/ngx_config.h.html#L78" title="core/ngx_config.h:78">ngx_int_t</a>&nbsp; tries;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tries = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> ( ;; ) {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*lock) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="ngx_posix_init.c.html#L13" title="os/unix/ngx_posix_init.c:13">ngx_ncpu</a> &gt; <span class="Constant">1</span> &amp;&amp; tries++ &lt; <span class="Constant">1000</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sched_yield();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tries = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="ngx_gcc_atomic_amd64.h.html#L37" title="os/unix/ngx_gcc_atomic_amd64.h:37">ngx_atomic_cmp_set</a>(lock, <span class="Constant">0</span>, <span class="Constant">1</span>)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Before FreeBSD 5.1 <a href="#L114" title="os/unix/ngx_freebsd_rfork_thread.c:114">_spinunlock</a>() is a simple #define in<br/></li>
<li></span><span class="Comment"> * src/lib/libc/include/spinlock.h that zeroes lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since FreeBSD 5.1 <a href="#L114" title="os/unix/ngx_freebsd_rfork_thread.c:114">_spinunlock</a>() is a weak referenced stub in<br/></li>
<li></span><span class="Comment"> * src/lib/libc/gen/_spinlock_stub.c that does nothing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifndef <a href="#L114" title="os/unix/ngx_freebsd_rfork_thread.c:114">_spinunlock</a><br/></li>
<li></span><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L114">&#x200c;</a></span><span class="linkable">_spinunlock</span>(<a href="ngx_atomic.h.html#L25" title="os/unix/ngx_atomic.h:25">ngx_atomic_t</a> *lock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; *lock = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a href="ngx_errno.h.html#L16" title="os/unix/ngx_errno.h:16">ngx_err_t</a><br/></li>
<li><a id="L123">&#x200c;</a><span class="linkable">ngx_create_thread</span>(<a href="ngx_thread.h.html#L27" title="os/unix/ngx_thread.h:27">ngx_tid_t</a> *tid, <a href="ngx_thread.h.html#L94" title="os/unix/ngx_thread.h:94">ngx_thread_value_t</a> (*func)(<span class="Type">void</span> *arg),<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span> *arg, <a href="../../core/ngx_core.h.html#L17" title="core/ngx_core.h:17">ngx_log_t</a> *log)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="ngx_process.h.html#L16" title="os/unix/ngx_process.h:16">ngx_pid_t</a>&nbsp;&nbsp; id;<br/></li>
<li>&nbsp; &nbsp; <a href="ngx_errno.h.html#L16" title="os/unix/ngx_errno.h:16">ngx_err_t</a>&nbsp;&nbsp; err;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *stack, *stack_top;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="ngx_pthread_thread.c.html#L12" title="os/unix/ngx_pthread_thread.c:12">nthreads</a> &gt;= <a href="ngx_pthread_thread.c.html#L13" title="os/unix/ngx_pthread_thread.c:13">max_threads</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L19" title="core/ngx_log.h:19">NGX_LOG_CRIT</a>, log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;no more than </span><span class="Special">%u</span><span class="Constant">i threads can be created&quot;</span>, <a href="ngx_pthread_thread.c.html#L13" title="os/unix/ngx_pthread_thread.c:13">max_threads</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L30" title="core/ngx_core.h:30">NGX_ERROR</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L41" title="os/unix/ngx_freebsd_rfork_thread.c:41">last_stack</a> -= <a href="#L36" title="os/unix/ngx_freebsd_rfork_thread.c:36">ngx_thread_stack_size</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stack = mmap(<a href="#L41" title="os/unix/ngx_freebsd_rfork_thread.c:41">last_stack</a>, <a href="#L40" title="os/unix/ngx_freebsd_rfork_thread.c:40">usable_stack_size</a>, PROT_READ|PROT_WRITE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAP_STACK, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stack == MAP_FAILED) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, log, <a href="ngx_errno.h.html#L68" title="os/unix/ngx_errno.h:68">ngx_errno</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;mmap(</span><span class="Special">%p</span><span class="Constant">:</span><span class="Special">%u</span><span class="Constant">z, MAP_STACK) thread stack failed&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L41" title="os/unix/ngx_freebsd_rfork_thread.c:41">last_stack</a>, <a href="#L40" title="os/unix/ngx_freebsd_rfork_thread.c:40">usable_stack_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L30" title="core/ngx_core.h:30">NGX_ERROR</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stack != <a href="#L41" title="os/unix/ngx_freebsd_rfork_thread.c:41">last_stack</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;stack </span><span class="Special">%p</span><span class="Constant"> address was changed to </span><span class="Special">%p</span><span class="Constant">&quot;</span>, <a href="#L41" title="os/unix/ngx_freebsd_rfork_thread.c:41">last_stack</a>, stack);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L30" title="core/ngx_core.h:30">NGX_ERROR</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stack_top = stack + <a href="#L40" title="os/unix/ngx_freebsd_rfork_thread.c:40">usable_stack_size</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L138" title="core/ngx_log.h:138">ngx_log_debug2</a>(<a href="../../core/ngx_log.h.html#L26" title="core/ngx_log.h:26">NGX_LOG_DEBUG_CORE</a>, log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;thread stack: </span><span class="Special">%p</span><span class="Constant">-</span><span class="Special">%p</span><span class="Constant">&quot;</span>, stack, stack_top);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="ngx_errno.h.html#L70" title="os/unix/ngx_errno.h:70">ngx_set_errno</a>(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; id = rfork_thread(RFPROC|RFTHREAD|RFMEM, stack_top,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="ngx_freebsd_rfork_thread.h.html#L119" title="os/unix/ngx_freebsd_rfork_thread.h:119">ngx_rfork_thread_func_pt</a>) func, arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; err = <a href="ngx_errno.h.html#L68" title="os/unix/ngx_errno.h:68">ngx_errno</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (id == -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, log, err, <span class="Constant">&quot;rfork() failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *tid = id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="ngx_pthread_thread.c.html#L12" title="os/unix/ngx_pthread_thread.c:12">nthreads</a> = (<a href="#L35" title="os/unix/ngx_freebsd_rfork_thread.c:35">ngx_freebsd_kern_usrstack</a> - stack_top)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; / <a href="#L36" title="os/unix/ngx_freebsd_rfork_thread.c:36">ngx_thread_stack_size</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L47" title="os/unix/ngx_freebsd_rfork_thread.c:47">tids</a>[<a href="ngx_pthread_thread.c.html#L12" title="os/unix/ngx_pthread_thread.c:12">nthreads</a>] = id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L135" title="core/ngx_log.h:135">ngx_log_debug1</a>(<a href="../../core/ngx_log.h.html#L26" title="core/ngx_log.h:26">NGX_LOG_DEBUG_CORE</a>, log, <span class="Constant">0</span>, <span class="Constant">&quot;rfork()ed thread: %P&quot;</span>, id);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> err;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a href="../../core/ngx_config.h.html#L78" title="core/ngx_config.h:78">ngx_int_t</a><br/></li>
<li><a id="L183">&#x200c;</a><span class="linkable">ngx_init_threads</span>(<span class="Type">int</span> n, <span class="Type">size_t</span> size, <a href="../../core/ngx_core.h.html#L14" title="core/ngx_core.h:14">ngx_cycle_t</a> *cycle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *red_zone, *zone;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <a href="../../core/ngx_config.h.html#L78" title="core/ngx_config.h:78">ngx_int_t</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> sigaction&nbsp;&nbsp; sa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="ngx_pthread_thread.c.html#L13" title="os/unix/ngx_pthread_thread.c:13">max_threads</a> = n + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; n; i++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_string.h.html#L86" title="core/ngx_string.h:86">ngx_memzero</a>(&amp;sa, <span class="Statement">sizeof</span>(<span class="Type">struct</span> sigaction));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sa.sa_handler = <span class="Constant">SIG_IGN</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sigemptyset(&amp;sa.sa_mask);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sigaction(<a href="ngx_freebsd_rfork_thread.h.html#L35" title="os/unix/ngx_freebsd_rfork_thread.h:35">NGX_CV_SIGNAL</a>, &amp;sa, <span class="Constant">NULL</span>) == -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, cycle-&gt;log, <a href="ngx_errno.h.html#L68" title="os/unix/ngx_errno.h:68">ngx_errno</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;sigaction(</span><span class="Special">%d</span><span class="Constant">, SIG_IGN) failed&quot;</span>, <a href="ngx_freebsd_rfork_thread.h.html#L35" title="os/unix/ngx_freebsd_rfork_thread.h:35">NGX_CV_SIGNAL</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L30" title="core/ngx_core.h:30">NGX_ERROR</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = <span class="Statement">sizeof</span>(<a href="#L35" title="os/unix/ngx_freebsd_rfork_thread.c:35">ngx_freebsd_kern_usrstack</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sysctlbyname(<span class="Constant">&quot;kern.usrstack&quot;</span>, &amp;<a href="#L35" title="os/unix/ngx_freebsd_rfork_thread.c:35">ngx_freebsd_kern_usrstack</a>, &amp;len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>) == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, cycle-&gt;log, <a href="ngx_errno.h.html#L68" title="os/unix/ngx_errno.h:68">ngx_errno</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;sysctlbyname(kern.usrstack) failed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L30" title="core/ngx_core.h:30">NGX_ERROR</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the <a href="../../core/nginx.c.html#L202" title="core/nginx.c:202">main</a> thread stack red zone */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L39" title="os/unix/ngx_freebsd_rfork_thread.c:39">rz_size</a> = <a href="ngx_alloc.c.html#L12" title="os/unix/ngx_alloc.c:12">ngx_pagesize</a>;<br/></li>
<li>&nbsp; &nbsp; red_zone = <a href="#L35" title="os/unix/ngx_freebsd_rfork_thread.c:35">ngx_freebsd_kern_usrstack</a> - (size + <a href="#L39" title="os/unix/ngx_freebsd_rfork_thread.c:39">rz_size</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L138" title="core/ngx_log.h:138">ngx_log_debug2</a>(<a href="../../core/ngx_log.h.html#L26" title="core/ngx_log.h:26">NGX_LOG_DEBUG_CORE</a>, cycle-&gt;log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;usrstack: </span><span class="Special">%p</span><span class="Constant"> red zone: </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L35" title="os/unix/ngx_freebsd_rfork_thread.c:35">ngx_freebsd_kern_usrstack</a>, red_zone);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; zone = mmap(red_zone, <a href="#L39" title="os/unix/ngx_freebsd_rfork_thread.c:39">rz_size</a>, PROT_NONE, MAP_ANON, -<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (zone == MAP_FAILED) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, cycle-&gt;log, <a href="ngx_errno.h.html#L68" title="os/unix/ngx_errno.h:68">ngx_errno</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;mmap(</span><span class="Special">%p</span><span class="Constant">:</span><span class="Special">%u</span><span class="Constant">z, PROT_NONE, MAP_ANON) red zone failed&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; red_zone, <a href="#L39" title="os/unix/ngx_freebsd_rfork_thread.c:39">rz_size</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L30" title="core/ngx_core.h:30">NGX_ERROR</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (zone != red_zone) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, cycle-&gt;log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;red zone </span><span class="Special">%p</span><span class="Constant"> address was changed to </span><span class="Special">%p</span><span class="Constant">&quot;</span>, red_zone, zone);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L30" title="core/ngx_core.h:30">NGX_ERROR</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* create the thread errno' array */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L53" title="os/unix/ngx_freebsd_rfork_thread.c:53">errnos</a> = <a href="ngx_alloc.c.html#L35" title="os/unix/ngx_alloc.c:35">ngx_calloc</a>(n * <span class="Statement">sizeof</span>(<span class="Type">int</span>), cycle-&gt;log);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L53" title="os/unix/ngx_freebsd_rfork_thread.c:53">errnos</a> == <span class="Constant">NULL</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L30" title="core/ngx_core.h:30">NGX_ERROR</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* create the thread <a href="#L47" title="os/unix/ngx_freebsd_rfork_thread.c:47">tids</a> array */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L47" title="os/unix/ngx_freebsd_rfork_thread.c:47">tids</a> = <a href="ngx_alloc.c.html#L35" title="os/unix/ngx_alloc.c:35">ngx_calloc</a>((n + <span class="Constant">1</span>) * <span class="Statement">sizeof</span>(<a href="ngx_thread.h.html#L27" title="os/unix/ngx_thread.h:27">ngx_tid_t</a>), cycle-&gt;log);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L47" title="os/unix/ngx_freebsd_rfork_thread.c:47">tids</a> == <span class="Constant">NULL</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L30" title="core/ngx_core.h:30">NGX_ERROR</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L47" title="os/unix/ngx_freebsd_rfork_thread.c:47">tids</a>[<span class="Constant">0</span>] = <a href="ngx_process_cycle.c.html#L36" title="os/unix/ngx_process_cycle.c:36">ngx_pid</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* create the thread tls' array */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="os/unix/ngx_freebsd_rfork_thread.c:48">ngx_tls</a> = <a href="ngx_alloc.c.html#L35" title="os/unix/ngx_alloc.c:35">ngx_calloc</a>(<a href="ngx_freebsd_rfork_thread.h.html#L91" title="os/unix/ngx_freebsd_rfork_thread.h:91">NGX_THREAD_KEYS_MAX</a> * (n + <span class="Constant">1</span>) * <span class="Statement">sizeof</span>(<span class="Type">void</span> *),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cycle-&gt;log);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L48" title="os/unix/ngx_freebsd_rfork_thread.c:48">ngx_tls</a> == <span class="Constant">NULL</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L30" title="core/ngx_core.h:30">NGX_ERROR</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="ngx_pthread_thread.c.html#L12" title="os/unix/ngx_pthread_thread.c:12">nthreads</a> = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L41" title="os/unix/ngx_freebsd_rfork_thread.c:41">last_stack</a> = zone + <a href="#L39" title="os/unix/ngx_freebsd_rfork_thread.c:39">rz_size</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L40" title="os/unix/ngx_freebsd_rfork_thread.c:40">usable_stack_size</a> = size;<br/></li>
<li>&nbsp; &nbsp; <a href="#L36" title="os/unix/ngx_freebsd_rfork_thread.c:36">ngx_thread_stack_size</a> = size + <a href="#L39" title="os/unix/ngx_freebsd_rfork_thread.c:39">rz_size</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allow the spinlock in libc malloc() */<br/></li>
<li></span>&nbsp; &nbsp; __isthreaded = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="ngx_process_cycle.c.html#L37" title="os/unix/ngx_process_cycle.c:37">ngx_threaded</a> = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L29" title="core/ngx_core.h:29">NGX_OK</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a href="ngx_thread.h.html#L27" title="os/unix/ngx_thread.h:27">ngx_tid_t</a><br/></li>
<li><a id="L274">&#x200c;</a><span class="linkable">ngx_thread_self</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../core/ngx_config.h.html#L78" title="core/ngx_config.h:78">ngx_int_t</a>&nbsp; tid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tid = <a href="ngx_freebsd_rfork_thread.h.html#L60" title="os/unix/ngx_freebsd_rfork_thread.h:60">ngx_gettid</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L47" title="os/unix/ngx_freebsd_rfork_thread.c:47">tids</a> == <span class="Constant">NULL</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="ngx_process_cycle.c.html#L36" title="os/unix/ngx_process_cycle.c:36">ngx_pid</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L47" title="os/unix/ngx_freebsd_rfork_thread.c:47">tids</a>[tid];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a href="ngx_errno.h.html#L16" title="os/unix/ngx_errno.h:16">ngx_err_t</a><br/></li>
<li><a id="L289">&#x200c;</a><span class="linkable">ngx_thread_key_create</span>(<a href="ngx_thread.h.html#L39" title="os/unix/ngx_thread.h:39">ngx_tls_key_t</a> *key)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L46" title="os/unix/ngx_freebsd_rfork_thread.c:46">nkeys</a> &gt;= <a href="ngx_freebsd_rfork_thread.h.html#L91" title="os/unix/ngx_freebsd_rfork_thread.h:91">NGX_THREAD_KEYS_MAX</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="ngx_errno.h.html#L24" title="os/unix/ngx_errno.h:24">NGX_ENOMEM</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *key = <a href="#L46" title="os/unix/ngx_freebsd_rfork_thread.c:46">nkeys</a>++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a href="ngx_errno.h.html#L16" title="os/unix/ngx_errno.h:16">ngx_err_t</a><br/></li>
<li><a id="L302">&#x200c;</a><span class="linkable">ngx_thread_set_tls</span>(<a href="ngx_thread.h.html#L39" title="os/unix/ngx_thread.h:39">ngx_tls_key_t</a> key, <span class="Type">void</span> *value)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (key &gt;= <a href="ngx_freebsd_rfork_thread.h.html#L91" title="os/unix/ngx_freebsd_rfork_thread.h:91">NGX_THREAD_KEYS_MAX</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="ngx_errno.h.html#L31" title="os/unix/ngx_errno.h:31">NGX_EINVAL</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L48" title="os/unix/ngx_freebsd_rfork_thread.c:48">ngx_tls</a>[key * <a href="ngx_freebsd_rfork_thread.h.html#L91" title="os/unix/ngx_freebsd_rfork_thread.h:91">NGX_THREAD_KEYS_MAX</a> + <a href="ngx_freebsd_rfork_thread.h.html#L60" title="os/unix/ngx_freebsd_rfork_thread.h:60">ngx_gettid</a>()] = value;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a href="ngx_thread.h.html#L53" title="os/unix/ngx_thread.h:53">ngx_mutex_t</a> *<br/></li>
<li><a id="L314">&#x200c;</a><span class="linkable">ngx_mutex_init</span>(<a href="../../core/ngx_core.h.html#L17" title="core/ngx_core.h:17">ngx_log_t</a> *log, <a href="../../core/ngx_config.h.html#L79" title="core/ngx_config.h:79">ngx_uint_t</a> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="ngx_thread.h.html#L53" title="os/unix/ngx_thread.h:53">ngx_mutex_t</a>&nbsp; *m;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">union</span> semun&nbsp;&nbsp; op;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; m = <a href="ngx_alloc.c.html#L18" title="os/unix/ngx_alloc.c:18">ngx_alloc</a>(<span class="Statement">sizeof</span>(<a href="ngx_thread.h.html#L53" title="os/unix/ngx_thread.h:53">ngx_mutex_t</a>), log);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (m == <span class="Constant">NULL</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; m-&gt;lock = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; m-&gt;log = log;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; <a href="ngx_thread.h.html#L48" title="os/unix/ngx_thread.h:48">NGX_MUTEX_LIGHT</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; m-&gt;semid = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> m;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; m-&gt;semid = semget(IPC_PRIVATE, <span class="Constant">1</span>, SEM_R|SEM_A);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (m-&gt;semid == -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, log, <a href="ngx_errno.h.html#L68" title="os/unix/ngx_errno.h:68">ngx_errno</a>, <span class="Constant">&quot;semget() failed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; op.val = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (semctl(m-&gt;semid, <span class="Constant">0</span>, SETVAL, op) == -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, log, <a href="ngx_errno.h.html#L68" title="os/unix/ngx_errno.h:68">ngx_errno</a>, <span class="Constant">&quot;semctl(SETVAL) failed&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (semctl(m-&gt;semid, <span class="Constant">0</span>, IPC_RMID) == -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, log, <a href="ngx_errno.h.html#L68" title="os/unix/ngx_errno.h:68">ngx_errno</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;semctl(IPC_RMID) failed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> m;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L356">&#x200c;</a></span><span class="linkable">ngx_mutex_destroy</span>(<a href="ngx_thread.h.html#L53" title="os/unix/ngx_thread.h:53">ngx_mutex_t</a> *m)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (semctl(m-&gt;semid, <span class="Constant">0</span>, IPC_RMID) == -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, m-&gt;log, <a href="ngx_errno.h.html#L68" title="os/unix/ngx_errno.h:68">ngx_errno</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;semctl(IPC_RMID) failed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="ngx_alloc.h.html#L19" title="os/unix/ngx_alloc.h:19">ngx_free</a>((<span class="Type">void</span> *) m);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a href="../../core/ngx_config.h.html#L78" title="core/ngx_config.h:78">ngx_int_t</a><br/></li>
<li><a id="L368">&#x200c;</a><span class="linkable">ngx_mutex_dolock</span>(<a href="ngx_thread.h.html#L53" title="os/unix/ngx_thread.h:53">ngx_mutex_t</a> *m, <a href="../../core/ngx_config.h.html#L78" title="core/ngx_config.h:78">ngx_int_t</a> try)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">uint32_t</span>&nbsp; &nbsp; &nbsp;&nbsp; lock, old;<br/></li>
<li>&nbsp; &nbsp; <a href="../../core/ngx_config.h.html#L79" title="core/ngx_config.h:79">ngx_uint_t</a>&nbsp; &nbsp;&nbsp; tries;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> sembuf&nbsp; op;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="ngx_process_cycle.c.html#L37" title="os/unix/ngx_process_cycle.c:37">ngx_threaded</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L29" title="core/ngx_core.h:29">NGX_OK</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#if (NGX_DEBUG)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (try) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L138" title="core/ngx_log.h:138">ngx_log_debug2</a>(<a href="../../core/ngx_log.h.html#L28" title="core/ngx_log.h:28">NGX_LOG_DEBUG_MUTEX</a>, m-&gt;log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;try lock mutex </span><span class="Special">%p</span><span class="Constant"> lock:</span><span class="Special">%X</span><span class="Constant">D&quot;</span>, m, m-&gt;lock);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L138" title="core/ngx_log.h:138">ngx_log_debug2</a>(<a href="../../core/ngx_log.h.html#L28" title="core/ngx_log.h:28">NGX_LOG_DEBUG_MUTEX</a>, m-&gt;log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;lock mutex </span><span class="Special">%p</span><span class="Constant"> lock:</span><span class="Special">%X</span><span class="Constant">D&quot;</span>, m, m-&gt;lock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; old = m-&gt;lock;<br/></li>
<li>&nbsp; &nbsp; tries = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> ( ;; ) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old &amp; <a href="ngx_freebsd_rfork_thread.h.html#L26" title="os/unix/ngx_freebsd_rfork_thread.h:26">NGX_MUTEX_LOCK_BUSY</a>) {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (try) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L31" title="core/ngx_core.h:31">NGX_AGAIN</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="ngx_posix_init.c.html#L13" title="os/unix/ngx_posix_init.c:13">ngx_ncpu</a> &gt; <span class="Constant">1</span> &amp;&amp; tries++ &lt; <span class="Constant">1000</span>) {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the spinlock is used only on the SMP system */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old = m-&gt;lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (m-&gt;semid == -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sched_yield();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tries = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old = m-&gt;lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L138" title="core/ngx_log.h:138">ngx_log_debug2</a>(<a href="../../core/ngx_log.h.html#L28" title="core/ngx_log.h:28">NGX_LOG_DEBUG_MUTEX</a>, m-&gt;log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;mutex </span><span class="Special">%p</span><span class="Constant"> lock:</span><span class="Special">%X</span><span class="Constant">D&quot;</span>, m, m-&gt;lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The mutex is locked so we increase a number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the threads that are waiting on the mutex<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock = old + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((lock &amp; ~<a href="ngx_freebsd_rfork_thread.h.html#L26" title="os/unix/ngx_freebsd_rfork_thread.h:26">NGX_MUTEX_LOCK_BUSY</a>) &gt; <a href="ngx_pthread_thread.c.html#L12" title="os/unix/ngx_pthread_thread.c:12">nthreads</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, m-&gt;log, <a href="ngx_errno.h.html#L68" title="os/unix/ngx_errno.h:68">ngx_errno</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;</span><span class="Special">%D</span><span class="Constant"> threads wait for mutex </span><span class="Special">%p</span><span class="Constant">, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;while only </span><span class="Special">%u</span><span class="Constant">i threads are available&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock &amp; ~<a href="ngx_freebsd_rfork_thread.h.html#L26" title="os/unix/ngx_freebsd_rfork_thread.h:26">NGX_MUTEX_LOCK_BUSY</a>, m, <a href="ngx_pthread_thread.c.html#L12" title="os/unix/ngx_pthread_thread.c:12">nthreads</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_config.h.html#L102" title="core/ngx_config.h:102">ngx_abort</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="ngx_gcc_atomic_amd64.h.html#L37" title="os/unix/ngx_gcc_atomic_amd64.h:37">ngx_atomic_cmp_set</a>(&amp;m-&gt;lock, old, lock)) {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L138" title="core/ngx_log.h:138">ngx_log_debug2</a>(<a href="../../core/ngx_log.h.html#L28" title="core/ngx_log.h:28">NGX_LOG_DEBUG_MUTEX</a>, m-&gt;log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;wait mutex </span><span class="Special">%p</span><span class="Constant"> lock:</span><span class="Special">%X</span><span class="Constant">D&quot;</span>, m, m-&gt;lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The number of the waiting threads has been increased<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and we would wait on the SysV semaphore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A semaphore should wake up us more efficiently than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a simple sched_yield() or usleep().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op.sem_num = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op.sem_op = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op.sem_flg = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (semop(m-&gt;semid, &amp;op, <span class="Constant">1</span>) == -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, m-&gt;log, <a href="ngx_errno.h.html#L68" title="os/unix/ngx_errno.h:68">ngx_errno</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;semop() failed while waiting on mutex </span><span class="Special">%p</span><span class="Constant">&quot;</span>, m);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_config.h.html#L102" title="core/ngx_config.h:102">ngx_abort</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L138" title="core/ngx_log.h:138">ngx_log_debug2</a>(<a href="../../core/ngx_log.h.html#L28" title="core/ngx_log.h:28">NGX_LOG_DEBUG_MUTEX</a>, m-&gt;log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;mutex waked up </span><span class="Special">%p</span><span class="Constant"> lock:</span><span class="Special">%X</span><span class="Constant">D&quot;</span>, m, m-&gt;lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tries = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old = m-&gt;lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old = m-&gt;lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; } <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock = old | <a href="ngx_freebsd_rfork_thread.h.html#L26" title="os/unix/ngx_freebsd_rfork_thread.h:26">NGX_MUTEX_LOCK_BUSY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="ngx_gcc_atomic_amd64.h.html#L37" title="os/unix/ngx_gcc_atomic_amd64.h:37">ngx_atomic_cmp_set</a>(&amp;m-&gt;lock, old, lock)) {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we locked the mutex */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old = m-&gt;lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tries++ &gt; <span class="Constant">1000</span>) {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L135" title="core/ngx_log.h:135">ngx_log_debug1</a>(<a href="../../core/ngx_log.h.html#L28" title="core/ngx_log.h:28">NGX_LOG_DEBUG_MUTEX</a>, m-&gt;log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;mutex </span><span class="Special">%p</span><span class="Constant"> is contested&quot;</span>, m);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the mutex is probably contested so we are giving up now */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sched_yield();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tries = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old = m-&gt;lock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L138" title="core/ngx_log.h:138">ngx_log_debug2</a>(<a href="../../core/ngx_log.h.html#L28" title="core/ngx_log.h:28">NGX_LOG_DEBUG_MUTEX</a>, m-&gt;log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;mutex </span><span class="Special">%p</span><span class="Constant"> is locked, lock:</span><span class="Special">%X</span><span class="Constant">D&quot;</span>, m, m-&gt;lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L29" title="core/ngx_core.h:29">NGX_OK</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L499">&#x200c;</a></span><span class="linkable">ngx_mutex_unlock</span>(<a href="ngx_thread.h.html#L53" title="os/unix/ngx_thread.h:53">ngx_mutex_t</a> *m)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">uint32_t</span>&nbsp; &nbsp; &nbsp;&nbsp; lock, old;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> sembuf&nbsp; op;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="ngx_process_cycle.c.html#L37" title="os/unix/ngx_process_cycle.c:37">ngx_threaded</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; old = m-&gt;lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(old &amp; <a href="ngx_freebsd_rfork_thread.h.html#L26" title="os/unix/ngx_freebsd_rfork_thread.h:26">NGX_MUTEX_LOCK_BUSY</a>)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, m-&gt;log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;trying to unlock the free mutex </span><span class="Special">%p</span><span class="Constant">&quot;</span>, m);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_config.h.html#L102" title="core/ngx_config.h:102">ngx_abort</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* free the mutex */<br/></li>
<li></span><br/></li>
<li><span class="Comment">#if 0<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L138" title="core/ngx_log.h:138">ngx_log_debug2</a>(<a href="../../core/ngx_log.h.html#L28" title="core/ngx_log.h:28">NGX_LOG_DEBUG_MUTEX</a>, m-&gt;log, 0,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &quot;unlock mutex %p lock:%XD&quot;, m, old);<br/></li>
<li></span><span class="Comment">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> ( ;; ) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock = old &amp; ~<a href="ngx_freebsd_rfork_thread.h.html#L26" title="os/unix/ngx_freebsd_rfork_thread.h:26">NGX_MUTEX_LOCK_BUSY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="ngx_gcc_atomic_amd64.h.html#L37" title="os/unix/ngx_gcc_atomic_amd64.h:37">ngx_atomic_cmp_set</a>(&amp;m-&gt;lock, old, lock)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; old = m-&gt;lock;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (m-&gt;semid == -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L135" title="core/ngx_log.h:135">ngx_log_debug1</a>(<a href="../../core/ngx_log.h.html#L28" title="core/ngx_log.h:28">NGX_LOG_DEBUG_MUTEX</a>, m-&gt;log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;mutex </span><span class="Special">%p</span><span class="Constant"> is unlocked&quot;</span>, m);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check whether we need to wake up a waiting thread */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; old = m-&gt;lock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> ( ;; ) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old &amp; <a href="ngx_freebsd_rfork_thread.h.html#L26" title="os/unix/ngx_freebsd_rfork_thread.h:26">NGX_MUTEX_LOCK_BUSY</a>) {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the mutex is just locked by another thread */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old == <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there are the waiting threads */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock = old - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="ngx_gcc_atomic_amd64.h.html#L37" title="os/unix/ngx_gcc_atomic_amd64.h:37">ngx_atomic_cmp_set</a>(&amp;m-&gt;lock, old, lock)) {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wake up the thread that waits on semaphore */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L135" title="core/ngx_log.h:135">ngx_log_debug1</a>(<a href="../../core/ngx_log.h.html#L28" title="core/ngx_log.h:28">NGX_LOG_DEBUG_MUTEX</a>, m-&gt;log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;wake up mutex </span><span class="Special">%p</span><span class="Constant">&quot;</span>, m);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op.sem_num = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op.sem_op = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op.sem_flg = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (semop(m-&gt;semid, &amp;op, <span class="Constant">1</span>) == -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, m-&gt;log, <a href="ngx_errno.h.html#L68" title="os/unix/ngx_errno.h:68">ngx_errno</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;semop() failed while waking up on mutex </span><span class="Special">%p</span><span class="Constant">&quot;</span>, m);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_config.h.html#L102" title="core/ngx_config.h:102">ngx_abort</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; old = m-&gt;lock;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L135" title="core/ngx_log.h:135">ngx_log_debug1</a>(<a href="../../core/ngx_log.h.html#L28" title="core/ngx_log.h:28">NGX_LOG_DEBUG_MUTEX</a>, m-&gt;log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;mutex </span><span class="Special">%p</span><span class="Constant"> is unlocked&quot;</span>, m);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a href="ngx_thread.h.html#L58" title="os/unix/ngx_thread.h:58">ngx_cond_t</a> *<br/></li>
<li><a id="L591">&#x200c;</a><span class="linkable">ngx_cond_init</span>(<a href="../../core/ngx_core.h.html#L17" title="core/ngx_core.h:17">ngx_log_t</a> *log)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="ngx_thread.h.html#L58" title="os/unix/ngx_thread.h:58">ngx_cond_t</a>&nbsp; *cv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cv = <a href="ngx_alloc.c.html#L18" title="os/unix/ngx_alloc.c:18">ngx_alloc</a>(<span class="Statement">sizeof</span>(<a href="ngx_thread.h.html#L58" title="os/unix/ngx_thread.h:58">ngx_cond_t</a>), log);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cv == <span class="Constant">NULL</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cv-&gt;signo = <a href="ngx_freebsd_rfork_thread.h.html#L35" title="os/unix/ngx_freebsd_rfork_thread.h:35">NGX_CV_SIGNAL</a>;<br/></li>
<li>&nbsp; &nbsp; cv-&gt;tid = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; cv-&gt;log = log;<br/></li>
<li>&nbsp; &nbsp; cv-&gt;kq = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cv;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L610">&#x200c;</a></span><span class="linkable">ngx_cond_destroy</span>(<a href="ngx_thread.h.html#L58" title="os/unix/ngx_thread.h:58">ngx_cond_t</a> *cv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (close(cv-&gt;kq) == -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, cv-&gt;log, <a href="ngx_errno.h.html#L68" title="os/unix/ngx_errno.h:68">ngx_errno</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;kqueue close() failed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="ngx_alloc.h.html#L19" title="os/unix/ngx_alloc.h:19">ngx_free</a>(cv);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a href="../../core/ngx_config.h.html#L78" title="core/ngx_config.h:78">ngx_int_t</a><br/></li>
<li><a id="L622">&#x200c;</a><span class="linkable">ngx_cond_wait</span>(<a href="ngx_thread.h.html#L58" title="os/unix/ngx_thread.h:58">ngx_cond_t</a> *cv, <a href="ngx_thread.h.html#L53" title="os/unix/ngx_thread.h:53">ngx_mutex_t</a> *m)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li>&nbsp; &nbsp; <a href="ngx_errno.h.html#L16" title="os/unix/ngx_errno.h:16">ngx_err_t</a>&nbsp; &nbsp; &nbsp; &nbsp; err;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> kevent&nbsp; &nbsp; kev;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> timespec&nbsp; ts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cv-&gt;kq == -<span class="Constant">1</span>) {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to add the EVFILT_SIGNAL filter in the rfork()ed thread.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise the thread would not get a signal event.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, we have not to open the kqueue in the thread,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it is simply handy do it together.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cv-&gt;kq = kqueue();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cv-&gt;kq == -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, cv-&gt;log, <a href="ngx_errno.h.html#L68" title="os/unix/ngx_errno.h:68">ngx_errno</a>, <span class="Constant">&quot;kqueue() failed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L30" title="core/ngx_core.h:30">NGX_ERROR</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L138" title="core/ngx_log.h:138">ngx_log_debug2</a>(<a href="../../core/ngx_log.h.html#L26" title="core/ngx_log.h:26">NGX_LOG_DEBUG_CORE</a>, cv-&gt;log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;cv kq:</span><span class="Special">%d</span><span class="Constant"> signo:</span><span class="Special">%d</span><span class="Constant">&quot;</span>, cv-&gt;kq, cv-&gt;signo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; kev.ident = cv-&gt;signo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; kev.filter = EVFILT_SIGNAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; kev.flags = EV_ADD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; kev.fflags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; kev.data = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; kev.udata = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ts.tv_sec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ts.tv_nsec = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (kevent(cv-&gt;kq, &amp;kev, <span class="Constant">1</span>, <span class="Constant">NULL</span>, <span class="Constant">0</span>, &amp;ts) == -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, cv-&gt;log, <a href="ngx_errno.h.html#L68" title="os/unix/ngx_errno.h:68">ngx_errno</a>, <span class="Constant">&quot;kevent() failed&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L30" title="core/ngx_core.h:30">NGX_ERROR</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cv-&gt;tid = <a href="ngx_thread.h.html#L29" title="os/unix/ngx_thread.h:29">ngx_thread_self</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="ngx_pthread_thread.c.html#L172" title="os/unix/ngx_pthread_thread.c:172">ngx_mutex_unlock</a>(m);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L141" title="core/ngx_log.h:141">ngx_log_debug3</a>(<a href="../../core/ngx_log.h.html#L26" title="core/ngx_log.h:26">NGX_LOG_DEBUG_CORE</a>, cv-&gt;log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;cv </span><span class="Special">%p</span><span class="Constant"> wait, kq:</span><span class="Special">%d</span><span class="Constant">, signo:</span><span class="Special">%d</span><span class="Constant">&quot;</span>, cv, cv-&gt;kq, cv-&gt;signo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> ( ;; ) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n = kevent(cv-&gt;kq, <span class="Constant">NULL</span>, <span class="Constant">0</span>, &amp;kev, <span class="Constant">1</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L138" title="core/ngx_log.h:138">ngx_log_debug2</a>(<a href="../../core/ngx_log.h.html#L26" title="core/ngx_log.h:26">NGX_LOG_DEBUG_CORE</a>, cv-&gt;log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;cv </span><span class="Special">%p</span><span class="Constant"> kevent: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, cv, n);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (n == -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; err = <a href="ngx_errno.h.html#L68" title="os/unix/ngx_errno.h:68">ngx_errno</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>((err == <a href="ngx_errno.h.html#L22" title="os/unix/ngx_errno.h:22">NGX_EINTR</a>) ? <a href="../../core/ngx_log.h.html#L23" title="core/ngx_log.h:23">NGX_LOG_INFO</a> : <a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cv-&gt;log, <a href="ngx_errno.h.html#L68" title="os/unix/ngx_errno.h:68">ngx_errno</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;kevent() failed while waiting condition variable </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (err == <a href="ngx_errno.h.html#L22" title="os/unix/ngx_errno.h:22">NGX_EINTR</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L30" title="core/ngx_core.h:30">NGX_ERROR</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (n == <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, cv-&gt;log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;kevent() returned no events &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;while waiting condition variable </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (kev.filter != EVFILT_SIGNAL) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, cv-&gt;log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;kevent() returned unexpected events: </span><span class="Special">%d</span><span class="Constant"> &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;while waiting condition variable </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kev.filter, cv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (kev.ident != (<span class="Type">uintptr_t</span>) cv-&gt;signo) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, cv-&gt;log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;kevent() returned unexpected signal: </span><span class="Special">%d</span><span class="Constant"> &quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;while waiting condition variable </span><span class="Special">%p</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kev.ident, cv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L135" title="core/ngx_log.h:135">ngx_log_debug1</a>(<a href="../../core/ngx_log.h.html#L26" title="core/ngx_log.h:26">NGX_LOG_DEBUG_CORE</a>, cv-&gt;log, <span class="Constant">0</span>, <span class="Constant">&quot;cv </span><span class="Special">%p</span><span class="Constant"> is waked up&quot;</span>, cv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="ngx_pthread_thread.c.html#L118" title="os/unix/ngx_pthread_thread.c:118">ngx_mutex_lock</a>(m);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L29" title="core/ngx_core.h:29">NGX_OK</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a href="../../core/ngx_config.h.html#L78" title="core/ngx_config.h:78">ngx_int_t</a><br/></li>
<li><a id="L727">&#x200c;</a><span class="linkable">ngx_cond_signal</span>(<a href="ngx_thread.h.html#L58" title="os/unix/ngx_thread.h:58">ngx_cond_t</a> *cv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="ngx_errno.h.html#L16" title="os/unix/ngx_errno.h:16">ngx_err_t</a>&nbsp; err;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L141" title="core/ngx_log.h:141">ngx_log_debug3</a>(<a href="../../core/ngx_log.h.html#L26" title="core/ngx_log.h:26">NGX_LOG_DEBUG_CORE</a>, cv-&gt;log, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;cv </span><span class="Special">%p</span><span class="Constant"> to signal %P </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cv, cv-&gt;tid, cv-&gt;signo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cv-&gt;tid == -<span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L29" title="core/ngx_core.h:29">NGX_OK</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (kill(cv-&gt;tid, cv-&gt;signo) == -<span class="Constant">1</span>) {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; err = <a href="ngx_errno.h.html#L68" title="os/unix/ngx_errno.h:68">ngx_errno</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L83" title="core/ngx_log.h:83">ngx_log_error</a>(<a href="../../core/ngx_log.h.html#L18" title="core/ngx_log.h:18">NGX_LOG_ALERT</a>, cv-&gt;log, err,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;kill() failed while signaling condition variable </span><span class="Special">%p</span><span class="Constant">&quot;</span>, cv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (err == <a href="ngx_errno.h.html#L21" title="os/unix/ngx_errno.h:21">NGX_ESRCH</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cv-&gt;tid = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L30" title="core/ngx_core.h:30">NGX_ERROR</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../core/ngx_log.h.html#L135" title="core/ngx_log.h:135">ngx_log_debug1</a>(<a href="../../core/ngx_log.h.html#L26" title="core/ngx_log.h:26">NGX_LOG_DEBUG_CORE</a>, cv-&gt;log, <span class="Constant">0</span>, <span class="Constant">&quot;cv </span><span class="Special">%p</span><span class="Constant"> is signaled&quot;</span>, cv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../core/ngx_core.h.html#L29" title="core/ngx_core.h:29">NGX_OK</a>;<br/></li>
<li>}<br/></li>
</ol></code>
 </body>
</html>
