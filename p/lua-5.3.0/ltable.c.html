<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>ltable.c - src</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

code {
    font-family: consolas, monospace;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
  <h3>ltable.c - src</h3>
   <a href="../index.html"> Table of Contents </a>
 <h4>Global variables defined</h4>
 <ul>
<li><a href="#L81">dummynode_</a></li>
</ul>
 <h4>Functions defined</h4>
 <ul>
<li><a href="#L151">arrayindex</a></li>
<li><a href="#L225">computesizes</a></li>
<li><a href="#L247">countint</a></li>
<li><a href="#L166">findindex</a></li>
<li><a href="#L423">getfreepos</a></li>
<li><a href="#L101">hashfloat</a></li>
<li><a href="#L415">luaH_free</a></li>
<li><a href="#L540">luaH_get</a></li>
<li><a href="#L497">luaH_getint</a></li>
<li><a href="#L622">luaH_getn</a></li>
<li><a href="#L520">luaH_getstr</a></li>
<li><a href="#L648">luaH_isdummy</a></li>
<li><a href="#L644">luaH_mainposition</a></li>
<li><a href="#L403">luaH_new</a></li>
<li><a href="#L441">luaH_newkey</a></li>
<li><a href="#L193">luaH_next</a></li>
<li><a href="#L335">luaH_resize</a></li>
<li><a href="#L370">luaH_resizearray</a></li>
<li><a href="#L572">luaH_set</a></li>
<li><a href="#L580">luaH_setint</a></li>
<li><a href="#L119">mainposition</a></li>
<li><a href="#L91">numisinteger</a></li>
<li><a href="#L258">numusearray</a></li>
<li><a href="#L284">numusehash</a></li>
<li><a href="#L378">rehash</a></li>
<li><a href="#L301">setarrayvector</a></li>
<li><a href="#L310">setnodevector</a></li>
<li><a href="#L594">unbound_search</a></li>
</ul>
 <h4>Macros defined</h4>
 <ul>
<li><a href="#L8">LUA_CORE</a></li>
<li><a href="#L48">MAXABITS</a></li>
<li><a href="#L49">MAXASIZE</a></li>
<li><a href="#L57">MAXHBITS</a></li>
<li><a href="#L77">dummynode</a></li>
<li><a href="#L63">hashboolean</a></li>
<li><a href="#L64">hashint</a></li>
<li><a href="#L71">hashmod</a></li>
<li><a href="#L74">hashpointer</a></li>
<li><a href="#L60">hashpow2</a></li>
<li><a href="#L62">hashstr</a></li>
<li><a href="#L79">isdummy</a></li>
<li><a href="#L7">ltable_c</a></li>
</ul>
 <h4>Source code</h4>

  <code><ol><li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** $Id: ltable.c,v 2.100 2015/01/05 13:52:37 roberto Exp $<br/></li>
<li></span><span class="Comment">** Lua tables (hash)<br/></li>
<li></span><span class="Comment">** See Copyright Notice in lua.h<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><a id="L7">&#x200c;</a><span class="PreProc">#define <span class="linkable">ltable_c</span><br/></li>
<li><a id="L8">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LUA_CORE</span><br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;lprefix.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** Implementation of tables (aka arrays, objects, or hash tables).<br/></li>
<li></span><span class="Comment">** Tables keep its elements in two parts: an array part and a hash part.<br/></li>
<li></span><span class="Comment">** Non-negative integer keys are all candidates to be kept in the array<br/></li>
<li></span><span class="Comment">** part. The actual size of the array is the largest 'n' such that at<br/></li>
<li></span><span class="Comment">** least half the slots between 0 and n are in use.<br/></li>
<li></span><span class="Comment">** Hash uses a mix of chained scatter table with Brent's variation.<br/></li>
<li></span><span class="Comment">** A <a href="lua.c.html#L595" title="lua.c:595">main</a> invariant of these tables is that, if an element is not<br/></li>
<li></span><span class="Comment">** in its <a href="lua.c.html#L595" title="lua.c:595">main</a> position (i.e. the 'original' position that its hash gives<br/></li>
<li></span><span class="Comment">** to it), then the colliding element is in its own <a href="lua.c.html#L595" title="lua.c:595">main</a> position.<br/></li>
<li></span><span class="Comment">** Hence even when the load factor reaches 100%, performance remains good.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;float.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;lua.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;ldebug.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;ldo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lgc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lobject.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lstate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lstring.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;ltable.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lvm.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** Maximum size of array part (<a href="#L49" title="ltable.c:49">MAXASIZE</a>) is 2^<a href="#L48" title="ltable.c:48">MAXABITS</a>. <a href="#L48" title="ltable.c:48">MAXABITS</a> is<br/></li>
<li></span><span class="Comment">** the largest integer such that <a href="#L49" title="ltable.c:49">MAXASIZE</a> fits in an unsigned int.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L48">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAXABITS</span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="llimits.h.html#L112" title="llimits.h:112">cast_int</a>(</span><span class="Statement">sizeof</span><span class="PreProc">(</span><span class="Type">int</span><span class="PreProc">) * </span><span class="Constant">CHAR_BIT</span><span class="PreProc"> - </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li><a id="L49">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAXASIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; (</span><span class="Constant">1u</span><span class="PreProc"> &lt;&lt; <a href="#L48" title="ltable.c:48">MAXABITS</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** Maximum size of hash part is 2^<a href="#L57" title="ltable.c:57">MAXHBITS</a>. <a href="#L57" title="ltable.c:57">MAXHBITS</a> is the largest<br/></li>
<li></span><span class="Comment">** integer such that 2^<a href="#L57" title="ltable.c:57">MAXHBITS</a> fits in a signed int. (Note that the<br/></li>
<li></span><span class="Comment">** maximum number of elements in a table, 2^<a href="#L48" title="ltable.c:48">MAXABITS</a> + 2^<a href="#L57" title="ltable.c:57">MAXHBITS</a>, still<br/></li>
<li></span><span class="Comment">** fits comfortably in an unsigned int.)<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L57">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAXHBITS</span>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L48" title="ltable.c:48">MAXABITS</a> - </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L60">&#x200c;</a><span class="PreProc">#define <span class="linkable">hashpow2</span>(t,n)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="ltable.h.html#L13" title="ltable.h:13">gnode</a>(t, <a href="lobject.h.html#L505" title="lobject.h:505">lmod</a>((n), <a href="lobject.h.html#L510" title="lobject.h:510">sizenode</a>(t))))<br/></li>
<li></span><br/></li>
<li><a id="L62">&#x200c;</a><span class="PreProc">#define <span class="linkable">hashstr</span>(t,str)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="ltable.c:60">hashpow2</a>(t, (str)-&gt;hash)<br/></li>
<li><a id="L63">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">hashboolean</span>(t,p)&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="ltable.c:60">hashpow2</a>(t, p)<br/></li>
<li><a id="L64">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">hashint</span>(t,i)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L60" title="ltable.c:60">hashpow2</a>(t, i)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** for some types, it is better to avoid modulus by power of 2, as<br/></li>
<li></span><span class="Comment">** they tend to have many 2 factors.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">hashmod</span>(t,n)&nbsp; &nbsp; &nbsp; &nbsp; (<a href="ltable.h.html#L13" title="ltable.h:13">gnode</a>(t, ((n) % ((<a href="lobject.h.html#L510" title="lobject.h:510">sizenode</a>(t)-</span><span class="Constant">1</span><span class="PreProc">)|</span><span class="Constant">1</span><span class="PreProc">))))<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L74">&#x200c;</a><span class="PreProc">#define <span class="linkable">hashpointer</span>(t,p)&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L71" title="ltable.c:71">hashmod</a>(t, <a href="llimits.h.html#L59" title="llimits.h:59">point2int</a>(p))<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L77">&#x200c;</a><span class="PreProc">#define <span class="linkable">dummynode</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (&amp;<a href="#L81" title="ltable.c:81">dummynode_</a>)<br/></li>
<li></span><br/></li>
<li><a id="L79">&#x200c;</a><span class="PreProc">#define <span class="linkable">isdummy</span>(n)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((n) == <a href="#L77" title="ltable.c:77">dummynode</a>)<br/></li>
<li></span><br/></li>
<li><a id="L81">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> <a href="lobject.h.html#L482" title="lobject.h:482">Node</a> <span class="linkable">dummynode_</span> = {<br/></li>
<li>&nbsp; {<a href="lobject.h.html#L112" title="lobject.h:112">NILCONSTANT</a>},&nbsp; <span class="Comment">/* value */<br/></li>
<li></span>&nbsp; {{<a href="lobject.h.html#L112" title="lobject.h:112">NILCONSTANT</a>, <span class="Constant">0</span>}}&nbsp; <span class="Comment">/* key */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** Checks whether a float has a value representable as a <a href="lua.h.html#L91" title="lua.h:91">lua_Integer</a><br/></li>
<li></span><span class="Comment">** (and does the conversion if so)<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L91">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">numisinteger</span> (<a href="lua.h.html#L87" title="lua.h:87">lua_Number</a> x, <a href="lua.h.html#L91" title="lua.h:91">lua_Integer</a> *p) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> ((x) == <a href="luaconf.h.html#L450" title="luaconf.h:450">l_floor</a>(x))&nbsp; <span class="Comment">/* integral value? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="luaconf.h.html#L463" title="luaconf.h:463">lua_numbertointeger</a>(x, p);&nbsp; <span class="Comment">/* try as an integer */<br/></li>
<li></span>&nbsp; <span class="Statement">else</span> <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** hash for floating-point numbers<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L101">&#x200c;</a></span><span class="Type">static</span> <a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *<span class="linkable">hashfloat</span> (<span class="Type">const</span> <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t, <a href="lua.h.html#L87" title="lua.h:87">lua_Number</a> n) {<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; n = <a href="luaconf.h.html#L412" title="luaconf.h:412">l_mathop</a>(frexp)(n, &amp;i) * <a href="llimits.h.html#L111" title="llimits.h:111">cast_num</a>(<span class="Constant">INT_MAX</span> - <span class="Constant">DBL_MAX_EXP</span>);<br/></li>
<li>&nbsp; i += <a href="llimits.h.html#L112" title="llimits.h:112">cast_int</a>(n);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (i &lt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="llimits.h.html#L107" title="llimits.h:107">cast</a>(<span class="Type">unsigned</span> <span class="Type">int</span>, i) == <span class="Constant">0u</span> - i)&nbsp; <span class="Comment">/* use unsigned to avoid overflows */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* handle INT_MIN */<br/></li>
<li></span>&nbsp; &nbsp; i = -i;&nbsp; <span class="Comment">/* must be a positive value */<br/></li>
<li></span>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L71" title="ltable.c:71">hashmod</a>(t, i);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** returns the '<a href="lua.c.html#L595" title="lua.c:595">main</a>' position of an element in a table (that is, the index<br/></li>
<li></span><span class="Comment">** of its hash value)<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L119">&#x200c;</a></span><span class="Type">static</span> <a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *<span class="linkable">mainposition</span> (<span class="Type">const</span> <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t, <span class="Type">const</span> <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *key) {<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (<a href="lobject.h.html#L125" title="lobject.h:125">ttype</a>(key)) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L61" title="lobject.h:61">LUA_TNUMINT</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L64" title="ltable.c:64">hashint</a>(t, <a href="lobject.h.html#L155" title="lobject.h:155">ivalue</a>(key));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L60" title="lobject.h:60">LUA_TNUMFLT</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L101" title="ltable.c:101">hashfloat</a>(t, <a href="lobject.h.html#L156" title="lobject.h:156">fltvalue</a>(key));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L55" title="lobject.h:55">LUA_TSHRSTR</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L62" title="ltable.c:62">hashstr</a>(t, <a href="lobject.h.html#L161" title="lobject.h:161">tsvalue</a>(key));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L56" title="lobject.h:56">LUA_TLNGSTR</a>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *s = <a href="lobject.h.html#L161" title="lobject.h:161">tsvalue</a>(key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;extra == <span class="Constant">0</span>) {&nbsp; <span class="Comment">/* no hash? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;hash = <a href="lstring.c.html#L47" title="lstring.c:47">luaS_hash</a>(<a href="lobject.h.html#L326" title="lobject.h:326">getstr</a>(s), s-&gt;len, s-&gt;hash);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;extra = <span class="Constant">1</span>;&nbsp; <span class="Comment">/* now it has its hash */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L62" title="ltable.c:62">hashstr</a>(t, <a href="lobject.h.html#L161" title="lobject.h:161">tsvalue</a>(key));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lua.h.html#L63" title="lua.h:63">LUA_TBOOLEAN</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L63" title="ltable.c:63">hashboolean</a>(t, <a href="lobject.h.html#L168" title="lobject.h:168">bvalue</a>(key));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lua.h.html#L64" title="lua.h:64">LUA_TLIGHTUSERDATA</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L74" title="ltable.c:74">hashpointer</a>(t, <a href="lobject.h.html#L160" title="lobject.h:160">pvalue</a>(key));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L50" title="lobject.h:50">LUA_TLCF</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L74" title="ltable.c:74">hashpointer</a>(t, <a href="lobject.h.html#L166" title="lobject.h:166">fvalue</a>(key));<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L74" title="ltable.c:74">hashpointer</a>(t, <a href="lobject.h.html#L159" title="lobject.h:159">gcvalue</a>(key));<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** returns the index for 'key' if 'key' is an appropriate key to live in<br/></li>
<li></span><span class="Comment">** the array part of the table, 0 otherwise.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L151">&#x200c;</a></span><span class="Type">static</span> <span class="Type">unsigned</span> <span class="Type">int</span> <span class="linkable">arrayindex</span> (<span class="Type">const</span> <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *key) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="lobject.h.html#L136" title="lobject.h:136">ttisinteger</a>(key)) {<br/></li>
<li>&nbsp; &nbsp; <a href="lua.h.html#L91" title="lua.h:91">lua_Integer</a> k = <a href="lobject.h.html#L155" title="lobject.h:155">ivalue</a>(key);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<span class="Constant">0</span> &lt; k &amp;&amp; (<a href="lua.h.html#L94" title="lua.h:94">lua_Unsigned</a>)k &lt;= <a href="#L49" title="ltable.c:49">MAXASIZE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="llimits.h.html#L107" title="llimits.h:107">cast</a>(<span class="Type">unsigned</span> <span class="Type">int</span>, k);&nbsp; <span class="Comment">/* 'key' is an appropriate array index */<br/></li>
<li></span>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; <span class="Comment">/* 'key' did not <a href="lstrlib.c.html#L420" title="lstrlib.c:420">match</a> some condition */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** returns the index of a 'key' for table traversals. First goes all<br/></li>
<li></span><span class="Comment">** elements in the array part, then elements in the hash part. The<br/></li>
<li></span><span class="Comment">** beginning of a traversal is signaled by 0.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L166">&#x200c;</a></span><span class="Type">static</span> <span class="Type">unsigned</span> <span class="Type">int</span> <span class="linkable">findindex</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t, <a href="lobject.h.html#L294" title="lobject.h:294">StkId</a> key) {<br/></li>
<li>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(key)) <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; <span class="Comment">/* first iteration */<br/></li>
<li></span>&nbsp; i = <a href="#L151" title="ltable.c:151">arrayindex</a>(key);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (i != <span class="Constant">0</span> &amp;&amp; i &lt;= t-&gt;sizearray)&nbsp; <span class="Comment">/* is 'key' inside array part? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> i;&nbsp; <span class="Comment">/* yes; that's the index */<br/></li>
<li></span>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> nx;<br/></li>
<li>&nbsp; &nbsp; <a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *n = <a href="#L119" title="ltable.c:119">mainposition</a>(t, key);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;) {&nbsp; <span class="Comment">/* <a href="lparser.c.html#L106" title="lparser.c:106">check</a> whether 'key' is somewhere in the chain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Comment">/* key may be dead already, but it is ok to use it in '<a href="llex.c.html#L31" title="llex.c:31">next</a>' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="lvm.h.html#L38" title="lvm.h:38">luaV_rawequalobj</a>(<a href="ltable.h.html#L19" title="ltable.h:19">gkey</a>(n), key) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="lobject.h.html#L151" title="lobject.h:151">ttisdeadkey</a>(<a href="ltable.h.html#L19" title="ltable.h:19">gkey</a>(n)) &amp;&amp; <a href="lobject.h.html#L176" title="lobject.h:176">iscollectable</a>(key) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="lobject.h.html#L171" title="lobject.h:171">deadvalue</a>(<a href="ltable.h.html#L19" title="ltable.h:19">gkey</a>(n)) == <a href="lobject.h.html#L159" title="lobject.h:159">gcvalue</a>(key))) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = <a href="llimits.h.html#L112" title="llimits.h:112">cast_int</a>(n - <a href="ltable.h.html#L13" title="ltable.h:13">gnode</a>(t, <span class="Constant">0</span>));&nbsp; <span class="Comment">/* key index in hash table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* hash elements are numbered after array ones */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (i + <span class="Constant">1</span>) + t-&gt;sizearray;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; nx = <a href="ltable.h.html#L15" title="ltable.h:15">gnext</a>(n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nx == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="ldebug.c.html#L603" title="ldebug.c:603">luaG_runerror</a>(L, <span class="Constant">&quot;invalid key to '<a href="llex.c.html#L31" title="llex.c:31">next</a>'&quot;</span>);&nbsp; <span class="Comment">/* key not found */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">else</span> n += nx;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L193">&#x200c;</a><span class="Type">int</span> <span class="linkable">luaH_next</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t, <a href="lobject.h.html#L294" title="lobject.h:294">StkId</a> key) {<br/></li>
<li>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> i = <a href="#L166" title="ltable.c:166">findindex</a>(L, t, key);&nbsp; <span class="Comment">/* find original element */<br/></li>
<li></span>&nbsp; <span class="Statement">for</span> (; i &lt; t-&gt;sizearray; i++) {&nbsp; <span class="Comment">/* try first array part */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(&amp;t-&gt;array[i])) {&nbsp; <span class="Comment">/* a non-nil value? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L193" title="lobject.h:193">setivalue</a>(key, i + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L257" title="lobject.h:257">setobj2s</a>(L, key+<span class="Constant">1</span>, &amp;t-&gt;array[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i -= t-&gt;sizearray; <a href="llimits.h.html#L112" title="llimits.h:112">cast_int</a>(i) &lt; <a href="lobject.h.html#L510" title="lobject.h:510">sizenode</a>(t); i++) {&nbsp; <span class="Comment">/* hash part */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(<a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(<a href="ltable.h.html#L13" title="ltable.h:13">gnode</a>(t, i)))) {&nbsp; <span class="Comment">/* a non-nil value? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L257" title="lobject.h:257">setobj2s</a>(L, key, <a href="ltable.h.html#L19" title="ltable.h:19">gkey</a>(<a href="ltable.h.html#L13" title="ltable.h:13">gnode</a>(t, i)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L257" title="lobject.h:257">setobj2s</a>(L, key+<span class="Constant">1</span>, <a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(<a href="ltable.h.html#L13" title="ltable.h:13">gnode</a>(t, i)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; <span class="Comment">/* no more elements */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** {=============================================================<br/></li>
<li></span><span class="Comment">** Rehash<br/></li>
<li></span><span class="Comment">** ==============================================================<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** Compute the optimal size for the array part of table 't'. 'nums' is a<br/></li>
<li></span><span class="Comment">** &quot;count array&quot; where 'nums[i]' is the number of integers in the table<br/></li>
<li></span><span class="Comment">** between 2^(i - 1) + 1 and 2^i. Put in '*narray' the optimal size, and<br/></li>
<li></span><span class="Comment">** return the number of elements that will go to that part.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L225">&#x200c;</a></span><span class="Type">static</span> <span class="Type">unsigned</span> <span class="Type">int</span> <span class="linkable">computesizes</span> (<span class="Type">unsigned</span> <span class="Type">int</span> nums[], <span class="Type">unsigned</span> <span class="Type">int</span> *narray) {<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> twotoi;&nbsp; <span class="Comment">/* 2^i */<br/></li>
<li></span>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> a = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* number of elements smaller than 2^i */<br/></li>
<li></span>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> na = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* number of elements to go to array part */<br/></li>
<li></span>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> n = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* optimal size for array part */<br/></li>
<li></span>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>, twotoi = <span class="Constant">1</span>; twotoi/<span class="Constant">2</span> &lt; *narray; i++, twotoi *= <span class="Constant">2</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nums[i] &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; a += nums[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (a &gt; twotoi/<span class="Constant">2</span>) {&nbsp; <span class="Comment">/* more than half elements present? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; n = twotoi;&nbsp; <span class="Comment">/* optimal size (till now) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; na = a;&nbsp; <span class="Comment">/* all elements up to 'n' will go to array part */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (a == *narray) <span class="Statement">break</span>;&nbsp; <span class="Comment">/* all elements already counted */<br/></li>
<li></span>&nbsp; }<br/></li>
<li>&nbsp; *narray = n;<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(*narray/<span class="Constant">2</span> &lt;= na &amp;&amp; na &lt;= *narray);<br/></li>
<li>&nbsp; <span class="Statement">return</span> na;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L247">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">countint</span> (<span class="Type">const</span> <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *key, <span class="Type">unsigned</span> <span class="Type">int</span> *nums) {<br/></li>
<li>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> k = <a href="#L151" title="ltable.c:151">arrayindex</a>(key);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (k != <span class="Constant">0</span>) {&nbsp; <span class="Comment">/* is 'key' an appropriate array index? */<br/></li>
<li></span>&nbsp; &nbsp; nums[<a href="lobject.c.html#L58" title="lobject.c:58">luaO_ceillog2</a>(k)]++;&nbsp; <span class="Comment">/* count as such */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L258">&#x200c;</a><span class="Type">static</span> <span class="Type">unsigned</span> <span class="Type">int</span> <span class="linkable">numusearray</span> (<span class="Type">const</span> <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t, <span class="Type">unsigned</span> <span class="Type">int</span> *nums) {<br/></li>
<li>&nbsp; <span class="Type">int</span> lg;<br/></li>
<li>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> ttlg;&nbsp; <span class="Comment">/* 2^lg */<br/></li>
<li></span>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> ause = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* summation of 'nums' */<br/></li>
<li></span>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> i = <span class="Constant">1</span>;&nbsp; <span class="Comment">/* count to traverse all array keys */<br/></li>
<li></span>&nbsp; <span class="Comment">/* traverse each slice */<br/></li>
<li></span>&nbsp; <span class="Statement">for</span> (lg = <span class="Constant">0</span>, ttlg = <span class="Constant">1</span>; lg &lt;= <a href="#L48" title="ltable.c:48">MAXABITS</a>; lg++, ttlg *= <span class="Constant">2</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> lc = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* counter */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> lim = ttlg;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lim &gt; t-&gt;sizearray) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; lim = t-&gt;sizearray;&nbsp; <span class="Comment">/* adjust upper limit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt; lim)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; <span class="Comment">/* no more elements to count */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* count elements in range (2^(lg - 1), 2^lg] */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (; i &lt;= lim; i++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(&amp;t-&gt;array[i-<span class="Constant">1</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lc++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; nums[lg] += lc;<br/></li>
<li>&nbsp; &nbsp; ause += lc;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> ause;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L284">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">numusehash</span> (<span class="Type">const</span> <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t, <span class="Type">unsigned</span> <span class="Type">int</span> *nums,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> *pnasize) {<br/></li>
<li>&nbsp; <span class="Type">int</span> totaluse = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* total number of elements */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> ause = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* elements added to 'nums' (can go to array part) */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> i = <a href="lobject.h.html#L510" title="lobject.h:510">sizenode</a>(t);<br/></li>
<li>&nbsp; <span class="Statement">while</span> (i--) {<br/></li>
<li>&nbsp; &nbsp; <a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *n = &amp;t-&gt;node[i];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(<a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(n))) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; ause += <a href="#L247" title="ltable.c:247">countint</a>(<a href="ltable.h.html#L19" title="ltable.h:19">gkey</a>(n), nums);<br/></li>
<li>&nbsp; &nbsp; &nbsp; totaluse++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; *pnasize += ause;<br/></li>
<li>&nbsp; <span class="Statement">return</span> totaluse;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L301">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">setarrayvector</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t, <span class="Type">unsigned</span> <span class="Type">int</span> size) {<br/></li>
<li>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <a href="lmem.h.html#L56" title="lmem.h:56">luaM_reallocvector</a>(L, t-&gt;array, t-&gt;sizearray, size, <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a>);<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i=t-&gt;sizearray; i&lt;size; i++)<br/></li>
<li>&nbsp; &nbsp;&nbsp; <a href="lobject.h.html#L196" title="lobject.h:196">setnilvalue</a>(&amp;t-&gt;array[i]);<br/></li>
<li>&nbsp; t-&gt;sizearray = size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L310">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">setnodevector</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t, <span class="Type">unsigned</span> <span class="Type">int</span> size) {<br/></li>
<li>&nbsp; <span class="Type">int</span> lsize;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (size == <span class="Constant">0</span>) {&nbsp; <span class="Comment">/* no elements to hash part? */<br/></li>
<li></span>&nbsp; &nbsp; t-&gt;node = <a href="llimits.h.html#L107" title="llimits.h:107">cast</a>(<a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *, <a href="#L77" title="ltable.c:77">dummynode</a>);&nbsp; <span class="Comment">/* use common '<a href="#L77" title="ltable.c:77">dummynode</a>' */<br/></li>
<li></span>&nbsp; &nbsp; lsize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; &nbsp; lsize = <a href="lobject.c.html#L58" title="lobject.c:58">luaO_ceillog2</a>(size);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lsize &gt; <a href="#L57" title="ltable.c:57">MAXHBITS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="ldebug.c.html#L603" title="ldebug.c:603">luaG_runerror</a>(L, <span class="Constant">&quot;table overflow&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; size = <a href="lobject.h.html#L509" title="lobject.h:509">twoto</a>(lsize);<br/></li>
<li>&nbsp; &nbsp; t-&gt;node = <a href="lmem.h.html#L47" title="lmem.h:47">luaM_newvector</a>(L, size, <a href="lobject.h.html#L482" title="lobject.h:482">Node</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; (<span class="Type">int</span>)size; i++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *n = <a href="ltable.h.html#L13" title="ltable.h:13">gnode</a>(t, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="ltable.h.html#L15" title="ltable.h:15">gnext</a>(n) = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L196" title="lobject.h:196">setnilvalue</a>(<a href="ltable.h.html#L21" title="ltable.h:21">wgkey</a>(n));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L196" title="lobject.h:196">setnilvalue</a>(<a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(n));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; t-&gt;lsizenode = <a href="llimits.h.html#L110" title="llimits.h:110">cast_byte</a>(lsize);<br/></li>
<li>&nbsp; t-&gt;lastfree = <a href="ltable.h.html#L13" title="ltable.h:13">gnode</a>(t, size);&nbsp; <span class="Comment">/* all positions are free */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L335">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaH_resize</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t, <span class="Type">unsigned</span> <span class="Type">int</span> nasize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> nhsize) {<br/></li>
<li>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Type">int</span> j;<br/></li>
<li>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> oldasize = t-&gt;sizearray;<br/></li>
<li>&nbsp; <span class="Type">int</span> oldhsize = t-&gt;lsizenode;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *nold = t-&gt;node;&nbsp; <span class="Comment">/* <a href="llex.c.html#L56" title="llex.c:56">save</a> old hash ... */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (nasize &gt; oldasize)&nbsp; <span class="Comment">/* array part must grow? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L301" title="ltable.c:301">setarrayvector</a>(L, t, nasize);<br/></li>
<li>&nbsp; <span class="Comment">/* create new hash part with appropriate size */<br/></li>
<li></span>&nbsp; <a href="#L310" title="ltable.c:310">setnodevector</a>(L, t, nhsize);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (nasize &lt; oldasize) {&nbsp; <span class="Comment">/* array part must shrink? */<br/></li>
<li></span>&nbsp; &nbsp; t-&gt;sizearray = nasize;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* re-insert elements from vanishing slice */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i=nasize; i&lt;oldasize; i++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(&amp;t-&gt;array[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L580" title="ltable.c:580">luaH_setint</a>(L, t, i + <span class="Constant">1</span>, &amp;t-&gt;array[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* shrink array */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lmem.h.html#L56" title="lmem.h:56">luaM_reallocvector</a>(L, t-&gt;array, oldasize, nasize, <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* re-insert elements from hash part */<br/></li>
<li></span>&nbsp; <span class="Statement">for</span> (j = <a href="lobject.h.html#L509" title="lobject.h:509">twoto</a>(oldhsize) - <span class="Constant">1</span>; j &gt;= <span class="Constant">0</span>; j--) {<br/></li>
<li>&nbsp; &nbsp; <a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *old = nold + j;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(<a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(old))) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* doesn't need barrier/invalidate cache, as entry was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; already present in the table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L262" title="lobject.h:262">setobjt2t</a>(L, <a href="#L572" title="ltable.c:572">luaH_set</a>(L, t, <a href="ltable.h.html#L19" title="ltable.h:19">gkey</a>(old)), <a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(old));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">if</span> (!<a href="#L79" title="ltable.c:79">isdummy</a>(nold))<br/></li>
<li>&nbsp; &nbsp; <a href="lmem.h.html#L43" title="lmem.h:43">luaM_freearray</a>(L, nold, <a href="llimits.h.html#L107" title="llimits.h:107">cast</a>(<span class="Type">size_t</span>, <a href="lobject.h.html#L509" title="lobject.h:509">twoto</a>(oldhsize))); <span class="Comment">/* free old array */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L370">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaH_resizearray</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t, <span class="Type">unsigned</span> <span class="Type">int</span> nasize) {<br/></li>
<li>&nbsp; <span class="Type">int</span> nsize = <a href="#L79" title="ltable.c:79">isdummy</a>(t-&gt;node) ? <span class="Constant">0</span> : <a href="lobject.h.html#L510" title="lobject.h:510">sizenode</a>(t);<br/></li>
<li>&nbsp; <a href="#L335" title="ltable.c:335">luaH_resize</a>(L, t, nasize, nsize);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** nums[i] = number of keys 'k' where 2^(i - 1) &lt; k &lt;= 2^i<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L378">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">rehash</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t, <span class="Type">const</span> <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *ek) {<br/></li>
<li>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> nasize, na;<br/></li>
<li>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> nums[<a href="#L48" title="ltable.c:48">MAXABITS</a> + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Type">int</span> totaluse;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt;= <a href="#L48" title="ltable.c:48">MAXABITS</a>; i++) nums[i] = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* reset counts */<br/></li>
<li></span>&nbsp; nasize = <a href="#L258" title="ltable.c:258">numusearray</a>(t, nums);&nbsp; <span class="Comment">/* count keys in array part */<br/></li>
<li></span>&nbsp; totaluse = nasize;&nbsp; <span class="Comment">/* all those keys are integer keys */<br/></li>
<li></span>&nbsp; totaluse += <a href="#L284" title="ltable.c:284">numusehash</a>(t, nums, &amp;nasize);&nbsp; <span class="Comment">/* count keys in hash part */<br/></li>
<li></span>&nbsp; <span class="Comment">/* count extra key */<br/></li>
<li></span>&nbsp; nasize += <a href="#L247" title="ltable.c:247">countint</a>(ek, nums);<br/></li>
<li>&nbsp; totaluse++;<br/></li>
<li>&nbsp; <span class="Comment">/* compute new size for array part */<br/></li>
<li></span>&nbsp; na = <a href="#L225" title="ltable.c:225">computesizes</a>(nums, &amp;nasize);<br/></li>
<li>&nbsp; <span class="Comment">/* resize the table to new computed sizes */<br/></li>
<li></span>&nbsp; <a href="#L335" title="ltable.c:335">luaH_resize</a>(L, t, nasize, totaluse - na);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** }=============================================================<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L403">&#x200c;</a><a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *<span class="linkable">luaH_new</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *o = <a href="lgc.c.html#L198" title="lgc.c:198">luaC_newobj</a>(L, <a href="lua.h.html#L67" title="lua.h:67">LUA_TTABLE</a>, <span class="Statement">sizeof</span>(<a href="lobject.h.html#L488" title="lobject.h:488">Table</a>));<br/></li>
<li>&nbsp; <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t = <a href="lstate.h.html#L202" title="lstate.h:202">gco2t</a>(o);<br/></li>
<li>&nbsp; t-&gt;metatable = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; t-&gt;flags = <a href="llimits.h.html#L110" title="llimits.h:110">cast_byte</a>(~<span class="Constant">0</span>);<br/></li>
<li>&nbsp; t-&gt;array = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; t-&gt;sizearray = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <a href="#L310" title="ltable.c:310">setnodevector</a>(L, t, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Statement">return</span> t;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L415">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaH_free</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (!<a href="#L79" title="ltable.c:79">isdummy</a>(t-&gt;node))<br/></li>
<li>&nbsp; &nbsp; <a href="lmem.h.html#L43" title="lmem.h:43">luaM_freearray</a>(L, t-&gt;node, <a href="llimits.h.html#L107" title="llimits.h:107">cast</a>(<span class="Type">size_t</span>, <a href="lobject.h.html#L510" title="lobject.h:510">sizenode</a>(t)));<br/></li>
<li>&nbsp; <a href="lmem.h.html#L43" title="lmem.h:43">luaM_freearray</a>(L, t-&gt;array, t-&gt;sizearray);<br/></li>
<li>&nbsp; <a href="lmem.h.html#L42" title="lmem.h:42">luaM_free</a>(L, t);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L423">&#x200c;</a><span class="Type">static</span> <a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *<span class="linkable">getfreepos</span> (<a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t) {<br/></li>
<li>&nbsp; <span class="Statement">while</span> (t-&gt;lastfree &gt; t-&gt;node) {<br/></li>
<li>&nbsp; &nbsp; t-&gt;lastfree--;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(<a href="ltable.h.html#L19" title="ltable.h:19">gkey</a>(t-&gt;lastfree)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> t-&gt;lastfree;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; <span class="Comment">/* could not find a free place */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** inserts a new key into a hash table; first, <a href="lparser.c.html#L106" title="lparser.c:106">check</a> whether key's <a href="lua.c.html#L595" title="lua.c:595">main</a><br/></li>
<li></span><span class="Comment">** position is free. If not, <a href="lparser.c.html#L106" title="lparser.c:106">check</a> whether colliding node is in its <a href="lua.c.html#L595" title="lua.c:595">main</a><br/></li>
<li></span><span class="Comment">** position or not: if it is not, move colliding node to an empty place and<br/></li>
<li></span><span class="Comment">** put new key in its <a href="lua.c.html#L595" title="lua.c:595">main</a> position; otherwise (colliding node is in its <a href="lua.c.html#L595" title="lua.c:595">main</a><br/></li>
<li></span><span class="Comment">** position), new key goes to an empty position.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L441">&#x200c;</a></span><a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *<span class="linkable">luaH_newkey</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t, <span class="Type">const</span> <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *key) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *mp;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> aux;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(key)) <a href="ldebug.c.html#L603" title="ldebug.c:603">luaG_runerror</a>(L, <span class="Constant">&quot;table index is nil&quot;</span>);<br/></li>
<li>&nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="lobject.h.html#L135" title="lobject.h:135">ttisfloat</a>(key)) {<br/></li>
<li>&nbsp; &nbsp; <a href="lua.h.html#L87" title="lua.h:87">lua_Number</a> n = <a href="lobject.h.html#L156" title="lobject.h:156">fltvalue</a>(key);<br/></li>
<li>&nbsp; &nbsp; <a href="lua.h.html#L91" title="lua.h:91">lua_Integer</a> k;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="luaconf.h.html#L506" title="luaconf.h:506">luai_numisnan</a>(n))<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="ldebug.c.html#L603" title="ldebug.c:603">luaG_runerror</a>(L, <span class="Constant">&quot;table index is NaN&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L91" title="ltable.c:91">numisinteger</a>(n, &amp;k)) {&nbsp; <span class="Comment">/* index is int? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L193" title="lobject.h:193">setivalue</a>(&amp;aux, k);<br/></li>
<li>&nbsp; &nbsp; &nbsp; key = &amp;aux;&nbsp; <span class="Comment">/* insert it as an integer */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; mp = <a href="#L119" title="ltable.c:119">mainposition</a>(t, key);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (!<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(<a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(mp)) || <a href="#L79" title="ltable.c:79">isdummy</a>(mp)) {&nbsp; <span class="Comment">/* <a href="lua.c.html#L595" title="lua.c:595">main</a> position is taken? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *othern;<br/></li>
<li>&nbsp; &nbsp; <a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *f = <a href="#L423" title="ltable.c:423">getfreepos</a>(t);&nbsp; <span class="Comment">/* get a free place */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (f == <span class="Constant">NULL</span>) {&nbsp; <span class="Comment">/* <a href="luac.c.html#L44" title="luac.c:44">cannot</a> find a free place? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L378" title="ltable.c:378">rehash</a>(L, t, key);&nbsp; <span class="Comment">/* grow table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Comment">/* whatever called 'newkey' takes care of TM cache and GC barrier */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L572" title="ltable.c:572">luaH_set</a>(L, t, key);&nbsp; <span class="Comment">/* insert key into grown table */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(!<a href="#L79" title="ltable.c:79">isdummy</a>(f));<br/></li>
<li>&nbsp; &nbsp; othern = <a href="#L119" title="ltable.c:119">mainposition</a>(t, <a href="ltable.h.html#L19" title="ltable.h:19">gkey</a>(mp));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (othern != mp) {&nbsp; <span class="Comment">/* is colliding node out of its <a href="lua.c.html#L595" title="lua.c:595">main</a> position? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Comment">/* yes; move colliding node into free position */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (othern + <a href="ltable.h.html#L15" title="ltable.h:15">gnext</a>(othern) != mp)&nbsp; <span class="Comment">/* find previous */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; othern += <a href="ltable.h.html#L15" title="ltable.h:15">gnext</a>(othern);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="ltable.h.html#L15" title="ltable.h:15">gnext</a>(othern) = <a href="llimits.h.html#L112" title="llimits.h:112">cast_int</a>(f - othern);&nbsp; <span class="Comment">/* rechain to point to 'f' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; *f = *mp;&nbsp; <span class="Comment">/* copy colliding node into free pos. (mp-&gt;<a href="llex.c.html#L31" title="llex.c:31">next</a> also goes) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="ltable.h.html#L15" title="ltable.h:15">gnext</a>(mp) != <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="ltable.h.html#L15" title="ltable.h:15">gnext</a>(f) += <a href="llimits.h.html#L112" title="llimits.h:112">cast_int</a>(mp - f);&nbsp; <span class="Comment">/* correct '<a href="llex.c.html#L31" title="llex.c:31">next</a>' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="ltable.h.html#L15" title="ltable.h:15">gnext</a>(mp) = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* now 'mp' is free */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L196" title="lobject.h:196">setnilvalue</a>(<a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(mp));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> {&nbsp; <span class="Comment">/* colliding node is in its own <a href="lua.c.html#L595" title="lua.c:595">main</a> position */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Comment">/* new node will go into free position */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="ltable.h.html#L15" title="ltable.h:15">gnext</a>(mp) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="ltable.h.html#L15" title="ltable.h:15">gnext</a>(f) = <a href="llimits.h.html#L112" title="llimits.h:112">cast_int</a>((mp + <a href="ltable.h.html#L15" title="ltable.h:15">gnext</a>(mp)) - f);&nbsp; <span class="Comment">/* chain new position */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<a href="ltable.h.html#L15" title="ltable.h:15">gnext</a>(f) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="ltable.h.html#L15" title="ltable.h:15">gnext</a>(mp) = <a href="llimits.h.html#L112" title="llimits.h:112">cast_int</a>(f - mp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; mp = f;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="lobject.h.html#L476" title="lobject.h:476">setnodekey</a>(L, &amp;mp-&gt;i_key, key);<br/></li>
<li>&nbsp; <a href="lgc.h.html#L113" title="lgc.h:113">luaC_barrierback</a>(L, t, key);<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(<a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(mp)));<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(mp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** search function for integers<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L497">&#x200c;</a></span><span class="Type">const</span> <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *<span class="linkable">luaH_getint</span> (<a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t, <a href="lua.h.html#L91" title="lua.h:91">lua_Integer</a> key) {<br/></li>
<li>&nbsp; <span class="Comment">/* (1 &lt;= key &amp;&amp; key &lt;= t-&gt;sizearray) */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="llimits.h.html#L118" title="llimits.h:118">l_castS2U</a>(key - <span class="Constant">1</span>) &lt; t-&gt;sizearray)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;t-&gt;array[key - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *n = <a href="#L64" title="ltable.c:64">hashint</a>(t, key);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;) {&nbsp; <span class="Comment">/* <a href="lparser.c.html#L106" title="lparser.c:106">check</a> whether 'key' is somewhere in the chain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="lobject.h.html#L136" title="lobject.h:136">ttisinteger</a>(<a href="ltable.h.html#L19" title="ltable.h:19">gkey</a>(n)) &amp;&amp; <a href="lobject.h.html#L155" title="lobject.h:155">ivalue</a>(<a href="ltable.h.html#L19" title="ltable.h:19">gkey</a>(n)) == key)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(n);&nbsp; <span class="Comment">/* that's it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nx = <a href="ltable.h.html#L15" title="ltable.h:15">gnext</a>(n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nx == <span class="Constant">0</span>) <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n += nx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="lobject.h.html#L516" title="lobject.h:516">luaO_nilobject</a>;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** search function for short strings<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L520">&#x200c;</a></span><span class="Type">const</span> <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *<span class="linkable">luaH_getstr</span> (<a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t, <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *key) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *n = <a href="#L62" title="ltable.c:62">hashstr</a>(t, key);<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(key-&gt;tt == <a href="lobject.h.html#L55" title="lobject.h:55">LUA_TSHRSTR</a>);<br/></li>
<li>&nbsp; <span class="Statement">for</span> (;;) {&nbsp; <span class="Comment">/* <a href="lparser.c.html#L106" title="lparser.c:106">check</a> whether 'key' is somewhere in the chain */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">const</span> <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *k = <a href="ltable.h.html#L19" title="ltable.h:19">gkey</a>(n);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="lobject.h.html#L141" title="lobject.h:141">ttisshrstring</a>(k) &amp;&amp; <a href="lstring.h.html#L34" title="lstring.h:34">eqshrstr</a>(<a href="lobject.h.html#L161" title="lobject.h:161">tsvalue</a>(k), key))<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(n);&nbsp; <span class="Comment">/* that's it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">int</span> nx = <a href="ltable.h.html#L15" title="ltable.h:15">gnext</a>(n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nx == <span class="Constant">0</span>) <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; n += nx;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; };<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="lobject.h.html#L516" title="lobject.h:516">luaO_nilobject</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** <a href="lua.c.html#L595" title="lua.c:595">main</a> search function<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L540">&#x200c;</a></span><span class="Type">const</span> <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *<span class="linkable">luaH_get</span> (<a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t, <span class="Type">const</span> <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *key) {<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (<a href="lobject.h.html#L125" title="lobject.h:125">ttype</a>(key)) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L55" title="lobject.h:55">LUA_TSHRSTR</a>: <span class="Statement">return</span> <a href="#L520" title="ltable.c:520">luaH_getstr</a>(t, <a href="lobject.h.html#L161" title="lobject.h:161">tsvalue</a>(key));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L61" title="lobject.h:61">LUA_TNUMINT</a>: <span class="Statement">return</span> <a href="#L497" title="ltable.c:497">luaH_getint</a>(t, <a href="lobject.h.html#L155" title="lobject.h:155">ivalue</a>(key));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lua.h.html#L62" title="lua.h:62">LUA_TNIL</a>: <span class="Statement">return</span> <a href="lobject.h.html#L516" title="lobject.h:516">luaO_nilobject</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L60" title="lobject.h:60">LUA_TNUMFLT</a>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lua.h.html#L91" title="lua.h:91">lua_Integer</a> k;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L91" title="ltable.c:91">numisinteger</a>(<a href="lobject.h.html#L156" title="lobject.h:156">fltvalue</a>(key), &amp;k)) <span class="Comment">/* index is int? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L497" title="ltable.c:497">luaH_getint</a>(t, k);&nbsp; <span class="Comment">/* use specialized version */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Comment">/* else go through */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *n = <a href="#L119" title="ltable.c:119">mainposition</a>(t, key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;) {&nbsp; <span class="Comment">/* <a href="lparser.c.html#L106" title="lparser.c:106">check</a> whether 'key' is somewhere in the chain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="lvm.h.html#L38" title="lvm.h:38">luaV_rawequalobj</a>(<a href="ltable.h.html#L19" title="ltable.h:19">gkey</a>(n), key))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(n);&nbsp; <span class="Comment">/* that's it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nx = <a href="ltable.h.html#L15" title="ltable.h:15">gnext</a>(n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nx == <span class="Constant">0</span>) <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n += nx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; };<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="lobject.h.html#L516" title="lobject.h:516">luaO_nilobject</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** beware: when using this function you probably need to <a href="lparser.c.html#L106" title="lparser.c:106">check</a> a GC<br/></li>
<li></span><span class="Comment">** barrier and invalidate the TM cache.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L572">&#x200c;</a></span><a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *<span class="linkable">luaH_set</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t, <span class="Type">const</span> <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *key) {<br/></li>
<li>&nbsp; <span class="Type">const</span> <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *p = <a href="#L540" title="ltable.c:540">luaH_get</a>(t, key);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (p != <a href="lobject.h.html#L516" title="lobject.h:516">luaO_nilobject</a>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="llimits.h.html#L107" title="llimits.h:107">cast</a>(<a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *, p);<br/></li>
<li>&nbsp; <span class="Statement">else</span> <span class="Statement">return</span> <a href="#L441" title="ltable.c:441">luaH_newkey</a>(L, t, key);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L580">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaH_setint</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t, <a href="lua.h.html#L91" title="lua.h:91">lua_Integer</a> key, <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *value) {<br/></li>
<li>&nbsp; <span class="Type">const</span> <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *p = <a href="#L497" title="ltable.c:497">luaH_getint</a>(t, key);<br/></li>
<li>&nbsp; <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *cell;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (p != <a href="lobject.h.html#L516" title="lobject.h:516">luaO_nilobject</a>)<br/></li>
<li>&nbsp; &nbsp; cell = <a href="llimits.h.html#L107" title="llimits.h:107">cast</a>(<a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *, p);<br/></li>
<li>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> k;<br/></li>
<li>&nbsp; &nbsp; <a href="lobject.h.html#L193" title="lobject.h:193">setivalue</a>(&amp;k, key);<br/></li>
<li>&nbsp; &nbsp; cell = <a href="#L441" title="ltable.c:441">luaH_newkey</a>(L, t, &amp;k);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="lobject.h.html#L264" title="lobject.h:264">setobj2t</a>(L, cell, value);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L594">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">unbound_search</span> (<a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t, <span class="Type">unsigned</span> <span class="Type">int</span> j) {<br/></li>
<li>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> i = j;&nbsp; <span class="Comment">/* i is zero or a present index */<br/></li>
<li></span>&nbsp; j++;<br/></li>
<li>&nbsp; <span class="Comment">/* find 'i' and 'j' such that i is present and j is not */<br/></li>
<li></span>&nbsp; <span class="Statement">while</span> (!<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(<a href="#L497" title="ltable.c:497">luaH_getint</a>(t, j))) {<br/></li>
<li>&nbsp; &nbsp; i = j;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (j &gt; <a href="llimits.h.html#L107" title="llimits.h:107">cast</a>(<span class="Type">unsigned</span> <span class="Type">int</span>, <a href="llimits.h.html#L51" title="llimits.h:51">MAX_INT</a>)/<span class="Constant">2</span>) {&nbsp; <span class="Comment">/* overflow? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Comment">/* table was built with bad purposes: resort to linear search */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; i = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (!<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(<a href="#L497" title="ltable.c:497">luaH_getint</a>(t, i))) i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> i - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; j *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* now do a binary search between them */<br/></li>
<li></span>&nbsp; <span class="Statement">while</span> (j - i &gt; <span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> m = (i+j)/<span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(<a href="#L497" title="ltable.c:497">luaH_getint</a>(t, m))) j = m;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> i = m;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> i;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** Try to find a boundary in table 't'. A 'boundary' is an integer index<br/></li>
<li></span><span class="Comment">** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L622">&#x200c;</a></span><span class="Type">int</span> <span class="linkable">luaH_getn</span> (<a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t) {<br/></li>
<li>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> j = t-&gt;sizearray;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (j &gt; <span class="Constant">0</span> &amp;&amp; <a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(&amp;t-&gt;array[j - <span class="Constant">1</span>])) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* there is a boundary in the array part: (binary) search for it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (j - i &gt; <span class="Constant">1</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> m = (i+j)/<span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(&amp;t-&gt;array[m - <span class="Constant">1</span>])) j = m;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">else</span> i = m;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> i;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* else must find a boundary in hash part */<br/></li>
<li></span>&nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L79" title="ltable.c:79">isdummy</a>(t-&gt;node))&nbsp; <span class="Comment">/* hash part is empty? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> j;&nbsp; <span class="Comment">/* that is easy... */<br/></li>
<li></span>&nbsp; <span class="Statement">else</span> <span class="Statement">return</span> <a href="#L594" title="ltable.c:594">unbound_search</a>(t, j);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#if defined(LUA_DEBUG)<br/></li>
<li></span><br/></li>
<li><a id="L644">&#x200c;</a><a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *<span class="linkable">luaH_mainposition</span> (<span class="Type">const</span> <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t, <span class="Type">const</span> <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *key) {<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L119" title="ltable.c:119">mainposition</a>(t, key);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L648">&#x200c;</a><span class="Type">int</span> <span class="linkable">luaH_isdummy</span> (<a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *n) { <span class="Statement">return</span> <a href="#L79" title="ltable.c:79">isdummy</a>(n); }<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif<br/></li>
</ol></span></code>
 </body>
</html>
