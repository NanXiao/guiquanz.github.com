<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>lgc.c - src</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

code {
    font-family: consolas, monospace;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
  <h3>lgc.c - src</h3>
   <a href="../index.html"> Table of Contents </a>
 <h4>Functions defined</h4>
 <ul>
<li><a href="#L789">static void GCTM (lua_State *L, int propagateerrors) {</a></li>
<li><a href="#L965">atomic</a></li>
<li><a href="#L839">callallpendingfinalizers</a></li>
<li><a href="#L759">checkSizes</a></li>
<li><a href="#L619">clearkeys</a></li>
<li><a href="#L637">clearvalues</a></li>
<li><a href="#L588">convergeephemerons</a></li>
<li><a href="#L783">dothecall</a></li>
<li><a href="#L940">entersweep</a></li>
<li><a href="#L849">findlast</a></li>
<li><a href="#L665">freeLclosure</a></li>
<li><a href="#L676">freeobj</a></li>
<li><a href="#L1098">getdebt</a></li>
<li><a href="#L129">iscleared</a></li>
<li><a href="#L145">luaC_barrier_</a></li>
<li><a href="#L161">luaC_barrierback_</a></li>
<li><a href="#L882">luaC_checkfinalizer</a></li>
<li><a href="#L184">luaC_fix</a></li>
<li><a href="#L950">luaC_freeallobjects</a></li>
<li><a href="#L1139">luaC_fullgc</a></li>
<li><a href="#L198">luaC_newobj</a></li>
<li><a href="#L1087">luaC_runtilstate</a></li>
<li><a href="#L1109">luaC_step</a></li>
<li><a href="#L175">luaC_upvalbarrier_</a></li>
<li><a href="#L657">luaC_upvdeccount</a></li>
<li><a href="#L285">markbeingfnz</a></li>
<li><a href="#L275">markmt</a></li>
<li><a href="#L583">propagateall</a></li>
<li><a href="#L539">propagatemark</a></li>
<li><a href="#L225">reallymarkobject</a></li>
<li><a href="#L298">remarkupvals</a></li>
<li><a href="#L115">removeentry</a></li>
<li><a href="#L323">restartcollection</a></li>
<li><a href="#L824">runafewfinalizers</a></li>
<li><a href="#L860">separatetobefnz</a></li>
<li><a href="#L920">setpause</a></li>
<li><a href="#L1027">singlestep</a></li>
<li><a href="#L713">sweeplist</a></li>
<li><a href="#L1011">sweepstep</a></li>
<li><a href="#L736">sweeptolive</a></li>
<li><a href="#L482">traverseCclosure</a></li>
<li><a href="#L495">traverseLclosure</a></li>
<li><a href="#L380">traverseephemeron</a></li>
<li><a href="#L460">traverseproto</a></li>
<li><a href="#L419">traversestrongtable</a></li>
<li><a href="#L437">traversetable</a></li>
<li><a href="#L511">traversethread</a></li>
<li><a href="#L347">traverseweakvalue</a></li>
<li><a href="#L770">udata2finalize</a></li>
</ul>
 <h4>Macros defined</h4>
 <ul>
<li><a href="#L45">GCFINALIZECOST</a></li>
<li><a href="#L39">GCSWEEPCOST</a></li>
<li><a href="#L42">GCSWEEPMAX</a></li>
<li><a href="#L33">GCSinsideatomic</a></li>
<li><a href="#L8">LUA_CORE</a></li>
<li><a href="#L59">PAUSEADJ</a></li>
<li><a href="#L52">STEPMULADJ</a></li>
<li><a href="#L71">black2gray</a></li>
<li><a href="#L79">checkconsistency</a></li>
<li><a href="#L76">checkdeadkey</a></li>
<li><a href="#L102">gnodelast</a></li>
<li><a href="#L7">lgc_c</a></li>
<li><a href="#L108">linkgclist</a></li>
<li><a href="#L67">makewhite</a></li>
<li><a href="#L86">markobject</a></li>
<li><a href="#L83">markvalue</a></li>
<li><a href="#L66">maskcolors</a></li>
<li><a href="#L702">sweepwholelist</a></li>
<li><a href="#L74">valiswhite</a></li>
<li><a href="#L70">white2gray</a></li>
</ul>
 <h4>Source code</h4>

  <code><ol><li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** $Id: lgc.c,v 2.201 2014/12/20 13:58:15 roberto Exp $<br/></li>
<li></span><span class="Comment">** Garbage Collector<br/></li>
<li></span><span class="Comment">** See Copyright Notice in lua.h<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><a id="L7">&#x200c;</a><span class="PreProc">#define <span class="linkable">lgc_c</span><br/></li>
<li><a id="L8">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LUA_CORE</span><br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;lprefix.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;lua.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;ldebug.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;ldo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lfunc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lgc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lobject.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lstate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lstring.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;ltable.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;ltm.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** internal state for collector while inside the <a href="#L965" title="lgc.c:965">atomic</a> phase. The<br/></li>
<li></span><span class="Comment">** collector should never be in this state while running regular code.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L33">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">GCSinsideatomic</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="lgc.h.html#L46" title="lgc.h:46">GCSpause</a> + </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** cost of sweeping one element (the size of a small object divided<br/></li>
<li></span><span class="Comment">** by some adjust for the sweep speed)<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L39">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">GCSWEEPCOST</span>&nbsp; &nbsp; &nbsp; &nbsp; ((</span><span class="Statement">sizeof</span><span class="PreProc">(<a href="lobject.h.html#L303" title="lobject.h:303">TString</a>) + </span><span class="Constant">4</span><span class="PreProc">) / </span><span class="Constant">4</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* maximum number of elements to sweep in each single step */<br/></li>
<li><a id="L42">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">GCSWEEPMAX</span>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="llimits.h.html#L112" title="llimits.h:112">cast_int</a>((<a href="lgc.h.html#L32" title="lgc.h:32">GCSTEPSIZE</a> / <a href="#L39" title="lgc.c:39">GCSWEEPCOST</a>) / </span><span class="Constant">4</span><span class="PreProc">))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* cost of calling one finalizer */<br/></li>
<li><a id="L45">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">GCFINALIZECOST</span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L39" title="lgc.c:39">GCSWEEPCOST</a><br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** macro to adjust 'stepmul': 'stepmul' is actually used like<br/></li>
<li></span><span class="Comment">** 'stepmul / <a href="#L52" title="lgc.c:52">STEPMULADJ</a>' (value chosen by tests)<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L52">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">STEPMULADJ</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">200<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** macro to adjust 'pause': 'pause' is actually used like<br/></li>
<li></span><span class="Comment">** 'pause / <a href="#L59" title="lgc.c:59">PAUSEADJ</a>' (value chosen by tests)<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L59">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PAUSEADJ</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">100<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** '<a href="#L67" title="lgc.c:67">makewhite</a>' erases all color bits then sets only the current white<br/></li>
<li></span><span class="Comment">** bit<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L66">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">maskcolors</span>&nbsp; &nbsp; &nbsp; &nbsp; (~(<a href="lgc.h.html#L70" title="lgc.h:70">bitmask</a>(<a href="lgc.h.html#L80" title="lgc.h:80">BLACKBIT</a>) | <a href="lgc.h.html#L84" title="lgc.h:84">WHITEBITS</a>))<br/></li>
<li><a id="L67">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">makewhite</span>(g,x)&nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc"> (x-&gt;marked = <a href="llimits.h.html#L110" title="llimits.h:110">cast_byte</a>((x-&gt;marked &amp; <a href="#L66" title="lgc.c:66">maskcolors</a>) | <a href="lgc.h.html#L101" title="lgc.h:101">luaC_white</a>(g)))<br/></li>
<li></span><br/></li>
<li><a id="L70">&#x200c;</a><span class="PreProc">#define <span class="linkable">white2gray</span>(x)&nbsp; &nbsp; &nbsp; &nbsp; <a href="lgc.h.html#L67" title="lgc.h:67">resetbits</a>(x-&gt;marked, <a href="lgc.h.html#L84" title="lgc.h:84">WHITEBITS</a>)<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">black2gray</span>(x)&nbsp; &nbsp; &nbsp; &nbsp; <a href="lgc.h.html#L73" title="lgc.h:73">resetbit</a>(x-&gt;marked, <a href="lgc.h.html#L80" title="lgc.h:80">BLACKBIT</a>)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L74">&#x200c;</a><span class="PreProc">#define <span class="linkable">valiswhite</span>(x)&nbsp;&nbsp; (<a href="lobject.h.html#L176" title="lobject.h:176">iscollectable</a>(x) &amp;&amp; <a href="lgc.h.html#L87" title="lgc.h:87">iswhite</a>(<a href="lobject.h.html#L159" title="lobject.h:159">gcvalue</a>(x)))<br/></li>
<li></span><br/></li>
<li><a id="L76">&#x200c;</a><span class="PreProc">#define <span class="linkable">checkdeadkey</span>(n)&nbsp; &nbsp; &nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(!<a href="lobject.h.html#L151" title="lobject.h:151">ttisdeadkey</a>(<a href="ltable.h.html#L19" title="ltable.h:19">gkey</a>(n)) || <a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(<a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(n)))<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L79">&#x200c;</a><span class="PreProc">#define <span class="linkable">checkconsistency</span>(obj)&nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; <a href="llimits.h.html#L81" title="llimits.h:81">lua_longassert</a>(!<a href="lobject.h.html#L176" title="lobject.h:176">iscollectable</a>(obj) || <a href="lobject.h.html#L180" title="lobject.h:180">righttt</a>(obj))<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L83">&#x200c;</a><span class="PreProc">#define <span class="linkable">markvalue</span>(g,o) { <a href="#L79" title="lgc.c:79">checkconsistency</a>(o); \<br/></li>
<li></span><span class="PreProc">&nbsp; </span><span class="Statement">if</span><span class="PreProc"> (<a href="#L74" title="lgc.c:74">valiswhite</a>(o)) <a href="#L225" title="lgc.c:225">reallymarkobject</a>(g,<a href="lobject.h.html#L159" title="lobject.h:159">gcvalue</a>(o)); }<br/></li>
<li></span><br/></li>
<li><a id="L86">&#x200c;</a><span class="PreProc">#define <span class="linkable">markobject</span>(g,t) \<br/></li>
<li></span><span class="PreProc">&nbsp; { </span><span class="Statement">if</span><span class="PreProc"> ((t) &amp;&amp; <a href="lgc.h.html#L87" title="lgc.h:87">iswhite</a>(t)) <a href="#L225" title="lgc.c:225">reallymarkobject</a>(g, <a href="lstate.h.html#L208" title="lstate.h:208">obj2gco</a>(t)); }<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L225" title="lgc.c:225">reallymarkobject</a> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g, <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *o);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** {======================================================<br/></li>
<li></span><span class="Comment">** Generic functions<br/></li>
<li></span><span class="Comment">** =======================================================<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** one after last element in a hash array<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L102">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">gnodelast</span>(h)&nbsp; &nbsp; &nbsp; &nbsp; <a href="ltable.h.html#L13" title="ltable.h:13">gnode</a>(h, <a href="llimits.h.html#L107" title="llimits.h:107">cast</a>(</span><span class="Type">size_t</span><span class="PreProc">, <a href="lobject.h.html#L510" title="lobject.h:510">sizenode</a>(h)))<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** link collectable object 'o' into list pointed by 'p'<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L108">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">linkgclist</span>(o,p)&nbsp; &nbsp; &nbsp; &nbsp; ((o)-&gt;gclist = (p), (p) = <a href="lstate.h.html#L208" title="lstate.h:208">obj2gco</a>(o))<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** if key is not marked, mark its entry as dead (therefore removing it<br/></li>
<li></span><span class="Comment">** from the table)<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L115">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">removeentry</span> (<a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *n) {<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(<a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(n)));<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L74" title="lgc.c:74">valiswhite</a>(<a href="ltable.h.html#L19" title="ltable.h:19">gkey</a>(n)))<br/></li>
<li>&nbsp; &nbsp; <a href="lobject.h.html#L241" title="lobject.h:241">setdeadvalue</a>(<a href="ltable.h.html#L21" title="ltable.h:21">wgkey</a>(n));&nbsp; <span class="Comment">/* unused and unmarked key; remove it */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** tells whether a key or value can be cleared from a weak<br/></li>
<li></span><span class="Comment">** table. Non-collectable objects are never removed from weak<br/></li>
<li></span><span class="Comment">** tables. Strings behave as 'values', so are never removed too. for<br/></li>
<li></span><span class="Comment">** other objects: if really collected, <a href="luac.c.html#L44" title="luac.c:44">cannot</a> keep them; for objects<br/></li>
<li></span><span class="Comment">** being finalized, keep them in keys, but not in values<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L129">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">iscleared</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g, <span class="Type">const</span> <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *o) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (!<a href="lobject.h.html#L176" title="lobject.h:176">iscollectable</a>(o)) <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="lobject.h.html#L140" title="lobject.h:140">ttisstring</a>(o)) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L86" title="lgc.c:86">markobject</a>(g, <a href="lobject.h.html#L161" title="lobject.h:161">tsvalue</a>(o));&nbsp; <span class="Comment">/* strings are 'values', so are never weak */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">else</span> <span class="Statement">return</span> <a href="lgc.h.html#L87" title="lgc.h:87">iswhite</a>(<a href="lobject.h.html#L159" title="lobject.h:159">gcvalue</a>(o));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** barrier that moves collector forward, that is, mark the white object<br/></li>
<li></span><span class="Comment">** being pointed by a black object. (If in sweep phase, clear the black<br/></li>
<li></span><span class="Comment">** object to white [sweep it] to avoid other barrier calls for this<br/></li>
<li></span><span class="Comment">** same object.)<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L145">&#x200c;</a></span><span class="Type">void</span> <span class="linkable">luaC_barrier_</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *o, <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *v) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g = <a href="lstate.h.html#L175" title="lstate.h:175">G</a>(L);<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<a href="lgc.h.html#L88" title="lgc.h:88">isblack</a>(o) &amp;&amp; <a href="lgc.h.html#L87" title="lgc.h:87">iswhite</a>(v) &amp;&amp; !<a href="lgc.h.html#L96" title="lgc.h:96">isdead</a>(g, v) &amp;&amp; !<a href="lgc.h.html#L96" title="lgc.h:96">isdead</a>(g, o));<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="lgc.h.html#L61" title="lgc.h:61">keepinvariant</a>(g))&nbsp; <span class="Comment">/* must keep invariant? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L225" title="lgc.c:225">reallymarkobject</a>(g, v);&nbsp; <span class="Comment">/* restore invariant */<br/></li>
<li></span>&nbsp; <span class="Statement">else</span> {&nbsp; <span class="Comment">/* sweep phase */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<a href="lgc.h.html#L49" title="lgc.h:49">issweepphase</a>(g));<br/></li>
<li>&nbsp; &nbsp; <a href="#L67" title="lgc.c:67">makewhite</a>(g, o);&nbsp; <span class="Comment">/* mark <a href="lua.c.html#L595" title="lua.c:595">main</a> obj. as white to avoid other barriers */<br/></li>
<li></span>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** barrier that moves collector backward, that is, mark the black object<br/></li>
<li></span><span class="Comment">** pointing to a white object as gray again.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L161">&#x200c;</a></span><span class="Type">void</span> <span class="linkable">luaC_barrierback_</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *t) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g = <a href="lstate.h.html#L175" title="lstate.h:175">G</a>(L);<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<a href="lgc.h.html#L88" title="lgc.h:88">isblack</a>(t) &amp;&amp; !<a href="lgc.h.html#L96" title="lgc.h:96">isdead</a>(g, t));<br/></li>
<li>&nbsp; <a href="#L71" title="lgc.c:71">black2gray</a>(t);&nbsp; <span class="Comment">/* make table gray (again) */<br/></li>
<li></span>&nbsp; <a href="#L108" title="lgc.c:108">linkgclist</a>(t, g-&gt;grayagain);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** barrier for assignments to closed upvalues. Because upvalues are<br/></li>
<li></span><span class="Comment">** shared among closures, it is impossible to know the color of all<br/></li>
<li></span><span class="Comment">** closures pointing to it. So, we assume that the object being assigned<br/></li>
<li></span><span class="Comment">** must be marked.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L175">&#x200c;</a></span><span class="Type">void</span> <span class="linkable">luaC_upvalbarrier_</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lfunc.h.html#L28" title="lfunc.h:28">UpVal</a> *uv) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g = <a href="lstate.h.html#L175" title="lstate.h:175">G</a>(L);<br/></li>
<li>&nbsp; <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *o = <a href="lobject.h.html#L159" title="lobject.h:159">gcvalue</a>(uv-&gt;v);<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(!<a href="lfunc.h.html#L40" title="lfunc.h:40">upisopen</a>(uv));&nbsp; <span class="Comment">/* ensured by macro <a href="lgc.h.html#L121" title="lgc.h:121">luaC_upvalbarrier</a> */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="lgc.h.html#L61" title="lgc.h:61">keepinvariant</a>(g))<br/></li>
<li>&nbsp; &nbsp; <a href="#L86" title="lgc.c:86">markobject</a>(g, o);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L184">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaC_fix</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *o) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g = <a href="lstate.h.html#L175" title="lstate.h:175">G</a>(L);<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(g-&gt;allgc == o);&nbsp; <span class="Comment">/* object must be 1st in 'allgc' list! */<br/></li>
<li></span>&nbsp; <a href="#L70" title="lgc.c:70">white2gray</a>(o);&nbsp; <span class="Comment">/* they will be gray forever */<br/></li>
<li></span>&nbsp; g-&gt;allgc = o-&gt;<a href="llex.c.html#L31" title="llex.c:31">next</a>;&nbsp; <span class="Comment">/* remove object from 'allgc' list */<br/></li>
<li></span>&nbsp; o-&gt;<a href="llex.c.html#L31" title="llex.c:31">next</a> = g-&gt;fixedgc;&nbsp; <span class="Comment">/* link it to 'fixedgc' list */<br/></li>
<li></span>&nbsp; g-&gt;fixedgc = o;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** create a new collectable object (with given type and size) and link<br/></li>
<li></span><span class="Comment">** it to 'allgc' list.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L198">&#x200c;</a></span><a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *<span class="linkable">luaC_newobj</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <span class="Type">int</span> tt, <span class="Type">size_t</span> sz) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g = <a href="lstate.h.html#L175" title="lstate.h:175">G</a>(L);<br/></li>
<li>&nbsp; <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *o = <a href="llimits.h.html#L107" title="llimits.h:107">cast</a>(<a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *, <a href="lmem.h.html#L50" title="lmem.h:50">luaM_newobject</a>(L, <a href="lobject.h.html#L122" title="lobject.h:122">novariant</a>(tt), sz));<br/></li>
<li>&nbsp; o-&gt;marked = <a href="lgc.h.html#L101" title="lgc.h:101">luaC_white</a>(g);<br/></li>
<li>&nbsp; o-&gt;tt = tt;<br/></li>
<li>&nbsp; o-&gt;<a href="llex.c.html#L31" title="llex.c:31">next</a> = g-&gt;allgc;<br/></li>
<li>&nbsp; g-&gt;allgc = o;<br/></li>
<li>&nbsp; <span class="Statement">return</span> o;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* }====================================================== */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** {======================================================<br/></li>
<li></span><span class="Comment">** Mark functions<br/></li>
<li></span><span class="Comment">** =======================================================<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** mark an object. Userdata, strings, and closed upvalues are visited<br/></li>
<li></span><span class="Comment">** and turned black here. Other objects are marked gray and added<br/></li>
<li></span><span class="Comment">** to appropriate list to be visited (and turned black) later. (Open<br/></li>
<li></span><span class="Comment">** upvalues are already linked in 'headuv' list.)<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L225">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">reallymarkobject</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g, <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *o) {<br/></li>
<li><span class="cUserCont"> </span><span class="Statement">reentry</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; <a href="#L70" title="lgc.c:70">white2gray</a>(o);<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (o-&gt;tt) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L55" title="lobject.h:55">LUA_TSHRSTR</a>:<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L56" title="lobject.h:56">LUA_TLNGSTR</a>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lgc.h.html#L99" title="lgc.h:99">gray2black</a>(o);<br/></li>
<li>&nbsp; &nbsp; &nbsp; g-&gt;GCmemtrav += <a href="lstring.h.html#L16" title="lstring.h:16">sizestring</a>(<a href="lstate.h.html#L195" title="lstate.h:195">gco2ts</a>(o));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lua.h.html#L69" title="lua.h:69">LUA_TUSERDATA</a>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> <a href="lobject.h.html#L162" title="lobject.h:162">uvalue</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L86" title="lgc.c:86">markobject</a>(g, <a href="lstate.h.html#L197" title="lstate.h:197">gco2u</a>(o)-&gt;metatable);&nbsp; <span class="Comment">/* mark its metatable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="lgc.h.html#L99" title="lgc.h:99">gray2black</a>(o);<br/></li>
<li>&nbsp; &nbsp; &nbsp; g-&gt;GCmemtrav += <a href="lstring.h.html#L19" title="lstring.h:19">sizeudata</a>(<a href="lstate.h.html#L197" title="lstate.h:197">gco2u</a>(o));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L368" title="lobject.h:368">getuservalue</a>(g-&gt;mainthread, <a href="lstate.h.html#L197" title="lstate.h:197">gco2u</a>(o), &amp;<a href="lobject.h.html#L162" title="lobject.h:162">uvalue</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L74" title="lgc.c:74">valiswhite</a>(&amp;<a href="lobject.h.html#L162" title="lobject.h:162">uvalue</a>)) {&nbsp; <span class="Comment">/* <a href="#L83" title="lgc.c:83">markvalue</a>(g, &amp;<a href="lobject.h.html#L162" title="lobject.h:162">uvalue</a>); */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; o = <a href="lobject.h.html#L159" title="lobject.h:159">gcvalue</a>(&amp;<a href="lobject.h.html#L162" title="lobject.h:162">uvalue</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> reentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L49" title="lobject.h:49">LUA_TLCL</a>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L108" title="lgc.c:108">linkgclist</a>(<a href="lstate.h.html#L198" title="lstate.h:198">gco2lcl</a>(o), g-&gt;gray);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L51" title="lobject.h:51">LUA_TCCL</a>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L108" title="lgc.c:108">linkgclist</a>(<a href="lstate.h.html#L199" title="lstate.h:199">gco2ccl</a>(o), g-&gt;gray);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lua.h.html#L67" title="lua.h:67">LUA_TTABLE</a>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L108" title="lgc.c:108">linkgclist</a>(<a href="lstate.h.html#L202" title="lstate.h:202">gco2t</a>(o), g-&gt;gray);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lua.h.html#L70" title="lua.h:70">LUA_TTHREAD</a>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L108" title="lgc.c:108">linkgclist</a>(<a href="lstate.h.html#L204" title="lstate.h:204">gco2th</a>(o), g-&gt;gray);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L22" title="lobject.h:22">LUA_TPROTO</a>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L108" title="lgc.c:108">linkgclist</a>(<a href="lstate.h.html#L203" title="lstate.h:203">gco2p</a>(o), g-&gt;gray);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<span class="Constant">0</span>); <span class="Statement">break</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** mark metamethods for basic types<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L275">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">markmt</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g) {<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i=<span class="Constant">0</span>; i &lt; <a href="lua.h.html#L72" title="lua.h:72">LUA_NUMTAGS</a>; i++)<br/></li>
<li>&nbsp; &nbsp; <a href="#L86" title="lgc.c:86">markobject</a>(g, g-&gt;mt[i]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** mark all objects in list of being-finalized<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L285">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">markbeingfnz</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *o;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (o = g-&gt;tobefnz; o != <span class="Constant">NULL</span>; o = o-&gt;<a href="llex.c.html#L31" title="llex.c:31">next</a>)<br/></li>
<li>&nbsp; &nbsp; <a href="#L86" title="lgc.c:86">markobject</a>(g, o);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** Mark all values stored in marked open upvalues from non-marked threads.<br/></li>
<li></span><span class="Comment">** (Values from marked threads were already marked when traversing the<br/></li>
<li></span><span class="Comment">** thread.) Remove from the list threads that no longer have upvalues and<br/></li>
<li></span><span class="Comment">** not-marked threads.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L298">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">remarkupvals</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *thread;<br/></li>
<li>&nbsp; <a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> **p = &amp;g-&gt;twups;<br/></li>
<li>&nbsp; <span class="Statement">while</span> ((thread = *p) != <span class="Constant">NULL</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(!<a href="lgc.h.html#L88" title="lgc.h:88">isblack</a>(thread));&nbsp; <span class="Comment">/* threads are never black */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="lgc.h.html#L89" title="lgc.h:89">isgray</a>(thread) &amp;&amp; thread-&gt;openupval != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; p = &amp;thread-&gt;twups;&nbsp; <span class="Comment">/* keep marked thread with upvalues in the list */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> {&nbsp; <span class="Comment">/* thread is not marked or without upvalues */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="lfunc.h.html#L28" title="lfunc.h:28">UpVal</a> *uv;<br/></li>
<li>&nbsp; &nbsp; &nbsp; *p = thread-&gt;twups;&nbsp; <span class="Comment">/* remove thread from the list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; thread-&gt;twups = thread;&nbsp; <span class="Comment">/* mark that it is out of list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (uv = thread-&gt;openupval; uv != <span class="Constant">NULL</span>; uv = uv-&gt;u.open.<a href="llex.c.html#L31" title="llex.c:31">next</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (uv-&gt;u.open.touched) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L83" title="lgc.c:83">markvalue</a>(g, uv-&gt;v);&nbsp; <span class="Comment">/* remark upvalue's value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uv-&gt;u.open.touched = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** mark root set and reset all gray lists, to start a new collection<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L323">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">restartcollection</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g) {<br/></li>
<li>&nbsp; g-&gt;gray = g-&gt;grayagain = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; g-&gt;weak = g-&gt;allweak = g-&gt;ephemeron = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; <a href="#L86" title="lgc.c:86">markobject</a>(g, g-&gt;mainthread);<br/></li>
<li>&nbsp; <a href="#L83" title="lgc.c:83">markvalue</a>(g, &amp;g-&gt;l_registry);<br/></li>
<li>&nbsp; <a href="#L275" title="lgc.c:275">markmt</a>(g);<br/></li>
<li>&nbsp; <a href="#L285" title="lgc.c:285">markbeingfnz</a>(g);&nbsp; <span class="Comment">/* mark any finalizing object left from previous cycle */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* }====================================================== */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** {======================================================<br/></li>
<li></span><span class="Comment">** Traverse functions<br/></li>
<li></span><span class="Comment">** =======================================================<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** Traverse a table with weak values and link it to proper list. During<br/></li>
<li></span><span class="Comment">** propagate phase, keep it in 'grayagain' list, to be revisited in the<br/></li>
<li></span><span class="Comment">** <a href="#L965" title="lgc.c:965">atomic</a> phase. In the <a href="#L965" title="lgc.c:965">atomic</a> phase, if table has any white value,<br/></li>
<li></span><span class="Comment">** put it in 'weak' list, to be cleared.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L347">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">traverseweakvalue</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g, <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *h) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *n, *limit = <a href="#L102" title="lgc.c:102">gnodelast</a>(h);<br/></li>
<li>&nbsp; <span class="Comment">/* if there is array part, assume it may have white values (it is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; worth traversing it now just to <a href="lparser.c.html#L106" title="lparser.c:106">check</a>) */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> hasclears = (h-&gt;sizearray &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Statement">for</span> (n = <a href="ltable.h.html#L13" title="ltable.h:13">gnode</a>(h, <span class="Constant">0</span>); n &lt; limit; n++) {&nbsp; <span class="Comment">/* traverse hash part */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L76" title="lgc.c:76">checkdeadkey</a>(n);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(<a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(n)))&nbsp; <span class="Comment">/* entry is empty? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L115" title="lgc.c:115">removeentry</a>(n);&nbsp; <span class="Comment">/* remove it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(!<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(<a href="ltable.h.html#L19" title="ltable.h:19">gkey</a>(n)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L83" title="lgc.c:83">markvalue</a>(g, <a href="ltable.h.html#L19" title="ltable.h:19">gkey</a>(n));&nbsp; <span class="Comment">/* mark key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!hasclears &amp;&amp; <a href="#L129" title="lgc.c:129">iscleared</a>(g, <a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(n)))&nbsp; <span class="Comment">/* is there a white value? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hasclears = <span class="Constant">1</span>;&nbsp; <span class="Comment">/* table will have to be cleared */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">if</span> (g-&gt;gcstate == <a href="lgc.h.html#L39" title="lgc.h:39">GCSpropagate</a>)<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="lgc.c:108">linkgclist</a>(h, g-&gt;grayagain);&nbsp; <span class="Comment">/* must retraverse it in <a href="#L965" title="lgc.c:965">atomic</a> phase */<br/></li>
<li></span>&nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (hasclears)<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="lgc.c:108">linkgclist</a>(h, g-&gt;weak);&nbsp; <span class="Comment">/* has to be cleared later */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** Traverse an ephemeron table and link it to proper list. Returns true<br/></li>
<li></span><span class="Comment">** iff any object was marked during this traversal (which implies that<br/></li>
<li></span><span class="Comment">** convergence has to continue). During propagation phase, keep table<br/></li>
<li></span><span class="Comment">** in 'grayagain' list, to be visited again in the <a href="#L965" title="lgc.c:965">atomic</a> phase. In<br/></li>
<li></span><span class="Comment">** the <a href="#L965" title="lgc.c:965">atomic</a> phase, if table has any white-&gt;white entry, it has to<br/></li>
<li></span><span class="Comment">** be revisited during ephemeron convergence (as that key may turn<br/></li>
<li></span><span class="Comment">** black). Otherwise, if it has any white key, table has to be cleared<br/></li>
<li></span><span class="Comment">** (in the <a href="#L965" title="lgc.c:965">atomic</a> phase).<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L380">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">traverseephemeron</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g, <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *h) {<br/></li>
<li>&nbsp; <span class="Type">int</span> marked = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* true if an object is marked in this traversal */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> hasclears = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* true if table has white keys */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> hasww = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* true if table has entry &quot;white-key -&gt; white-value&quot; */<br/></li>
<li></span>&nbsp; <a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *n, *limit = <a href="#L102" title="lgc.c:102">gnodelast</a>(h);<br/></li>
<li>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Comment">/* traverse array part */<br/></li>
<li></span>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; h-&gt;sizearray; i++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L74" title="lgc.c:74">valiswhite</a>(&amp;h-&gt;array[i])) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; marked = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L225" title="lgc.c:225">reallymarkobject</a>(g, <a href="lobject.h.html#L159" title="lobject.h:159">gcvalue</a>(&amp;h-&gt;array[i]));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* traverse hash part */<br/></li>
<li></span>&nbsp; <span class="Statement">for</span> (n = <a href="ltable.h.html#L13" title="ltable.h:13">gnode</a>(h, <span class="Constant">0</span>); n &lt; limit; n++) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="lgc.c:76">checkdeadkey</a>(n);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(<a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(n)))&nbsp; <span class="Comment">/* entry is empty? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L115" title="lgc.c:115">removeentry</a>(n);&nbsp; <span class="Comment">/* remove it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L129" title="lgc.c:129">iscleared</a>(g, <a href="ltable.h.html#L19" title="ltable.h:19">gkey</a>(n))) {&nbsp; <span class="Comment">/* key is not marked (yet)? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; hasclears = <span class="Constant">1</span>;&nbsp; <span class="Comment">/* table must be cleared */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L74" title="lgc.c:74">valiswhite</a>(<a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(n)))&nbsp; <span class="Comment">/* value not marked yet? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hasww = <span class="Constant">1</span>;&nbsp; <span class="Comment">/* white-white entry */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L74" title="lgc.c:74">valiswhite</a>(<a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(n))) {&nbsp; <span class="Comment">/* value not marked yet? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; marked = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L225" title="lgc.c:225">reallymarkobject</a>(g, <a href="lobject.h.html#L159" title="lobject.h:159">gcvalue</a>(<a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(n)));&nbsp; <span class="Comment">/* mark it now */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* link table into proper list */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (g-&gt;gcstate == <a href="lgc.h.html#L39" title="lgc.h:39">GCSpropagate</a>)<br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="lgc.c:108">linkgclist</a>(h, g-&gt;grayagain);&nbsp; <span class="Comment">/* must retraverse it in <a href="#L965" title="lgc.c:965">atomic</a> phase */<br/></li>
<li></span>&nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (hasww)&nbsp; <span class="Comment">/* table has white-&gt;white entries? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L108" title="lgc.c:108">linkgclist</a>(h, g-&gt;ephemeron);&nbsp; <span class="Comment">/* have to propagate again */<br/></li>
<li></span>&nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (hasclears)&nbsp; <span class="Comment">/* table has white keys? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L108" title="lgc.c:108">linkgclist</a>(h, g-&gt;allweak);&nbsp; <span class="Comment">/* may have to clean white keys */<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> marked;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L419">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">traversestrongtable</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g, <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *h) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *n, *limit = <a href="#L102" title="lgc.c:102">gnodelast</a>(h);<br/></li>
<li>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; h-&gt;sizearray; i++)&nbsp; <span class="Comment">/* traverse array part */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L83" title="lgc.c:83">markvalue</a>(g, &amp;h-&gt;array[i]);<br/></li>
<li>&nbsp; <span class="Statement">for</span> (n = <a href="ltable.h.html#L13" title="ltable.h:13">gnode</a>(h, <span class="Constant">0</span>); n &lt; limit; n++) {&nbsp; <span class="Comment">/* traverse hash part */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L76" title="lgc.c:76">checkdeadkey</a>(n);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(<a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(n)))&nbsp; <span class="Comment">/* entry is empty? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L115" title="lgc.c:115">removeentry</a>(n);&nbsp; <span class="Comment">/* remove it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(!<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(<a href="ltable.h.html#L19" title="ltable.h:19">gkey</a>(n)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L83" title="lgc.c:83">markvalue</a>(g, <a href="ltable.h.html#L19" title="ltable.h:19">gkey</a>(n));&nbsp; <span class="Comment">/* mark key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L83" title="lgc.c:83">markvalue</a>(g, <a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(n));&nbsp; <span class="Comment">/* mark value */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L437">&#x200c;</a><span class="Type">static</span> <a href="llimits.h.html#L23" title="llimits.h:23">lu_mem</a> <span class="linkable">traversetable</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g, <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *h) {<br/></li>
<li>&nbsp; <span class="Type">const</span> <span class="Type">char</span> *weakkey, *weakvalue;<br/></li>
<li>&nbsp; <span class="Type">const</span> <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *mode = <a href="ltm.h.html#L48" title="ltm.h:48">gfasttm</a>(g, h-&gt;metatable, TM_MODE);<br/></li>
<li>&nbsp; <a href="#L86" title="lgc.c:86">markobject</a>(g, h-&gt;metatable);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (mode &amp;&amp; <a href="lobject.h.html#L140" title="lobject.h:140">ttisstring</a>(mode) &amp;&amp;&nbsp; <span class="Comment">/* is there a weak mode? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; ((weakkey = strchr(<a href="lobject.h.html#L330" title="lobject.h:330">svalue</a>(mode), <span class="Constant">'k'</span>)),<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; (weakvalue = strchr(<a href="lobject.h.html#L330" title="lobject.h:330">svalue</a>(mode), <span class="Constant">'v'</span>)),<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; (weakkey || weakvalue))) {&nbsp; <span class="Comment">/* is really weak? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L71" title="lgc.c:71">black2gray</a>(h);&nbsp; <span class="Comment">/* keep table gray */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!weakkey)&nbsp; <span class="Comment">/* strong keys? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L347" title="lgc.c:347">traverseweakvalue</a>(g, h);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!weakvalue)&nbsp; <span class="Comment">/* strong values? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L380" title="lgc.c:380">traverseephemeron</a>(g, h);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span>&nbsp; <span class="Comment">/* all weak */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L108" title="lgc.c:108">linkgclist</a>(h, g-&gt;allweak);&nbsp; <span class="Comment">/* nothing to traverse now */<br/></li>
<li></span>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">else</span>&nbsp; <span class="Comment">/* not weak */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L419" title="lgc.c:419">traversestrongtable</a>(g, h);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Statement">sizeof</span>(<a href="lobject.h.html#L488" title="lobject.h:488">Table</a>) + <span class="Statement">sizeof</span>(<a href="lobject.h.html#L108" title="lobject.h:108">TValue</a>) * h-&gt;sizearray +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement">sizeof</span>(<a href="lobject.h.html#L482" title="lobject.h:482">Node</a>) * <a href="llimits.h.html#L107" title="llimits.h:107">cast</a>(<span class="Type">size_t</span>, <a href="lobject.h.html#L510" title="lobject.h:510">sizenode</a>(h));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L460">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">traverseproto</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g, <a href="lobject.h.html#L398" title="lobject.h:398">Proto</a> *f) {<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (f-&gt;cache &amp;&amp; <a href="lgc.h.html#L87" title="lgc.h:87">iswhite</a>(f-&gt;cache))<br/></li>
<li>&nbsp; &nbsp; f-&gt;cache = <span class="Constant">NULL</span>;&nbsp; <span class="Comment">/* allow cache to be collected */<br/></li>
<li></span>&nbsp; <a href="#L86" title="lgc.c:86">markobject</a>(g, f-&gt;source);<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; f-&gt;sizek; i++)&nbsp; <span class="Comment">/* mark literals */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L83" title="lgc.c:83">markvalue</a>(g, &amp;f-&gt;k[i]);<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; f-&gt;sizeupvalues; i++)&nbsp; <span class="Comment">/* mark upvalue names */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L86" title="lgc.c:86">markobject</a>(g, f-&gt;upvalues[i].name);<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; f-&gt;sizep; i++)&nbsp; <span class="Comment">/* mark nested protos */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L86" title="lgc.c:86">markobject</a>(g, f-&gt;p[i]);<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; f-&gt;sizelocvars; i++)&nbsp; <span class="Comment">/* mark local-variable names */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L86" title="lgc.c:86">markobject</a>(g, f-&gt;locvars[i].varname);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Statement">sizeof</span>(<a href="lobject.h.html#L398" title="lobject.h:398">Proto</a>) + <span class="Statement">sizeof</span>(<a href="llimits.h.html#L164" title="llimits.h:164">Instruction</a>) * f-&gt;sizecode +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement">sizeof</span>(<a href="lobject.h.html#L398" title="lobject.h:398">Proto</a> *) * f-&gt;sizep +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement">sizeof</span>(<a href="lobject.h.html#L108" title="lobject.h:108">TValue</a>) * f-&gt;sizek +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement">sizeof</span>(<span class="Type">int</span>) * f-&gt;sizelineinfo +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement">sizeof</span>(<a href="lobject.h.html#L388" title="lobject.h:388">LocVar</a>) * f-&gt;sizelocvars +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement">sizeof</span>(<a href="lobject.h.html#L377" title="lobject.h:377">Upvaldesc</a>) * f-&gt;sizeupvalues;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L482">&#x200c;</a><span class="Type">static</span> <a href="llimits.h.html#L23" title="llimits.h:23">lu_mem</a> <span class="linkable">traverseCclosure</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g, <a href="lobject.h.html#L437" title="lobject.h:437">CClosure</a> *cl) {<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; cl-&gt;nupvalues; i++)&nbsp; <span class="Comment">/* mark its upvalues */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L83" title="lgc.c:83">markvalue</a>(g, &amp;cl-&gt;upvalue[i]);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="lfunc.h.html#L14" title="lfunc.h:14">sizeCclosure</a>(cl-&gt;nupvalues);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** open upvalues point to values in a thread, so those values should<br/></li>
<li></span><span class="Comment">** be marked when the thread is traversed except in the <a href="#L965" title="lgc.c:965">atomic</a> phase<br/></li>
<li></span><span class="Comment">** (because then the value <a href="luac.c.html#L44" title="luac.c:44">cannot</a> be changed by the thread and the<br/></li>
<li></span><span class="Comment">** thread may not be traversed again)<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L495">&#x200c;</a></span><span class="Type">static</span> <a href="llimits.h.html#L23" title="llimits.h:23">lu_mem</a> <span class="linkable">traverseLclosure</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g, <a href="lobject.h.html#L444" title="lobject.h:444">LClosure</a> *cl) {<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <a href="#L86" title="lgc.c:86">markobject</a>(g, cl-&gt;p);&nbsp; <span class="Comment">/* mark its prototype */<br/></li>
<li></span>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; cl-&gt;nupvalues; i++) {&nbsp; <span class="Comment">/* mark its upvalues */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lfunc.h.html#L28" title="lfunc.h:28">UpVal</a> *uv = cl-&gt;upvals[i];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (uv != <span class="Constant">NULL</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="lfunc.h.html#L40" title="lfunc.h:40">upisopen</a>(uv) &amp;&amp; g-&gt;gcstate != <a href="#L33" title="lgc.c:33">GCSinsideatomic</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uv-&gt;u.open.touched = <span class="Constant">1</span>;&nbsp; <span class="Comment">/* can be marked in '<a href="#L298" title="lgc.c:298">remarkupvals</a>' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L83" title="lgc.c:83">markvalue</a>(g, uv-&gt;v);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="lfunc.h.html#L17" title="lfunc.h:17">sizeLclosure</a>(cl-&gt;nupvalues);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L511">&#x200c;</a><span class="Type">static</span> <a href="llimits.h.html#L23" title="llimits.h:23">lu_mem</a> <span class="linkable">traversethread</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g, <a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *th) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L294" title="lobject.h:294">StkId</a> o = th-&gt;stack;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (o == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;&nbsp; <span class="Comment">/* stack not completely built yet */<br/></li>
<li></span>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(g-&gt;gcstate == <a href="#L33" title="lgc.c:33">GCSinsideatomic</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; th-&gt;openupval == <span class="Constant">NULL</span> || <a href="lfunc.h.html#L22" title="lfunc.h:22">isintwups</a>(th));<br/></li>
<li>&nbsp; <span class="Statement">for</span> (; o &lt; th-&gt;top; o++)&nbsp; <span class="Comment">/* mark live elements in the stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L83" title="lgc.c:83">markvalue</a>(g, o);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (g-&gt;gcstate == <a href="#L33" title="lgc.c:33">GCSinsideatomic</a>) {&nbsp; <span class="Comment">/* final traversal? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lobject.h.html#L294" title="lobject.h:294">StkId</a> lim = th-&gt;stack + th-&gt;stacksize;&nbsp; <span class="Comment">/* real end of stack */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (; o &lt; lim; o++)&nbsp; <span class="Comment">/* clear not-marked stack slice */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L196" title="lobject.h:196">setnilvalue</a>(o);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* '<a href="#L298" title="lgc.c:298">remarkupvals</a>' may have removed thread from 'twups' list */</span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="lfunc.h.html#L22" title="lfunc.h:22">isintwups</a>(th) &amp;&amp; th-&gt;openupval != <span class="Constant">NULL</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; th-&gt;twups = g-&gt;twups;&nbsp; <span class="Comment">/* link it back to the list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; g-&gt;twups = th;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (g-&gt;gckind != <a href="lstate.h.html#L46" title="lstate.h:46">KGC_EMERGENCY</a>)<br/></li>
<li>&nbsp; &nbsp; <a href="ldo.c.html#L216" title="ldo.c:216">luaD_shrinkstack</a>(th); <span class="Comment">/* do not change stack in emergency cycle */<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> (<span class="Statement">sizeof</span>(<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a>) + <span class="Statement">sizeof</span>(<a href="lobject.h.html#L108" title="lobject.h:108">TValue</a>) * th-&gt;stacksize);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** traverse one gray object, turning it to black (except for threads,<br/></li>
<li></span><span class="Comment">** which are always gray).<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L539">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">propagatemark</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g) {<br/></li>
<li>&nbsp; <a href="llimits.h.html#L23" title="llimits.h:23">lu_mem</a> size;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *o = g-&gt;gray;<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<a href="lgc.h.html#L89" title="lgc.h:89">isgray</a>(o));<br/></li>
<li>&nbsp; <a href="lgc.h.html#L99" title="lgc.h:99">gray2black</a>(o);<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (o-&gt;tt) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lua.h.html#L67" title="lua.h:67">LUA_TTABLE</a>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *h = <a href="lstate.h.html#L202" title="lstate.h:202">gco2t</a>(o);<br/></li>
<li>&nbsp; &nbsp; &nbsp; g-&gt;gray = h-&gt;gclist;&nbsp; <span class="Comment">/* remove from 'gray' list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; size = <a href="#L437" title="lgc.c:437">traversetable</a>(g, h);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L49" title="lobject.h:49">LUA_TLCL</a>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L444" title="lobject.h:444">LClosure</a> *cl = <a href="lstate.h.html#L198" title="lstate.h:198">gco2lcl</a>(o);<br/></li>
<li>&nbsp; &nbsp; &nbsp; g-&gt;gray = cl-&gt;gclist;&nbsp; <span class="Comment">/* remove from 'gray' list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; size = <a href="#L495" title="lgc.c:495">traverseLclosure</a>(g, cl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L51" title="lobject.h:51">LUA_TCCL</a>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L437" title="lobject.h:437">CClosure</a> *cl = <a href="lstate.h.html#L199" title="lstate.h:199">gco2ccl</a>(o);<br/></li>
<li>&nbsp; &nbsp; &nbsp; g-&gt;gray = cl-&gt;gclist;&nbsp; <span class="Comment">/* remove from 'gray' list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; size = <a href="#L482" title="lgc.c:482">traverseCclosure</a>(g, cl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lua.h.html#L70" title="lua.h:70">LUA_TTHREAD</a>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *th = <a href="lstate.h.html#L204" title="lstate.h:204">gco2th</a>(o);<br/></li>
<li>&nbsp; &nbsp; &nbsp; g-&gt;gray = th-&gt;gclist;&nbsp; <span class="Comment">/* remove from 'gray' list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L108" title="lgc.c:108">linkgclist</a>(th, g-&gt;grayagain);&nbsp; <span class="Comment">/* insert into 'grayagain' list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L71" title="lgc.c:71">black2gray</a>(o);<br/></li>
<li>&nbsp; &nbsp; &nbsp; size = <a href="#L511" title="lgc.c:511">traversethread</a>(g, th);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L22" title="lobject.h:22">LUA_TPROTO</a>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L398" title="lobject.h:398">Proto</a> *p = <a href="lstate.h.html#L203" title="lstate.h:203">gco2p</a>(o);<br/></li>
<li>&nbsp; &nbsp; &nbsp; g-&gt;gray = p-&gt;gclist;&nbsp; <span class="Comment">/* remove from 'gray' list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; size = <a href="#L460" title="lgc.c:460">traverseproto</a>(g, p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<span class="Constant">0</span>); <span class="Statement">return</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; g-&gt;GCmemtrav += size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L583">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">propagateall</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g) {<br/></li>
<li>&nbsp; <span class="Statement">while</span> (g-&gt;gray) <a href="#L539" title="lgc.c:539">propagatemark</a>(g);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L588">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">convergeephemerons</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g) {<br/></li>
<li>&nbsp; <span class="Type">int</span> changed;<br/></li>
<li>&nbsp; <span class="Statement">do</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *w;<br/></li>
<li>&nbsp; &nbsp; <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *<a href="llex.c.html#L31" title="llex.c:31">next</a> = g-&gt;ephemeron;&nbsp; <span class="Comment">/* get ephemeron list */<br/></li>
<li></span>&nbsp; &nbsp; g-&gt;ephemeron = <span class="Constant">NULL</span>;&nbsp; <span class="Comment">/* tables may return to this list when traversed */<br/></li>
<li></span>&nbsp; &nbsp; changed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((w = <a href="llex.c.html#L31" title="llex.c:31">next</a>) != <span class="Constant">NULL</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="llex.c.html#L31" title="llex.c:31">next</a> = <a href="lstate.h.html#L202" title="lstate.h:202">gco2t</a>(w)-&gt;gclist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L380" title="lgc.c:380">traverseephemeron</a>(g, <a href="lstate.h.html#L202" title="lstate.h:202">gco2t</a>(w))) {&nbsp; <span class="Comment">/* traverse marked some value? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L583" title="lgc.c:583">propagateall</a>(g);&nbsp; <span class="Comment">/* propagate changes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; changed = <span class="Constant">1</span>;&nbsp; <span class="Comment">/* will have to revisit all ephemeron tables */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; } <span class="Statement">while</span> (changed);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* }====================================================== */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** {======================================================<br/></li>
<li></span><span class="Comment">** Sweep Functions<br/></li>
<li></span><span class="Comment">** =======================================================<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** clear entries with unmarked keys from all weaktables in list 'l' up<br/></li>
<li></span><span class="Comment">** to element 'f'<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L619">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">clearkeys</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g, <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *l, <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *f) {<br/></li>
<li>&nbsp; <span class="Statement">for</span> (; l != f; l = <a href="lstate.h.html#L202" title="lstate.h:202">gco2t</a>(l)-&gt;gclist) {<br/></li>
<li>&nbsp; &nbsp; <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *h = <a href="lstate.h.html#L202" title="lstate.h:202">gco2t</a>(l);<br/></li>
<li>&nbsp; &nbsp; <a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *n, *limit = <a href="#L102" title="lgc.c:102">gnodelast</a>(h);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (n = <a href="ltable.h.html#L13" title="ltable.h:13">gnode</a>(h, <span class="Constant">0</span>); n &lt; limit; n++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(<a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(n)) &amp;&amp; (<a href="#L129" title="lgc.c:129">iscleared</a>(g, <a href="ltable.h.html#L19" title="ltable.h:19">gkey</a>(n)))) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L196" title="lobject.h:196">setnilvalue</a>(<a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(n));&nbsp; <span class="Comment">/* remove value ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="lgc.c:115">removeentry</a>(n);&nbsp; <span class="Comment">/* and remove entry from table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** clear entries with unmarked values from all weaktables in list 'l' up<br/></li>
<li></span><span class="Comment">** to element 'f'<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L637">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">clearvalues</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g, <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *l, <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *f) {<br/></li>
<li>&nbsp; <span class="Statement">for</span> (; l != f; l = <a href="lstate.h.html#L202" title="lstate.h:202">gco2t</a>(l)-&gt;gclist) {<br/></li>
<li>&nbsp; &nbsp; <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *h = <a href="lstate.h.html#L202" title="lstate.h:202">gco2t</a>(l);<br/></li>
<li>&nbsp; &nbsp; <a href="lobject.h.html#L482" title="lobject.h:482">Node</a> *n, *limit = <a href="#L102" title="lgc.c:102">gnodelast</a>(h);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> i;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; h-&gt;sizearray; i++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *o = &amp;h-&gt;array[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L129" title="lgc.c:129">iscleared</a>(g, o))&nbsp; <span class="Comment">/* value was collected? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L196" title="lobject.h:196">setnilvalue</a>(o);&nbsp; <span class="Comment">/* remove value */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (n = <a href="ltable.h.html#L13" title="ltable.h:13">gnode</a>(h, <span class="Constant">0</span>); n &lt; limit; n++) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="lobject.h.html#L137" title="lobject.h:137">ttisnil</a>(<a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(n)) &amp;&amp; <a href="#L129" title="lgc.c:129">iscleared</a>(g, <a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(n))) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L196" title="lobject.h:196">setnilvalue</a>(<a href="ltable.h.html#L14" title="ltable.h:14">gval</a>(n));&nbsp; <span class="Comment">/* remove value ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="lgc.c:115">removeentry</a>(n);&nbsp; <span class="Comment">/* and remove entry from table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L657">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaC_upvdeccount</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lfunc.h.html#L28" title="lfunc.h:28">UpVal</a> *uv) {<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(uv-&gt;refcount &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; uv-&gt;refcount--;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (uv-&gt;refcount == <span class="Constant">0</span> &amp;&amp; !<a href="lfunc.h.html#L40" title="lfunc.h:40">upisopen</a>(uv))<br/></li>
<li>&nbsp; &nbsp; <a href="lmem.h.html#L42" title="lmem.h:42">luaM_free</a>(L, uv);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L665">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">freeLclosure</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lobject.h.html#L444" title="lobject.h:444">LClosure</a> *cl) {<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; cl-&gt;nupvalues; i++) {<br/></li>
<li>&nbsp; &nbsp; <a href="lfunc.h.html#L28" title="lfunc.h:28">UpVal</a> *uv = cl-&gt;upvals[i];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (uv)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L657" title="lgc.c:657">luaC_upvdeccount</a>(L, uv);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="lmem.h.html#L41" title="lmem.h:41">luaM_freemem</a>(L, cl, <a href="lfunc.h.html#L17" title="lfunc.h:17">sizeLclosure</a>(cl-&gt;nupvalues));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L676">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">freeobj</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *o) {<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (o-&gt;tt) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L22" title="lobject.h:22">LUA_TPROTO</a>: <a href="lfunc.c.html#L125" title="lfunc.c:125">luaF_freeproto</a>(L, <a href="lstate.h.html#L203" title="lstate.h:203">gco2p</a>(o)); <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L49" title="lobject.h:49">LUA_TLCL</a>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L665" title="lgc.c:665">freeLclosure</a>(L, <a href="lstate.h.html#L198" title="lstate.h:198">gco2lcl</a>(o));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L51" title="lobject.h:51">LUA_TCCL</a>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lmem.h.html#L41" title="lmem.h:41">luaM_freemem</a>(L, o, <a href="lfunc.h.html#L14" title="lfunc.h:14">sizeCclosure</a>(<a href="lstate.h.html#L199" title="lstate.h:199">gco2ccl</a>(o)-&gt;nupvalues));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lua.h.html#L67" title="lua.h:67">LUA_TTABLE</a>: <a href="ltable.c.html#L415" title="ltable.c:415">luaH_free</a>(L, <a href="lstate.h.html#L202" title="lstate.h:202">gco2t</a>(o)); <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lua.h.html#L70" title="lua.h:70">LUA_TTHREAD</a>: <a href="lstate.c.html#L283" title="lstate.c:283">luaE_freethread</a>(L, <a href="lstate.h.html#L204" title="lstate.h:204">gco2th</a>(o)); <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lua.h.html#L69" title="lua.h:69">LUA_TUSERDATA</a>: <a href="lmem.h.html#L41" title="lmem.h:41">luaM_freemem</a>(L, o, <a href="lstring.h.html#L19" title="lstring.h:19">sizeudata</a>(<a href="lstate.h.html#L197" title="lstate.h:197">gco2u</a>(o))); <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L55" title="lobject.h:55">LUA_TSHRSTR</a>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lstring.c.html#L109" title="lstring.c:109">luaS_remove</a>(L, <a href="lstate.h.html#L195" title="lstate.h:195">gco2ts</a>(o));&nbsp; <span class="Comment">/* remove it from hash table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Comment">/* go through */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lobject.h.html#L56" title="lobject.h:56">LUA_TLNGSTR</a>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lmem.h.html#L41" title="lmem.h:41">luaM_freemem</a>(L, o, <a href="lstring.h.html#L16" title="lstring.h:16">sizestring</a>(<a href="lstate.h.html#L195" title="lstate.h:195">gco2ts</a>(o)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L702">&#x200c;</a><span class="PreProc">#define <span class="linkable">sweepwholelist</span>(L,p)&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L713" title="lgc.c:713">sweeplist</a>(L,p,<a href="llimits.h.html#L46" title="llimits.h:46">MAX_LUMEM</a>)<br/></li>
<li></span><span class="Type">static</span> <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> **<a href="#L713" title="lgc.c:713">sweeplist</a> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> **p, <a href="llimits.h.html#L23" title="llimits.h:23">lu_mem</a> count);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** sweep at most 'count' elements from a list of GCObjects erasing dead<br/></li>
<li></span><span class="Comment">** objects, where a dead object is one marked with the old (non current)<br/></li>
<li></span><span class="Comment">** white; change all non-dead objects back to white, preparing for <a href="llex.c.html#L31" title="llex.c:31">next</a><br/></li>
<li></span><span class="Comment">** collection cycle. Return where to continue the traversal or NULL if<br/></li>
<li></span><span class="Comment">** list is finished.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L713">&#x200c;</a></span><span class="Type">static</span> <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> **<span class="linkable">sweeplist</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> **p, <a href="llimits.h.html#L23" title="llimits.h:23">lu_mem</a> count) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g = <a href="lstate.h.html#L175" title="lstate.h:175">G</a>(L);<br/></li>
<li>&nbsp; <span class="Type">int</span> ow = <a href="lgc.h.html#L94" title="lgc.h:94">otherwhite</a>(g);<br/></li>
<li>&nbsp; <span class="Type">int</span> white = <a href="lgc.h.html#L101" title="lgc.h:101">luaC_white</a>(g);&nbsp; <span class="Comment">/* current white */<br/></li>
<li></span>&nbsp; <span class="Statement">while</span> (*p != <span class="Constant">NULL</span> &amp;&amp; count-- &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *curr = *p;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> marked = curr-&gt;marked;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="lgc.h.html#L95" title="lgc.h:95">isdeadm</a>(ow, marked)) {&nbsp; <span class="Comment">/* is 'curr' dead? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; *p = curr-&gt;<a href="llex.c.html#L31" title="llex.c:31">next</a>;&nbsp; <span class="Comment">/* remove 'curr' from list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L676" title="lgc.c:676">freeobj</a>(L, curr);&nbsp; <span class="Comment">/* erase 'curr' */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> {&nbsp; <span class="Comment">/* change mark to 'white' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; curr-&gt;marked = <a href="llimits.h.html#L110" title="llimits.h:110">cast_byte</a>((marked &amp; <a href="#L66" title="lgc.c:66">maskcolors</a>) | white);<br/></li>
<li>&nbsp; &nbsp; &nbsp; p = &amp;curr-&gt;<a href="llex.c.html#L31" title="llex.c:31">next</a>;&nbsp; <span class="Comment">/* go to <a href="llex.c.html#L31" title="llex.c:31">next</a> element */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> (*p == <span class="Constant">NULL</span>) ? <span class="Constant">NULL</span> : p;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** sweep a list until a live object (or end of list)<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L736">&#x200c;</a></span><span class="Type">static</span> <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> **<span class="linkable">sweeptolive</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> **p, <span class="Type">int</span> *n) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> **old = p;<br/></li>
<li>&nbsp; <span class="Type">int</span> i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Statement">do</span> {<br/></li>
<li>&nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; p = <a href="#L713" title="lgc.c:713">sweeplist</a>(L, p, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; } <span class="Statement">while</span> (p == old);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (n) *n += i;<br/></li>
<li>&nbsp; <span class="Statement">return</span> p;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* }====================================================== */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** {======================================================<br/></li>
<li></span><span class="Comment">** Finalization<br/></li>
<li></span><span class="Comment">** =======================================================<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** If possible, free concatenation buffer and shrink string table<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L759">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">checkSizes</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (g-&gt;gckind != <a href="lstate.h.html#L46" title="lstate.h:46">KGC_EMERGENCY</a>) {<br/></li>
<li>&nbsp; &nbsp; <a href="llimits.h.html#L24" title="llimits.h:24">l_mem</a> olddebt = g-&gt;GCdebt;<br/></li>
<li>&nbsp; &nbsp; <a href="lzio.h.html#L44" title="lzio.h:44">luaZ_freebuffer</a>(L, &amp;g-&gt;buff);&nbsp; <span class="Comment">/* free concatenation buffer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (g-&gt;strt.nuse &lt; g-&gt;strt.size / <span class="Constant">4</span>)&nbsp; <span class="Comment">/* string table too big? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="lstring.c.html#L60" title="lstring.c:60">luaS_resize</a>(L, g-&gt;strt.size / <span class="Constant">2</span>);&nbsp; <span class="Comment">/* shrink it a little */<br/></li>
<li></span>&nbsp; &nbsp; g-&gt;GCestimate += g-&gt;GCdebt - olddebt;&nbsp; <span class="Comment">/* update estimate */<br/></li>
<li></span>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L770">&#x200c;</a><span class="Type">static</span> <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *<span class="linkable">udata2finalize</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *o = g-&gt;tobefnz;&nbsp; <span class="Comment">/* get first element */<br/></li>
<li></span>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<a href="lgc.h.html#L92" title="lgc.h:92">tofinalize</a>(o));<br/></li>
<li>&nbsp; g-&gt;tobefnz = o-&gt;<a href="llex.c.html#L31" title="llex.c:31">next</a>;&nbsp; <span class="Comment">/* remove it from 'tobefnz' list */<br/></li>
<li></span>&nbsp; o-&gt;<a href="llex.c.html#L31" title="llex.c:31">next</a> = g-&gt;allgc;&nbsp; <span class="Comment">/* return it to 'allgc' list */<br/></li>
<li></span>&nbsp; g-&gt;allgc = o;<br/></li>
<li>&nbsp; <a href="lgc.h.html#L73" title="lgc.h:73">resetbit</a>(o-&gt;marked, <a href="lgc.h.html#L81" title="lgc.h:81">FINALIZEDBIT</a>);&nbsp; <span class="Comment">/* object is &quot;normal&quot; again */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="lgc.h.html#L49" title="lgc.h:49">issweepphase</a>(g))<br/></li>
<li>&nbsp; &nbsp; <a href="#L67" title="lgc.c:67">makewhite</a>(g, o);&nbsp; <span class="Comment">/* &quot;sweep&quot; object */<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> o;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L783">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">dothecall</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <span class="Type">void</span> *ud) {<br/></li>
<li>&nbsp; <a href="llimits.h.html#L103" title="llimits.h:103">UNUSED</a>(ud);<br/></li>
<li>&nbsp; <a href="ldo.c.html#L413" title="ldo.c:413">luaD_call</a>(L, L-&gt;top - <span class="Constant">2</span>, <span class="Constant">0</span>, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L789">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">GCTM</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <span class="Type">int</span> propagateerrors) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g = <a href="lstate.h.html#L175" title="lstate.h:175">G</a>(L);<br/></li>
<li>&nbsp; <span class="Type">const</span> <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *tm;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> v;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L207" title="lobject.h:207">setgcovalue</a>(L, &amp;v, <a href="#L770" title="lgc.c:770">udata2finalize</a>(g));<br/></li>
<li>&nbsp; tm = <a href="ltm.c.html#L70" title="ltm.c:70">luaT_gettmbyobj</a>(L, &amp;v, TM_GC);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (tm != <span class="Constant">NULL</span> &amp;&amp; <a href="lobject.h.html#L144" title="lobject.h:144">ttisfunction</a>(tm)) {&nbsp; <span class="Comment">/* is there a finalizer? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span> status;<br/></li>
<li>&nbsp; &nbsp; <a href="llimits.h.html#L35" title="llimits.h:35">lu_byte</a> oldah = L-&gt;allowhook;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> running&nbsp; = g-&gt;gcrunning;<br/></li>
<li>&nbsp; &nbsp; L-&gt;allowhook = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* stop debug hooks during GC metamethod */<br/></li>
<li></span>&nbsp; &nbsp; g-&gt;gcrunning = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* avoid GC steps */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lobject.h.html#L257" title="lobject.h:257">setobj2s</a>(L, L-&gt;top, tm);&nbsp; <span class="Comment">/* push finalizer... */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lobject.h.html#L257" title="lobject.h:257">setobj2s</a>(L, L-&gt;top + <span class="Constant">1</span>, &amp;v);&nbsp; <span class="Comment">/* ... and its argument */<br/></li>
<li></span>&nbsp; &nbsp; L-&gt;top += <span class="Constant">2</span>;&nbsp; <span class="Comment">/* and (<a href="llex.c.html#L31" title="llex.c:31">next</a> line) call the finalizer */<br/></li>
<li></span>&nbsp; &nbsp; status = <a href="ldo.c.html#L636" title="ldo.c:636">luaD_pcall</a>(L, <a href="#L783" title="lgc.c:783">dothecall</a>, <span class="Constant">NULL</span>, <a href="ldo.h.html#L22" title="ldo.h:22">savestack</a>(L, L-&gt;top - <span class="Constant">2</span>), <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; L-&gt;allowhook = oldah;&nbsp; <span class="Comment">/* restore hooks */<br/></li>
<li></span>&nbsp; &nbsp; g-&gt;gcrunning = running;&nbsp; <span class="Comment">/* restore state */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (status != <a href="lua.h.html#L45" title="lua.h:45">LUA_OK</a> &amp;&amp; propagateerrors) {&nbsp; <span class="Comment">/* <a href="lundump.c.html#L40" title="lundump.c:40">error</a> while running __gc? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (status == <a href="lua.h.html#L47" title="lua.h:47">LUA_ERRRUN</a>) {&nbsp; <span class="Comment">/* is there an <a href="lundump.c.html#L40" title="lundump.c:40">error</a> object? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *msg = (<a href="lobject.h.html#L140" title="lobject.h:140">ttisstring</a>(L-&gt;top - <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? <a href="lobject.h.html#L330" title="lobject.h:330">svalue</a>(L-&gt;top - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : <span class="Constant">&quot;no message&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lobject.c.html#L416" title="lobject.c:416">luaO_pushfstring</a>(L, <span class="Constant">&quot;<a href="lundump.c.html#L40" title="lundump.c:40">error</a> in __gc metamethod (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>, msg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; status = <a href="lua.h.html#L50" title="lua.h:50">LUA_ERRGCMM</a>;&nbsp; <span class="Comment">/* <a href="lundump.c.html#L40" title="lundump.c:40">error</a> in __gc metamethod */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="ldo.c.html#L110" title="ldo.c:110">luaD_throw</a>(L, status);&nbsp; <span class="Comment">/* re-throw <a href="lundump.c.html#L40" title="lundump.c:40">error</a> */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** call a few (up to 'g-&gt;gcfinnum') finalizers<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L824">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">runafewfinalizers</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g = <a href="lstate.h.html#L175" title="lstate.h:175">G</a>(L);<br/></li>
<li>&nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(!g-&gt;tobefnz || g-&gt;gcfinnum &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; g-&gt;tobefnz &amp;&amp; i &lt; g-&gt;gcfinnum; i++)<br/></li>
<li>&nbsp; &nbsp; <a href="#L789" title="lgc.c:789">GCTM</a>(L, <span class="Constant">1</span>);&nbsp; <span class="Comment">/* call one finalizer */<br/></li>
<li></span>&nbsp; g-&gt;gcfinnum = (!g-&gt;tobefnz) ? <span class="Constant">0</span>&nbsp; <span class="Comment">/* nothing more to finalize? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : g-&gt;gcfinnum * <span class="Constant">2</span>;&nbsp; <span class="Comment">/* else call a few more <a href="llex.c.html#L31" title="llex.c:31">next</a> time */<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> i;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** call all pending finalizers<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L839">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">callallpendingfinalizers</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <span class="Type">int</span> propagateerrors) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g = <a href="lstate.h.html#L175" title="lstate.h:175">G</a>(L);<br/></li>
<li>&nbsp; <span class="Statement">while</span> (g-&gt;tobefnz)<br/></li>
<li>&nbsp; &nbsp; <a href="#L789" title="lgc.c:789">GCTM</a>(L, propagateerrors);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** find last '<a href="llex.c.html#L31" title="llex.c:31">next</a>' <a href="lparser.c.html#L696" title="lparser.c:696">field</a> in list 'p' list (to add elements in its end)<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L849">&#x200c;</a></span><span class="Type">static</span> <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> **<span class="linkable">findlast</span> (<a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> **p) {<br/></li>
<li>&nbsp; <span class="Statement">while</span> (*p != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; p = &amp;(*p)-&gt;<a href="llex.c.html#L31" title="llex.c:31">next</a>;<br/></li>
<li>&nbsp; <span class="Statement">return</span> p;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** move all unreachable objects (or 'all' objects) that need<br/></li>
<li></span><span class="Comment">** finalization from list 'finobj' to list 'tobefnz' (to be finalized)<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L860">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">separatetobefnz</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g, <span class="Type">int</span> all) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *curr;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> **p = &amp;g-&gt;finobj;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> **lastnext = <a href="#L849" title="lgc.c:849">findlast</a>(&amp;g-&gt;tobefnz);<br/></li>
<li>&nbsp; <span class="Statement">while</span> ((curr = *p) != <span class="Constant">NULL</span>) {&nbsp; <span class="Comment">/* traverse all finalizable objects */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<a href="lgc.h.html#L92" title="lgc.h:92">tofinalize</a>(curr));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(<a href="lgc.h.html#L87" title="lgc.h:87">iswhite</a>(curr) || all))&nbsp; <span class="Comment">/* not being collected? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; p = &amp;curr-&gt;<a href="llex.c.html#L31" title="llex.c:31">next</a>;&nbsp; <span class="Comment">/* don't bother with it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; *p = curr-&gt;<a href="llex.c.html#L31" title="llex.c:31">next</a>;&nbsp; <span class="Comment">/* remove 'curr' from 'finobj' list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; curr-&gt;<a href="llex.c.html#L31" title="llex.c:31">next</a> = *lastnext;&nbsp; <span class="Comment">/* link at the end of 'tobefnz' list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; *lastnext = curr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; lastnext = &amp;curr-&gt;<a href="llex.c.html#L31" title="llex.c:31">next</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** if object 'o' has a finalizer, remove it from 'allgc' list (must<br/></li>
<li></span><span class="Comment">** search the list to find it) and link it in 'finobj' list.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L882">&#x200c;</a></span><span class="Type">void</span> <span class="linkable">luaC_checkfinalizer</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *o, <a href="lobject.h.html#L488" title="lobject.h:488">Table</a> *mt) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g = <a href="lstate.h.html#L175" title="lstate.h:175">G</a>(L);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="lgc.h.html#L92" title="lgc.h:92">tofinalize</a>(o) ||&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* obj. is already marked... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="ltm.h.html#L48" title="ltm.h:48">gfasttm</a>(g, mt, TM_GC) == <span class="Constant">NULL</span>)&nbsp;&nbsp; <span class="Comment">/* or has no finalizer? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; <span class="Comment">/* nothing to be done */<br/></li>
<li></span>&nbsp; <span class="Statement">else</span> {&nbsp; <span class="Comment">/* move 'o' to 'finobj' list */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> **p;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="lgc.h.html#L49" title="lgc.h:49">issweepphase</a>(g)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L67" title="lgc.c:67">makewhite</a>(g, o);&nbsp; <span class="Comment">/* &quot;sweep&quot; object 'o' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (g-&gt;sweepgc == &amp;o-&gt;<a href="llex.c.html#L31" title="llex.c:31">next</a>)&nbsp; <span class="Comment">/* should not remove 'sweepgc' object */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; g-&gt;sweepgc = <a href="#L736" title="lgc.c:736">sweeptolive</a>(L, g-&gt;sweepgc, <span class="Constant">NULL</span>);&nbsp; <span class="Comment">/* change 'sweepgc' */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* search for pointer pointing to 'o' */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (p = &amp;g-&gt;allgc; *p != o; p = &amp;(*p)-&gt;<a href="llex.c.html#L31" title="llex.c:31">next</a>) { <span class="Comment">/* empty */</span> }<br/></li>
<li>&nbsp; &nbsp; *p = o-&gt;<a href="llex.c.html#L31" title="llex.c:31">next</a>;&nbsp; <span class="Comment">/* remove 'o' from 'allgc' list */<br/></li>
<li></span>&nbsp; &nbsp; o-&gt;<a href="llex.c.html#L31" title="llex.c:31">next</a> = g-&gt;finobj;&nbsp; <span class="Comment">/* link it in 'finobj' list */<br/></li>
<li></span>&nbsp; &nbsp; g-&gt;finobj = o;<br/></li>
<li>&nbsp; &nbsp; <a href="lgc.h.html#L72" title="lgc.h:72">l_setbit</a>(o-&gt;marked, <a href="lgc.h.html#L81" title="lgc.h:81">FINALIZEDBIT</a>);&nbsp; <span class="Comment">/* mark it as such */<br/></li>
<li></span>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* }====================================================== */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** {======================================================<br/></li>
<li></span><span class="Comment">** GC control<br/></li>
<li></span><span class="Comment">** =======================================================<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** Set a reasonable &quot;time&quot; to wait before starting a new GC cycle; cycle<br/></li>
<li></span><span class="Comment">** will start when memory use hits threshold. (Division by 'estimate'<br/></li>
<li></span><span class="Comment">** should be OK: it <a href="luac.c.html#L44" title="luac.c:44">cannot</a> be zero (because Lua <a href="luac.c.html#L44" title="luac.c:44">cannot</a> even start with<br/></li>
<li></span><span class="Comment">** less than <a href="#L59" title="lgc.c:59">PAUSEADJ</a> bytes).<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L920">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">setpause</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g) {<br/></li>
<li>&nbsp; <a href="llimits.h.html#L24" title="llimits.h:24">l_mem</a> threshold, debt;<br/></li>
<li>&nbsp; <a href="llimits.h.html#L24" title="llimits.h:24">l_mem</a> estimate = g-&gt;GCestimate / <a href="#L59" title="lgc.c:59">PAUSEADJ</a>;&nbsp; <span class="Comment">/* adjust 'estimate' */<br/></li>
<li></span>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(estimate &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; threshold = (g-&gt;gcpause &lt; <a href="llimits.h.html#L48" title="llimits.h:48">MAX_LMEM</a> / estimate)&nbsp; <span class="Comment">/* overflow? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? estimate * g-&gt;gcpause&nbsp; <span class="Comment">/* no overflow */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : <a href="llimits.h.html#L48" title="llimits.h:48">MAX_LMEM</a>;&nbsp; <span class="Comment">/* overflow; truncate to maximum */<br/></li>
<li></span>&nbsp; debt = <a href="lstate.h.html#L213" title="lstate.h:213">gettotalbytes</a>(g) - threshold;<br/></li>
<li>&nbsp; <a href="lstate.c.html#L101" title="lstate.c:101">luaE_setdebt</a>(g, debt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** Enter first sweep phase.<br/></li>
<li></span><span class="Comment">** The call to '<a href="#L736" title="lgc.c:736">sweeptolive</a>' makes pointer point to an object inside<br/></li>
<li></span><span class="Comment">** the list (instead of to the header), so that the real sweep do not<br/></li>
<li></span><span class="Comment">** need to skip objects created between &quot;now&quot; and the start of the real<br/></li>
<li></span><span class="Comment">** sweep.<br/></li>
<li></span><span class="Comment">** Returns how many objects it swept.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L940">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">entersweep</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g = <a href="lstate.h.html#L175" title="lstate.h:175">G</a>(L);<br/></li>
<li>&nbsp; <span class="Type">int</span> n = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; g-&gt;gcstate = <a href="lgc.h.html#L41" title="lgc.h:41">GCSswpallgc</a>;<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(g-&gt;sweepgc == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; g-&gt;sweepgc = <a href="#L736" title="lgc.c:736">sweeptolive</a>(L, &amp;g-&gt;allgc, &amp;n);<br/></li>
<li>&nbsp; <span class="Statement">return</span> n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L950">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaC_freeallobjects</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g = <a href="lstate.h.html#L175" title="lstate.h:175">G</a>(L);<br/></li>
<li>&nbsp; <a href="#L860" title="lgc.c:860">separatetobefnz</a>(g, <span class="Constant">1</span>);&nbsp; <span class="Comment">/* separate all objects with finalizers */<br/></li>
<li></span>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(g-&gt;finobj == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; <a href="#L839" title="lgc.c:839">callallpendingfinalizers</a>(L, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(g-&gt;tobefnz == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; g-&gt;currentwhite = <a href="lgc.h.html#L84" title="lgc.h:84">WHITEBITS</a>; <span class="Comment">/* this &quot;white&quot; makes all objects look dead */<br/></li>
<li></span>&nbsp; g-&gt;gckind = <a href="lstate.h.html#L45" title="lstate.h:45">KGC_NORMAL</a>;<br/></li>
<li>&nbsp; <a href="#L702" title="lgc.c:702">sweepwholelist</a>(L, &amp;g-&gt;finobj);<br/></li>
<li>&nbsp; <a href="#L702" title="lgc.c:702">sweepwholelist</a>(L, &amp;g-&gt;allgc);<br/></li>
<li>&nbsp; <a href="#L702" title="lgc.c:702">sweepwholelist</a>(L, &amp;g-&gt;fixedgc);&nbsp; <span class="Comment">/* collect fixed objects */<br/></li>
<li></span>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(g-&gt;strt.nuse == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L965">&#x200c;</a><span class="Type">static</span> <a href="llimits.h.html#L24" title="llimits.h:24">l_mem</a> <span class="linkable">atomic</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g = <a href="lstate.h.html#L175" title="lstate.h:175">G</a>(L);<br/></li>
<li>&nbsp; <a href="llimits.h.html#L24" title="llimits.h:24">l_mem</a> work;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *origweak, *origall;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> *grayagain = g-&gt;grayagain;&nbsp; <span class="Comment">/* <a href="llex.c.html#L56" title="llex.c:56">save</a> original list */<br/></li>
<li></span>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(g-&gt;ephemeron == <span class="Constant">NULL</span> &amp;&amp; g-&gt;weak == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(!<a href="lgc.h.html#L87" title="lgc.h:87">iswhite</a>(g-&gt;mainthread));<br/></li>
<li>&nbsp; g-&gt;gcstate = <a href="#L33" title="lgc.c:33">GCSinsideatomic</a>;<br/></li>
<li>&nbsp; g-&gt;GCmemtrav = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* start counting work */<br/></li>
<li></span>&nbsp; <a href="#L86" title="lgc.c:86">markobject</a>(g, L);&nbsp; <span class="Comment">/* mark running thread */<br/></li>
<li></span>&nbsp; <span class="Comment">/* registry and global metatables may be changed by API */<br/></li>
<li></span>&nbsp; <a href="#L83" title="lgc.c:83">markvalue</a>(g, &amp;g-&gt;l_registry);<br/></li>
<li>&nbsp; <a href="#L275" title="lgc.c:275">markmt</a>(g);&nbsp; <span class="Comment">/* mark global metatables */<br/></li>
<li></span>&nbsp; <span class="Comment">/* remark occasional upvalues of (maybe) dead threads */<br/></li>
<li></span>&nbsp; <a href="#L298" title="lgc.c:298">remarkupvals</a>(g);<br/></li>
<li>&nbsp; <a href="#L583" title="lgc.c:583">propagateall</a>(g);&nbsp; <span class="Comment">/* propagate changes */<br/></li>
<li></span>&nbsp; work = g-&gt;GCmemtrav;&nbsp; <span class="Comment">/* stop counting (do not recount 'grayagain') */<br/></li>
<li></span>&nbsp; g-&gt;gray = grayagain;<br/></li>
<li>&nbsp; <a href="#L583" title="lgc.c:583">propagateall</a>(g);&nbsp; <span class="Comment">/* traverse 'grayagain' list */<br/></li>
<li></span>&nbsp; g-&gt;GCmemtrav = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* restart counting */<br/></li>
<li></span>&nbsp; <a href="#L588" title="lgc.c:588">convergeephemerons</a>(g);<br/></li>
<li>&nbsp; <span class="Comment">/* at this point, all strongly accessible objects are marked. */<br/></li>
<li></span>&nbsp; <span class="Comment">/* Clear values from weak tables, before checking finalizers */<br/></li>
<li></span>&nbsp; <a href="#L637" title="lgc.c:637">clearvalues</a>(g, g-&gt;weak, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; <a href="#L637" title="lgc.c:637">clearvalues</a>(g, g-&gt;allweak, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; origweak = g-&gt;weak; origall = g-&gt;allweak;<br/></li>
<li>&nbsp; work += g-&gt;GCmemtrav;&nbsp; <span class="Comment">/* stop counting (objects being finalized) */<br/></li>
<li></span>&nbsp; <a href="#L860" title="lgc.c:860">separatetobefnz</a>(g, <span class="Constant">0</span>);&nbsp; <span class="Comment">/* separate objects to be finalized */<br/></li>
<li></span>&nbsp; g-&gt;gcfinnum = <span class="Constant">1</span>;&nbsp; <span class="Comment">/* there may be objects to be finalized */<br/></li>
<li></span>&nbsp; <a href="#L285" title="lgc.c:285">markbeingfnz</a>(g);&nbsp; <span class="Comment">/* mark objects that will be finalized */<br/></li>
<li></span>&nbsp; <a href="#L583" title="lgc.c:583">propagateall</a>(g);&nbsp; <span class="Comment">/* remark, to propagate 'resurrection' */<br/></li>
<li></span>&nbsp; g-&gt;GCmemtrav = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* restart counting */<br/></li>
<li></span>&nbsp; <a href="#L588" title="lgc.c:588">convergeephemerons</a>(g);<br/></li>
<li>&nbsp; <span class="Comment">/* at this point, all resurrected objects are marked. */<br/></li>
<li></span>&nbsp; <span class="Comment">/* remove dead objects from weak tables */<br/></li>
<li></span>&nbsp; <a href="#L619" title="lgc.c:619">clearkeys</a>(g, g-&gt;ephemeron, <span class="Constant">NULL</span>);&nbsp; <span class="Comment">/* clear keys from all ephemeron tables */<br/></li>
<li></span>&nbsp; <a href="#L619" title="lgc.c:619">clearkeys</a>(g, g-&gt;allweak, <span class="Constant">NULL</span>);&nbsp; <span class="Comment">/* clear keys from all 'allweak' tables */<br/></li>
<li></span>&nbsp; <span class="Comment">/* clear values from resurrected weak tables */<br/></li>
<li></span>&nbsp; <a href="#L637" title="lgc.c:637">clearvalues</a>(g, g-&gt;weak, origweak);<br/></li>
<li>&nbsp; <a href="#L637" title="lgc.c:637">clearvalues</a>(g, g-&gt;allweak, origall);<br/></li>
<li>&nbsp; g-&gt;currentwhite = <a href="llimits.h.html#L110" title="llimits.h:110">cast_byte</a>(<a href="lgc.h.html#L94" title="lgc.h:94">otherwhite</a>(g));&nbsp; <span class="Comment">/* flip current white */<br/></li>
<li></span>&nbsp; work += g-&gt;GCmemtrav;&nbsp; <span class="Comment">/* complete counting */<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> work;&nbsp; <span class="Comment">/* estimate of memory marked by '<a href="#L965" title="lgc.c:965">atomic</a>' */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1011">&#x200c;</a><span class="Type">static</span> <a href="llimits.h.html#L23" title="llimits.h:23">lu_mem</a> <span class="linkable">sweepstep</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nextstate, <a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a> **nextlist) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (g-&gt;sweepgc) {<br/></li>
<li>&nbsp; &nbsp; <a href="llimits.h.html#L24" title="llimits.h:24">l_mem</a> olddebt = g-&gt;GCdebt;<br/></li>
<li>&nbsp; &nbsp; g-&gt;sweepgc = <a href="#L713" title="lgc.c:713">sweeplist</a>(L, g-&gt;sweepgc, <a href="#L42" title="lgc.c:42">GCSWEEPMAX</a>);<br/></li>
<li>&nbsp; &nbsp; g-&gt;GCestimate += g-&gt;GCdebt - olddebt;&nbsp; <span class="Comment">/* update estimate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (g-&gt;sweepgc)&nbsp; <span class="Comment">/* is there still something to sweep? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L42" title="lgc.c:42">GCSWEEPMAX</a> * <a href="#L39" title="lgc.c:39">GCSWEEPCOST</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* else enter <a href="llex.c.html#L31" title="llex.c:31">next</a> state */<br/></li>
<li></span>&nbsp; g-&gt;gcstate = nextstate;<br/></li>
<li>&nbsp; g-&gt;sweepgc = nextlist;<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1027">&#x200c;</a><span class="Type">static</span> <a href="llimits.h.html#L23" title="llimits.h:23">lu_mem</a> <span class="linkable">singlestep</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g = <a href="lstate.h.html#L175" title="lstate.h:175">G</a>(L);<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (g-&gt;gcstate) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lgc.h.html#L46" title="lgc.h:46">GCSpause</a>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; g-&gt;GCmemtrav = g-&gt;strt.size * <span class="Statement">sizeof</span>(<a href="lobject.h.html#L87" title="lobject.h:87">GCObject</a>*);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L323" title="lgc.c:323">restartcollection</a>(g);<br/></li>
<li>&nbsp; &nbsp; &nbsp; g-&gt;gcstate = <a href="lgc.h.html#L39" title="lgc.h:39">GCSpropagate</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> g-&gt;GCmemtrav;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lgc.h.html#L39" title="lgc.h:39">GCSpropagate</a>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; g-&gt;GCmemtrav = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(g-&gt;gray);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L539" title="lgc.c:539">propagatemark</a>(g);<br/></li>
<li>&nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement">if</span> (g-&gt;gray == <span class="Constant">NULL</span>)&nbsp; <span class="Comment">/* no more gray objects? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; g-&gt;gcstate = <a href="lgc.h.html#L40" title="lgc.h:40">GCSatomic</a>;&nbsp; <span class="Comment">/* finish propagate phase */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> g-&gt;GCmemtrav;&nbsp; <span class="Comment">/* memory traversed in this step */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lgc.h.html#L40" title="lgc.h:40">GCSatomic</a>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="llimits.h.html#L23" title="llimits.h:23">lu_mem</a> work;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">int</span> sw;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L583" title="lgc.c:583">propagateall</a>(g);&nbsp; <span class="Comment">/* make sure gray list is empty */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; work = <a href="#L965" title="lgc.c:965">atomic</a>(L);&nbsp; <span class="Comment">/* work is what was traversed by '<a href="#L965" title="lgc.c:965">atomic</a>' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; sw = <a href="#L940" title="lgc.c:940">entersweep</a>(L);<br/></li>
<li>&nbsp; &nbsp; &nbsp; g-&gt;GCestimate = <a href="lstate.h.html#L213" title="lstate.h:213">gettotalbytes</a>(g);&nbsp; <span class="Comment">/* first estimate */</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> work + sw * <a href="#L39" title="lgc.c:39">GCSWEEPCOST</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lgc.h.html#L41" title="lgc.h:41">GCSswpallgc</a>: {&nbsp; <span class="Comment">/* sweep &quot;regular&quot; objects */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1011" title="lgc.c:1011">sweepstep</a>(L, g, <a href="lgc.h.html#L42" title="lgc.h:42">GCSswpfinobj</a>, &amp;g-&gt;finobj);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lgc.h.html#L42" title="lgc.h:42">GCSswpfinobj</a>: {&nbsp; <span class="Comment">/* sweep objects with finalizers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1011" title="lgc.c:1011">sweepstep</a>(L, g, <a href="lgc.h.html#L43" title="lgc.h:43">GCSswptobefnz</a>, &amp;g-&gt;tobefnz);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lgc.h.html#L43" title="lgc.h:43">GCSswptobefnz</a>: {&nbsp; <span class="Comment">/* sweep objects to be finalized */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1011" title="lgc.c:1011">sweepstep</a>(L, g, <a href="lgc.h.html#L44" title="lgc.h:44">GCSswpend</a>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lgc.h.html#L44" title="lgc.h:44">GCSswpend</a>: {&nbsp; <span class="Comment">/* finish sweeps */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L67" title="lgc.c:67">makewhite</a>(g, g-&gt;mainthread);&nbsp; <span class="Comment">/* sweep <a href="lua.c.html#L595" title="lua.c:595">main</a> thread */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L759" title="lgc.c:759">checkSizes</a>(L, g);<br/></li>
<li>&nbsp; &nbsp; &nbsp; g-&gt;gcstate = <a href="lgc.h.html#L45" title="lgc.h:45">GCScallfin</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lgc.h.html#L45" title="lgc.h:45">GCScallfin</a>: {&nbsp; <span class="Comment">/* call remaining finalizers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (g-&gt;tobefnz &amp;&amp; g-&gt;gckind != <a href="lstate.h.html#L46" title="lstate.h:46">KGC_EMERGENCY</a>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> n = <a href="#L824" title="lgc.c:824">runafewfinalizers</a>(L);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (n * <a href="#L45" title="lgc.c:45">GCFINALIZECOST</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">else</span> {&nbsp; <span class="Comment">/* emergency mode or no more finalizers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; g-&gt;gcstate = <a href="lgc.h.html#L46" title="lgc.h:46">GCSpause</a>;&nbsp; <span class="Comment">/* finish collection */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<span class="Constant">0</span>); <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** advances the garbage collector until it reaches a state allowed<br/></li>
<li></span><span class="Comment">** by 'statemask'<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L1087">&#x200c;</a></span><span class="Type">void</span> <span class="linkable">luaC_runtilstate</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <span class="Type">int</span> statesmask) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g = <a href="lstate.h.html#L175" title="lstate.h:175">G</a>(L);<br/></li>
<li>&nbsp; <span class="Statement">while</span> (!<a href="lgc.h.html#L74" title="lgc.h:74">testbit</a>(statesmask, g-&gt;gcstate))<br/></li>
<li>&nbsp; &nbsp; <a href="#L1027" title="lgc.c:1027">singlestep</a>(L);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** get GC debt and convert it from Kb to 'work units' (avoid zero debt<br/></li>
<li></span><span class="Comment">** and overflows)<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L1098">&#x200c;</a></span><span class="Type">static</span> <a href="llimits.h.html#L24" title="llimits.h:24">l_mem</a> <span class="linkable">getdebt</span> (<a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g) {<br/></li>
<li>&nbsp; <a href="llimits.h.html#L24" title="llimits.h:24">l_mem</a> debt = g-&gt;GCdebt;<br/></li>
<li>&nbsp; <span class="Type">int</span> stepmul = g-&gt;gcstepmul;<br/></li>
<li>&nbsp; debt = (debt / <a href="#L52" title="lgc.c:52">STEPMULADJ</a>) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; debt = (debt &lt; <a href="llimits.h.html#L48" title="llimits.h:48">MAX_LMEM</a> / stepmul) ? debt * stepmul : <a href="llimits.h.html#L48" title="llimits.h:48">MAX_LMEM</a>;<br/></li>
<li>&nbsp; <span class="Statement">return</span> debt;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** performs a basic GC step when collector is running<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L1109">&#x200c;</a></span><span class="Type">void</span> <span class="linkable">luaC_step</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g = <a href="lstate.h.html#L175" title="lstate.h:175">G</a>(L);<br/></li>
<li>&nbsp; <a href="llimits.h.html#L24" title="llimits.h:24">l_mem</a> debt = <a href="#L1098" title="lgc.c:1098">getdebt</a>(g);&nbsp; <span class="Comment">/* GC deficit (be paid now) */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (!g-&gt;gcrunning) {&nbsp; <span class="Comment">/* not running? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lstate.c.html#L101" title="lstate.c:101">luaE_setdebt</a>(g, -<a href="lgc.h.html#L32" title="lgc.h:32">GCSTEPSIZE</a> * <span class="Constant">10</span>);&nbsp; <span class="Comment">/* avoid being called too often */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">do</span> {&nbsp; <span class="Comment">/* repeat until pause or enough &quot;credit&quot; (negative debt) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="llimits.h.html#L23" title="llimits.h:23">lu_mem</a> work = <a href="#L1027" title="lgc.c:1027">singlestep</a>(L);&nbsp; <span class="Comment">/* perform one single step */<br/></li>
<li></span>&nbsp; &nbsp; debt -= work;<br/></li>
<li>&nbsp; } <span class="Statement">while</span> (debt &gt; -<a href="lgc.h.html#L32" title="lgc.h:32">GCSTEPSIZE</a> &amp;&amp; g-&gt;gcstate != <a href="lgc.h.html#L46" title="lgc.h:46">GCSpause</a>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (g-&gt;gcstate == <a href="lgc.h.html#L46" title="lgc.h:46">GCSpause</a>)<br/></li>
<li>&nbsp; &nbsp; <a href="#L920" title="lgc.c:920">setpause</a>(g);&nbsp; <span class="Comment">/* pause until <a href="llex.c.html#L31" title="llex.c:31">next</a> cycle */<br/></li>
<li></span>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; debt = (debt / g-&gt;gcstepmul) * <a href="#L52" title="lgc.c:52">STEPMULADJ</a>;&nbsp; <span class="Comment">/* convert 'work units' to Kb */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lstate.c.html#L101" title="lstate.c:101">luaE_setdebt</a>(g, debt);<br/></li>
<li>&nbsp; &nbsp; <a href="#L824" title="lgc.c:824">runafewfinalizers</a>(L);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** Performs a full GC cycle; if 'isemergency', set a flag to avoid<br/></li>
<li></span><span class="Comment">** some operations which could change the interpreter state in some<br/></li>
<li></span><span class="Comment">** unexpected ways (running finalizers and shrinking some structures).<br/></li>
<li></span><span class="Comment">** Before running the collection, <a href="lparser.c.html#L106" title="lparser.c:106">check</a> '<a href="lgc.h.html#L61" title="lgc.h:61">keepinvariant</a>'; if it is true,<br/></li>
<li></span><span class="Comment">** there may be some objects marked as black, so the collector has<br/></li>
<li></span><span class="Comment">** to sweep all objects to turn them back to white (as white has not<br/></li>
<li></span><span class="Comment">** changed, nothing will be collected).<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L1139">&#x200c;</a></span><span class="Type">void</span> <span class="linkable">luaC_fullgc</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <span class="Type">int</span> isemergency) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L108" title="lstate.h:108">global_State</a> *g = <a href="lstate.h.html#L175" title="lstate.h:175">G</a>(L);<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(g-&gt;gckind == <a href="lstate.h.html#L45" title="lstate.h:45">KGC_NORMAL</a>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (isemergency) g-&gt;gckind = <a href="lstate.h.html#L46" title="lstate.h:46">KGC_EMERGENCY</a>;&nbsp; <span class="Comment">/* set flag */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="lgc.h.html#L61" title="lgc.h:61">keepinvariant</a>(g)) {&nbsp; <span class="Comment">/* black objects? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L940" title="lgc.c:940">entersweep</a>(L); <span class="Comment">/* sweep everything to turn them back to white */<br/></li>
<li></span>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* finish any pending sweep phase to start a new cycle */<br/></li>
<li></span>&nbsp; <a href="#L1087" title="lgc.c:1087">luaC_runtilstate</a>(L, <a href="lgc.h.html#L70" title="lgc.h:70">bitmask</a>(<a href="lgc.h.html#L46" title="lgc.h:46">GCSpause</a>));<br/></li>
<li>&nbsp; <a href="#L1087" title="lgc.c:1087">luaC_runtilstate</a>(L, ~<a href="lgc.h.html#L70" title="lgc.h:70">bitmask</a>(<a href="lgc.h.html#L46" title="lgc.h:46">GCSpause</a>));&nbsp; <span class="Comment">/* start new collection */<br/></li>
<li></span>&nbsp; <a href="#L1087" title="lgc.c:1087">luaC_runtilstate</a>(L, <a href="lgc.h.html#L70" title="lgc.h:70">bitmask</a>(<a href="lgc.h.html#L45" title="lgc.h:45">GCScallfin</a>));&nbsp; <span class="Comment">/* run up to finalizers */<br/></li>
<li></span>&nbsp; <span class="Comment">/* estimate must be correct after a full GC cycle */<br/></li>
<li></span>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(g-&gt;GCestimate == <a href="lstate.h.html#L213" title="lstate.h:213">gettotalbytes</a>(g));<br/></li>
<li>&nbsp; <a href="#L1087" title="lgc.c:1087">luaC_runtilstate</a>(L, <a href="lgc.h.html#L70" title="lgc.h:70">bitmask</a>(<a href="lgc.h.html#L46" title="lgc.h:46">GCSpause</a>));&nbsp; <span class="Comment">/* finish collection */<br/></li>
<li></span>&nbsp; g-&gt;gckind = <a href="lstate.h.html#L45" title="lstate.h:45">KGC_NORMAL</a>;<br/></li>
<li>&nbsp; <a href="#L920" title="lgc.c:920">setpause</a>(g);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* }====================================================== */<br/></li>
<li></span><br/></li>
<li><br/></li>
</ol></code>
 </body>
</html>
