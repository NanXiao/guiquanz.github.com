<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>lparser.c - src</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

code {
    font-family: consolas, monospace;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
  <h3>lparser.c - src</h3>
   <a href="../index.html"> Table of Contents </a>
 <h4>Global variables defined</h4>
 <ul>
<li><a href="#L1022">priority</a></li>
</ul>
 <h4>Data types defined</h4>
 <ul>
<li><a href="#L48">BlockCnt</a></li>
<li><a href="#L55">BlockCnt</a></li>
<li><a href="#L631">ConsControl</a></li>
<li><a href="#L1101">LHS_assign</a></li>
</ul>
 <h4>Functions defined</h4>
 <ul>
<li><a href="#L494">addprototype</a></li>
<li><a href="#L306">adjust_assign</a></li>
<li><a href="#L201">adjustlocalvars</a></li>
<li><a href="#L1141">assignment</a></li>
<li><a href="#L1087">block</a></li>
<li><a href="#L581">block_follow</a></li>
<li><a href="#L776">body</a></li>
<li><a href="#L449">breaklabel</a></li>
<li><a href="#L106">check</a></li>
<li><a href="#L1113">check_conflict</a></li>
<li><a href="#L122">check_match</a></li>
<li><a href="#L92">checklimit</a></li>
<li><a href="#L156">checkname</a></li>
<li><a href="#L112">checknext</a></li>
<li><a href="#L1200">checkrepeated</a></li>
<li><a href="#L546">close_func</a></li>
<li><a href="#L336">closegoto</a></li>
<li><a href="#L661">closelistfield</a></li>
<li><a href="#L516">codeclosure</a></li>
<li><a href="#L151">codestring</a></li>
<li><a href="#L1174">cond</a></li>
<li><a href="#L718">constructor</a></li>
<li><a href="#L434">enterblock</a></li>
<li><a href="#L326">enterlevel</a></li>
<li><a href="#L73">error_expected</a></li>
<li><a href="#L79">errorlimit</a></li>
<li><a href="#L1277">exp1</a></li>
<li><a href="#L798">explist</a></li>
<li><a href="#L1072">expr</a></li>
<li><a href="#L1485">exprstat</a></li>
<li><a href="#L696">field</a></li>
<li><a href="#L604">fieldsel</a></li>
<li><a href="#L398">findgotos</a></li>
<li><a href="#L360">findlabel</a></li>
<li><a href="#L1288">forbody</a></li>
<li><a href="#L1336">forlist</a></li>
<li><a href="#L1314">fornum</a></li>
<li><a href="#L1361">forstat</a></li>
<li><a href="#L811">funcargs</a></li>
<li><a href="#L1459">funcname</a></li>
<li><a href="#L1473">funcstat</a></li>
<li><a href="#L991">getbinopr</a></li>
<li><a href="#L194">getlocvar</a></li>
<li><a href="#L980">getunopr</a></li>
<li><a href="#L1184">gotostat</a></li>
<li><a href="#L1414">ifstat</a></li>
<li><a href="#L144">init_exp</a></li>
<li><a href="#L1220">labelstat</a></li>
<li><a href="#L672">lastlistfield</a></li>
<li><a href="#L468">leaveblock</a></li>
<li><a href="#L687">listfield</a></li>
<li><a href="#L1428">localfunc</a></li>
<li><a href="#L1439">localstat</a></li>
<li><a href="#L1623">luaY_parser</a></li>
<li><a href="#L1609">mainfunc</a></li>
<li><a href="#L256">markupval</a></li>
<li><a href="#L416">movegotosout</a></li>
<li><a href="#L174">new_localvar</a></li>
<li><a href="#L186">new_localvarliteral_</a></li>
<li><a href="#L380">newlabelentry</a></li>
<li><a href="#L227">newupvalue</a></li>
<li><a href="#L523">open_func</a></li>
<li><a href="#L747">parlist</a></li>
<li><a href="#L865">primaryexp</a></li>
<li><a href="#L640">recfield</a></li>
<li><a href="#L161">registerlocalvar</a></li>
<li><a href="#L210">removevars</a></li>
<li><a href="#L1257">repeatstat</a></li>
<li><a href="#L1501">retstat</a></li>
<li><a href="#L217">searchupvalue</a></li>
<li><a href="#L242">searchvar</a></li>
<li><a href="#L67">semerror</a></li>
<li><a href="#L925">simpleexp</a></li>
<li><a href="#L293">singlevar</a></li>
<li><a href="#L267">singlevaraux</a></li>
<li><a href="#L1214">skipnoopstat</a></li>
<li><a href="#L1534">statement</a></li>
<li><a href="#L592">statlist</a></li>
<li><a href="#L135">str_checkname</a></li>
<li><a href="#L1042">subexpr</a></li>
<li><a href="#L887">suffixedexp</a></li>
<li><a href="#L1379">test_then_block</a></li>
<li><a href="#L97">testnext</a></li>
<li><a href="#L459">undefgoto</a></li>
<li><a href="#L1238">whilestat</a></li>
<li><a href="#L615">yindex</a></li>
</ul>
 <h4>Macros defined</h4>
 <ul>
<li><a href="#L8">LUA_CORE</a></li>
<li><a href="#L34">MAXVARS</a></li>
<li><a href="#L1035">UNARY_PRIORITY</a></li>
<li><a href="#L118">check_condition</a></li>
<li><a href="#L42">eqstr</a></li>
<li><a href="#L37">hasmultret</a></li>
<li><a href="#L333">leavelevel</a></li>
<li><a href="#L7">lparser_c</a></li>
<li><a href="#L190">new_localvarliteral</a></li>
</ul>
 <h4>Source code</h4>

  <code><ol><li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** $Id: lparser.c,v 2.147 2014/12/27 20:31:43 roberto Exp $<br/></li>
<li></span><span class="Comment">** Lua Parser<br/></li>
<li></span><span class="Comment">** See Copyright Notice in lua.h<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><a id="L7">&#x200c;</a><span class="PreProc">#define <span class="linkable">lparser_c</span><br/></li>
<li><a id="L8">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LUA_CORE</span><br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;lprefix.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;lua.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;lcode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;ldebug.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;ldo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lfunc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;<a href="llex.c.html#L467" title="llex.c:467">llex</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lobject.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lopcodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lparser.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lstate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lstring.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;ltable.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* maximum number of local variables per function (must be smaller<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; than 250, due to the bytecode format) */<br/></li>
<li><a id="L34">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAXVARS</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">200<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L37">&#x200c;</a><span class="PreProc">#define <span class="linkable">hasmultret</span>(k)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((k) == VCALL || (k) == VVARARG)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* because all strings are unified by the scanner, the parser<br/></li>
<li></span><span class="Comment">&nbsp;&nbsp; can use pointer equality for string equality */<br/></li>
<li><a id="L42">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">eqstr</span>(a,b)&nbsp; &nbsp; &nbsp; &nbsp; ((a) == (b))<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** nodes for <a href="#L1087" title="lparser.c:1087">block</a> list (list of active blocks)<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L48">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BlockCnt</span> {<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L48" title="lparser.c:48">BlockCnt</a> *previous;&nbsp; <span class="Comment">/* chain */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> firstlabel;&nbsp; <span class="Comment">/* index of first label in this <a href="#L1087" title="lparser.c:1087">block</a> */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> firstgoto;&nbsp; <span class="Comment">/* index of first pending goto in this <a href="#L1087" title="lparser.c:1087">block</a> */<br/></li>
<li></span>&nbsp; <a href="llimits.h.html#L35" title="llimits.h:35">lu_byte</a> nactvar;&nbsp; <span class="Comment">/* # active locals outside the <a href="#L1087" title="lparser.c:1087">block</a> */<br/></li>
<li></span>&nbsp; <a href="llimits.h.html#L35" title="llimits.h:35">lu_byte</a> upval;&nbsp; <span class="Comment">/* true if some variable in the <a href="#L1087" title="lparser.c:1087">block</a> is an upvalue */<br/></li>
<li></span>&nbsp; <a href="llimits.h.html#L35" title="llimits.h:35">lu_byte</a> isloop;&nbsp; <span class="Comment">/* true if '<a href="#L1087" title="lparser.c:1087">block</a>' is a loop */<br/></li>
<li><a id="L55">&#x200c;</a></span>} <span class="linkable">BlockCnt</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** prototypes for recursive non-terminal functions<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1534" title="lparser.c:1534">statement</a> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1072" title="lparser.c:1072">expr</a> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *v);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* semantic <a href="lundump.c.html#L40" title="lundump.c:40">error</a> */<br/></li>
<li><a id="L67">&#x200c;</a></span><span class="Type">static</span> <a href="llimits.h.html#L135" title="llimits.h:135">l_noret</a> <span class="linkable">semerror</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">const</span> <span class="Type">char</span> *msg) {<br/></li>
<li>&nbsp; ls-&gt;t.token = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* remove &quot;near &lt;token&gt;&quot; from final message */<br/></li>
<li></span>&nbsp; <a href="llex.c.html#L118" title="llex.c:118">luaX_syntaxerror</a>(ls, msg);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L73">&#x200c;</a><span class="Type">static</span> <a href="llimits.h.html#L135" title="llimits.h:135">l_noret</a> <span class="linkable">error_expected</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">int</span> token) {<br/></li>
<li>&nbsp; <a href="llex.c.html#L118" title="llex.c:118">luaX_syntaxerror</a>(ls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lobject.c.html#L416" title="lobject.c:416">luaO_pushfstring</a>(ls-&gt;L, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> expected&quot;</span>, <a href="llex.c.html#L81" title="llex.c:81">luaX_token2str</a>(ls, token)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L79">&#x200c;</a><span class="Type">static</span> <a href="llimits.h.html#L135" title="llimits.h:135">l_noret</a> <span class="linkable">errorlimit</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> limit, <span class="Type">const</span> <span class="Type">char</span> *what) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L = fs-&gt;ls-&gt;L;<br/></li>
<li>&nbsp; <span class="Type">const</span> <span class="Type">char</span> *msg;<br/></li>
<li>&nbsp; <span class="Type">int</span> line = fs-&gt;f-&gt;linedefined;<br/></li>
<li>&nbsp; <span class="Type">const</span> <span class="Type">char</span> *where = (line == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? <span class="Constant">&quot;<a href="lua.c.html#L595" title="lua.c:595">main</a> function&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : <a href="lobject.c.html#L416" title="lobject.c:416">luaO_pushfstring</a>(L, <span class="Constant">&quot;function at line </span><span class="Special">%d</span><span class="Constant">&quot;</span>, line);<br/></li>
<li>&nbsp; msg = <a href="lobject.c.html#L416" title="lobject.c:416">luaO_pushfstring</a>(L, <span class="Constant">&quot;too many </span><span class="Special">%s</span><span class="Constant"> (limit is </span><span class="Special">%d</span><span class="Constant">) in </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; what, limit, where);<br/></li>
<li>&nbsp; <a href="llex.c.html#L118" title="llex.c:118">luaX_syntaxerror</a>(fs-&gt;ls, msg);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L92">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">checklimit</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> v, <span class="Type">int</span> l, <span class="Type">const</span> <span class="Type">char</span> *what) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (v &gt; l) <a href="#L79" title="lparser.c:79">errorlimit</a>(fs, l, what);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L97">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">testnext</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">int</span> c) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (ls-&gt;t.token == c) {<br/></li>
<li>&nbsp; &nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">else</span> <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L106">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">check</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">int</span> c) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (ls-&gt;t.token != c)<br/></li>
<li>&nbsp; &nbsp; <a href="#L73" title="lparser.c:73">error_expected</a>(ls, c);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L112">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">checknext</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">int</span> c) {<br/></li>
<li>&nbsp; <a href="#L106" title="lparser.c:106">check</a>(ls, c);<br/></li>
<li>&nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L118">&#x200c;</a><span class="PreProc">#define <span class="linkable">check_condition</span>(ls,c,msg)&nbsp; &nbsp; &nbsp; &nbsp; { </span><span class="Statement">if</span><span class="PreProc"> (!(c)) <a href="llex.c.html#L118" title="llex.c:118">luaX_syntaxerror</a>(ls, msg); }<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L122">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">check_match</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">int</span> what, <span class="Type">int</span> who, <span class="Type">int</span> where) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (!<a href="#L97" title="lparser.c:97">testnext</a>(ls, what)) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (where == ls-&gt;linenumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L73" title="lparser.c:73">error_expected</a>(ls, what);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="llex.c.html#L118" title="llex.c:118">luaX_syntaxerror</a>(ls, <a href="lobject.c.html#L416" title="lobject.c:416">luaO_pushfstring</a>(ls-&gt;L,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> expected (to close </span><span class="Special">%s</span><span class="Constant"> at line </span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="llex.c.html#L81" title="llex.c:81">luaX_token2str</a>(ls, what), <a href="llex.c.html#L81" title="llex.c:81">luaX_token2str</a>(ls, who), where));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L135">&#x200c;</a><span class="Type">static</span> <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *<span class="linkable">str_checkname</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *ts;<br/></li>
<li>&nbsp; <a href="#L106" title="lparser.c:106">check</a>(ls, TK_NAME);<br/></li>
<li>&nbsp; ts = ls-&gt;t.seminfo.ts;<br/></li>
<li>&nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);<br/></li>
<li>&nbsp; <span class="Statement">return</span> ts;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L144">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">init_exp</span> (<a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e, <a href="lparser.h.html#L35" title="lparser.h:35">expkind</a> k, <span class="Type">int</span> i) {<br/></li>
<li>&nbsp; e-&gt;f = e-&gt;t = <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>;<br/></li>
<li>&nbsp; e-&gt;k = k;<br/></li>
<li>&nbsp; e-&gt;u.info = i;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L151">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">codestring</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e, <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *s) {<br/></li>
<li>&nbsp; <a href="#L144" title="lparser.c:144">init_exp</a>(e, VK, <a href="lcode.c.html#L339" title="lcode.c:339">luaK_stringK</a>(ls-&gt;fs, s));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L156">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">checkname</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e) {<br/></li>
<li>&nbsp; <a href="#L151" title="lparser.c:151">codestring</a>(ls, e, <a href="#L135" title="lparser.c:135">str_checkname</a>(ls));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L161">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">registerlocalvar</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *varname) {<br/></li>
<li>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L398" title="lobject.h:398">Proto</a> *f = fs-&gt;f;<br/></li>
<li>&nbsp; <span class="Type">int</span> oldsize = f-&gt;sizelocvars;<br/></li>
<li>&nbsp; <a href="lmem.h.html#L52" title="lmem.h:52">luaM_growvector</a>(ls-&gt;L, f-&gt;locvars, fs-&gt;nlocvars, f-&gt;sizelocvars,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L388" title="lobject.h:388">LocVar</a>, <span class="Constant">SHRT_MAX</span>, <span class="Constant">&quot;local variables&quot;</span>);<br/></li>
<li>&nbsp; <span class="Statement">while</span> (oldsize &lt; f-&gt;sizelocvars) f-&gt;locvars[oldsize++].varname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; f-&gt;locvars[fs-&gt;nlocvars].varname = varname;<br/></li>
<li>&nbsp; <a href="lgc.h.html#L117" title="lgc.h:117">luaC_objbarrier</a>(ls-&gt;L, f, varname);<br/></li>
<li>&nbsp; <span class="Statement">return</span> fs-&gt;nlocvars++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L174">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">new_localvar</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *name) {<br/></li>
<li>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L82" title="lparser.h:82">Dyndata</a> *dyd = ls-&gt;dyd;<br/></li>
<li>&nbsp; <span class="Type">int</span> reg = <a href="#L161" title="lparser.c:161">registerlocalvar</a>(ls, name);<br/></li>
<li>&nbsp; <a href="#L92" title="lparser.c:92">checklimit</a>(fs, dyd-&gt;actvar.n + <span class="Constant">1</span> - fs-&gt;firstlocal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L34" title="lparser.c:34">MAXVARS</a>, <span class="Constant">&quot;local variables&quot;</span>);<br/></li>
<li>&nbsp; <a href="lmem.h.html#L52" title="lmem.h:52">luaM_growvector</a>(ls-&gt;L, dyd-&gt;actvar.arr, dyd-&gt;actvar.n + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dyd-&gt;actvar.size, <a href="lparser.h.html#L59" title="lparser.h:59">Vardesc</a>, <a href="llimits.h.html#L51" title="llimits.h:51">MAX_INT</a>, <span class="Constant">&quot;local variables&quot;</span>);<br/></li>
<li>&nbsp; dyd-&gt;actvar.arr[dyd-&gt;actvar.n++].idx = <a href="llimits.h.html#L107" title="llimits.h:107">cast</a>(<span class="Type">short</span>, reg);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L186">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">new_localvarliteral_</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type">size_t</span> sz) {<br/></li>
<li>&nbsp; <a href="#L174" title="lparser.c:174">new_localvar</a>(ls, <a href="llex.c.html#L128" title="llex.c:128">luaX_newstring</a>(ls, name, sz));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L190">&#x200c;</a><span class="PreProc">#define <span class="linkable">new_localvarliteral</span>(ls,v) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L186" title="lparser.c:186">new_localvarliteral_</a>(ls, </span><span class="Constant">&quot;&quot;</span><span class="PreProc"> v, (</span><span class="Statement">sizeof</span><span class="PreProc">(v)/</span><span class="Statement">sizeof</span><span class="PreProc">(</span><span class="Type">char</span><span class="PreProc">))-</span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L194">&#x200c;</a><span class="Type">static</span> <a href="lobject.h.html#L388" title="lobject.h:388">LocVar</a> *<span class="linkable">getlocvar</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> i) {<br/></li>
<li>&nbsp; <span class="Type">int</span> idx = fs-&gt;ls-&gt;dyd-&gt;actvar.arr[fs-&gt;firstlocal + i].idx;<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(idx &lt; fs-&gt;nlocvars);<br/></li>
<li>&nbsp; <span class="Statement">return</span> &amp;fs-&gt;f-&gt;locvars[idx];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L201">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">adjustlocalvars</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">int</span> nvars) {<br/></li>
<li>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; fs-&gt;nactvar = <a href="llimits.h.html#L110" title="llimits.h:110">cast_byte</a>(fs-&gt;nactvar + nvars);<br/></li>
<li>&nbsp; <span class="Statement">for</span> (; nvars; nvars--) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L194" title="lparser.c:194">getlocvar</a>(fs, fs-&gt;nactvar - nvars)-&gt;startpc = fs-&gt;pc;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L210">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">removevars</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> tolevel) {<br/></li>
<li>&nbsp; fs-&gt;ls-&gt;dyd-&gt;actvar.n -= (fs-&gt;nactvar - tolevel);<br/></li>
<li>&nbsp; <span class="Statement">while</span> (fs-&gt;nactvar &gt; tolevel)<br/></li>
<li>&nbsp; &nbsp; <a href="#L194" title="lparser.c:194">getlocvar</a>(fs, --fs-&gt;nactvar)-&gt;endpc = fs-&gt;pc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L217">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">searchupvalue</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *name) {<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L377" title="lobject.h:377">Upvaldesc</a> *up = fs-&gt;f-&gt;upvalues;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; fs-&gt;nups; i++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L42" title="lparser.c:42">eqstr</a>(up[i].name, name)) <span class="Statement">return</span> i;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;&nbsp; <span class="Comment">/* not found */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L227">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">newupvalue</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *name, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *v) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L398" title="lobject.h:398">Proto</a> *f = fs-&gt;f;<br/></li>
<li>&nbsp; <span class="Type">int</span> oldsize = f-&gt;sizeupvalues;<br/></li>
<li>&nbsp; <a href="#L92" title="lparser.c:92">checklimit</a>(fs, fs-&gt;nups + <span class="Constant">1</span>, <a href="llimits.h.html#L156" title="llimits.h:156">MAXUPVAL</a>, <span class="Constant">&quot;upvalues&quot;</span>);<br/></li>
<li>&nbsp; <a href="lmem.h.html#L52" title="lmem.h:52">luaM_growvector</a>(fs-&gt;ls-&gt;L, f-&gt;upvalues, fs-&gt;nups, f-&gt;sizeupvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L377" title="lobject.h:377">Upvaldesc</a>, <a href="llimits.h.html#L156" title="llimits.h:156">MAXUPVAL</a>, <span class="Constant">&quot;upvalues&quot;</span>);<br/></li>
<li>&nbsp; <span class="Statement">while</span> (oldsize &lt; f-&gt;sizeupvalues) f-&gt;upvalues[oldsize++].name = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; f-&gt;upvalues[fs-&gt;nups].instack = (v-&gt;k == VLOCAL);<br/></li>
<li>&nbsp; f-&gt;upvalues[fs-&gt;nups].idx = <a href="llimits.h.html#L110" title="llimits.h:110">cast_byte</a>(v-&gt;u.info);<br/></li>
<li>&nbsp; f-&gt;upvalues[fs-&gt;nups].name = name;<br/></li>
<li>&nbsp; <a href="lgc.h.html#L117" title="lgc.h:117">luaC_objbarrier</a>(fs-&gt;ls-&gt;L, f, name);<br/></li>
<li>&nbsp; <span class="Statement">return</span> fs-&gt;nups++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L242">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">searchvar</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *n) {<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = <a href="llimits.h.html#L112" title="llimits.h:112">cast_int</a>(fs-&gt;nactvar) - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L42" title="lparser.c:42">eqstr</a>(n, <a href="#L194" title="lparser.c:194">getlocvar</a>(fs, i)-&gt;varname))<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> i;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;&nbsp; <span class="Comment">/* not found */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; Mark <a href="#L1087" title="lparser.c:1087">block</a> where variable at given level was defined<br/></li>
<li></span><span class="Comment">&nbsp; (to emit close instructions later).<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L256">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">markupval</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> level) {<br/></li>
<li>&nbsp; <a href="#L48" title="lparser.c:48">BlockCnt</a> *bl = fs-&gt;bl;<br/></li>
<li>&nbsp; <span class="Statement">while</span> (bl-&gt;nactvar &gt; level) bl = bl-&gt;previous;<br/></li>
<li>&nbsp; bl-&gt;upval = <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; Find variable with given name 'n'. If it is an upvalue, add this<br/></li>
<li></span><span class="Comment">&nbsp; upvalue into all intermediate functions.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L267">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">singlevaraux</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *n, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *var, <span class="Type">int</span> base) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (fs == <span class="Constant">NULL</span>)&nbsp; <span class="Comment">/* no more levels? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> VVOID;&nbsp; <span class="Comment">/* default is global */<br/></li>
<li></span>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> v = <a href="#L242" title="lparser.c:242">searchvar</a>(fs, n);&nbsp; <span class="Comment">/* look up locals at current level */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (v &gt;= <span class="Constant">0</span>) {&nbsp; <span class="Comment">/* found? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L144" title="lparser.c:144">init_exp</a>(var, VLOCAL, v);&nbsp; <span class="Comment">/* variable is local */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!base)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L256" title="lparser.c:256">markupval</a>(fs, v);&nbsp; <span class="Comment">/* local will be used as an upval */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> VLOCAL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> {&nbsp; <span class="Comment">/* not found as local at current level; try upvalues */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Type">int</span> idx = <a href="#L217" title="lparser.c:217">searchupvalue</a>(fs, n);&nbsp; <span class="Comment">/* try existing upvalues */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (idx &lt; <span class="Constant">0</span>) {&nbsp; <span class="Comment">/* not found? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L267" title="lparser.c:267">singlevaraux</a>(fs-&gt;prev, n, var, <span class="Constant">0</span>) == VVOID) <span class="Comment">/* try upper levels */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> VVOID;&nbsp; <span class="Comment">/* not found; is a global */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else was LOCAL or UPVAL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; idx&nbsp; = <a href="#L227" title="lparser.c:227">newupvalue</a>(fs, n, var);&nbsp; <span class="Comment">/* will be a new upvalue */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L144" title="lparser.c:144">init_exp</a>(var, VUPVAL, idx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> VUPVAL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L293">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">singlevar</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *var) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *varname = <a href="#L135" title="lparser.c:135">str_checkname</a>(ls);<br/></li>
<li>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L267" title="lparser.c:267">singlevaraux</a>(fs, varname, var, <span class="Constant">1</span>) == VVOID) {&nbsp; <span class="Comment">/* global name? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> key;<br/></li>
<li>&nbsp; &nbsp; <a href="#L267" title="lparser.c:267">singlevaraux</a>(fs, ls-&gt;envn, var, <span class="Constant">1</span>);&nbsp; <span class="Comment">/* get environment variable */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(var-&gt;k == VLOCAL || var-&gt;k == VUPVAL);<br/></li>
<li>&nbsp; &nbsp; <a href="#L151" title="lparser.c:151">codestring</a>(ls, &amp;key, varname);&nbsp; <span class="Comment">/* key is variable name */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lcode.c.html#L736" title="lcode.c:736">luaK_indexed</a>(fs, var, &amp;key);&nbsp; <span class="Comment">/* env[varname] */<br/></li>
<li></span>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L306">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">adjust_assign</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">int</span> nvars, <span class="Type">int</span> nexps, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e) {<br/></li>
<li>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <span class="Type">int</span> extra = nvars - nexps;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L37" title="lparser.c:37">hasmultret</a>(e-&gt;k)) {<br/></li>
<li>&nbsp; &nbsp; extra++;&nbsp; <span class="Comment">/* includes call itself */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (extra &lt; <span class="Constant">0</span>) extra = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="lcode.c.html#L382" title="lcode.c:382">luaK_setreturns</a>(fs, e, extra);&nbsp; <span class="Comment">/* last exp. provides the difference */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (extra &gt; <span class="Constant">1</span>) <a href="lcode.c.html#L288" title="lcode.c:288">luaK_reserveregs</a>(fs, extra-<span class="Constant">1</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (e-&gt;k != VVOID) <a href="lcode.c.html#L519" title="lcode.c:519">luaK_exp2nextreg</a>(fs, e);&nbsp; <span class="Comment">/* close last expression */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (extra &gt; <span class="Constant">0</span>) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">int</span> reg = fs-&gt;<a href="lcode.c.html#L294" title="lcode.c:294">freereg</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lcode.c.html#L288" title="lcode.c:288">luaK_reserveregs</a>(fs, extra);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lcode.c.html#L54" title="lcode.c:54">luaK_nil</a>(fs, reg, extra);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L326">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">enterlevel</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L = ls-&gt;L;<br/></li>
<li>&nbsp; ++L-&gt;nCcalls;<br/></li>
<li>&nbsp; <a href="#L92" title="lparser.c:92">checklimit</a>(ls-&gt;fs, L-&gt;nCcalls, <a href="llimits.h.html#L149" title="llimits.h:149">LUAI_MAXCCALLS</a>, <span class="Constant">&quot;C levels&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L333">&#x200c;</a><span class="PreProc">#define <span class="linkable">leavelevel</span>(ls)&nbsp; &nbsp; &nbsp; &nbsp; ((ls)-&gt;L-&gt;nCcalls--)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L336">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">closegoto</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">int</span> g, <a href="lparser.h.html#L65" title="lparser.h:65">Labeldesc</a> *label) {<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L74" title="lparser.h:74">Labellist</a> *gl = &amp;ls-&gt;dyd-&gt;gt;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L65" title="lparser.h:65">Labeldesc</a> *gt = &amp;gl-&gt;arr[g];<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<a href="#L42" title="lparser.c:42">eqstr</a>(gt-&gt;name, label-&gt;name));<br/></li>
<li>&nbsp; <span class="Statement">if</span> (gt-&gt;nactvar &lt; label-&gt;nactvar) {<br/></li>
<li>&nbsp; &nbsp; <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *vname = <a href="#L194" title="lparser.c:194">getlocvar</a>(fs, gt-&gt;nactvar)-&gt;varname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *msg = <a href="lobject.c.html#L416" title="lobject.c:416">luaO_pushfstring</a>(ls-&gt;L,<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Constant">&quot;&lt;goto </span><span class="Special">%s</span><span class="Constant">&gt; at line </span><span class="Special">%d</span><span class="Constant"> jumps into the scope of local '</span><span class="Special">%s</span><span class="Constant">'&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L326" title="lobject.h:326">getstr</a>(gt-&gt;name), gt-&gt;line, <a href="lobject.h.html#L326" title="lobject.h:326">getstr</a>(vname));<br/></li>
<li>&nbsp; &nbsp; <a href="#L67" title="lparser.c:67">semerror</a>(ls, msg);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="lcode.c.html#L186" title="lcode.c:186">luaK_patchlist</a>(fs, gt-&gt;pc, label-&gt;pc);<br/></li>
<li>&nbsp; <span class="Comment">/* remove goto from pending list */<br/></li>
<li></span>&nbsp; <span class="Statement">for</span> (i = g; i &lt; gl-&gt;n - <span class="Constant">1</span>; i++)<br/></li>
<li>&nbsp; &nbsp; gl-&gt;arr[i] = gl-&gt;arr[i + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; gl-&gt;n--;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** try to close a goto with existing labels; this solves backward jumps<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L360">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">findlabel</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">int</span> g) {<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <a href="#L48" title="lparser.c:48">BlockCnt</a> *bl = ls-&gt;fs-&gt;bl;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L82" title="lparser.h:82">Dyndata</a> *dyd = ls-&gt;dyd;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L65" title="lparser.h:65">Labeldesc</a> *gt = &amp;dyd-&gt;gt.arr[g];<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L106" title="lparser.c:106">check</a> labels in current <a href="#L1087" title="lparser.c:1087">block</a> for a <a href="lstrlib.c.html#L420" title="lstrlib.c:420">match</a> */<br/></li>
<li></span>&nbsp; <span class="Statement">for</span> (i = bl-&gt;firstlabel; i &lt; dyd-&gt;label.n; i++) {<br/></li>
<li>&nbsp; &nbsp; <a href="lparser.h.html#L65" title="lparser.h:65">Labeldesc</a> *lb = &amp;dyd-&gt;label.arr[i];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L42" title="lparser.c:42">eqstr</a>(lb-&gt;name, gt-&gt;name)) {&nbsp; <span class="Comment">/* correct label? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (gt-&gt;nactvar &gt; lb-&gt;nactvar &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (bl-&gt;upval || dyd-&gt;label.n &gt; bl-&gt;firstlabel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lcode.c.html#L196" title="lcode.c:196">luaK_patchclose</a>(ls-&gt;fs, gt-&gt;pc, lb-&gt;nactvar);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L336" title="lparser.c:336">closegoto</a>(ls, g, lb);&nbsp; <span class="Comment">/* close it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; <span class="Comment">/* label not found; <a href="luac.c.html#L44" title="luac.c:44">cannot</a> close goto */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L380">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">newlabelentry</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L74" title="lparser.h:74">Labellist</a> *l, <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> line, <span class="Type">int</span> pc) {<br/></li>
<li>&nbsp; <span class="Type">int</span> n = l-&gt;n;<br/></li>
<li>&nbsp; <a href="lmem.h.html#L52" title="lmem.h:52">luaM_growvector</a>(ls-&gt;L, l-&gt;arr, n, l-&gt;size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lparser.h.html#L65" title="lparser.h:65">Labeldesc</a>, <span class="Constant">SHRT_MAX</span>, <span class="Constant">&quot;labels/gotos&quot;</span>);<br/></li>
<li>&nbsp; l-&gt;arr[n].name = name;<br/></li>
<li>&nbsp; l-&gt;arr[n].line = line;<br/></li>
<li>&nbsp; l-&gt;arr[n].nactvar = ls-&gt;fs-&gt;nactvar;<br/></li>
<li>&nbsp; l-&gt;arr[n].pc = pc;<br/></li>
<li>&nbsp; l-&gt;n = n + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="Statement">return</span> n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** <a href="#L106" title="lparser.c:106">check</a> whether new label 'lb' matches any pending gotos in current<br/></li>
<li></span><span class="Comment">** <a href="#L1087" title="lparser.c:1087">block</a>; solves forward jumps<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L398">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">findgotos</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L65" title="lparser.h:65">Labeldesc</a> *lb) {<br/></li>
<li>&nbsp; <a href="lparser.h.html#L74" title="lparser.h:74">Labellist</a> *gl = &amp;ls-&gt;dyd-&gt;gt;<br/></li>
<li>&nbsp; <span class="Type">int</span> i = ls-&gt;fs-&gt;bl-&gt;firstgoto;<br/></li>
<li>&nbsp; <span class="Statement">while</span> (i &lt; gl-&gt;n) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L42" title="lparser.c:42">eqstr</a>(gl-&gt;arr[i].name, lb-&gt;name))<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L336" title="lparser.c:336">closegoto</a>(ls, i, lb);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** export pending gotos to outer level, to <a href="#L106" title="lparser.c:106">check</a> them against<br/></li>
<li></span><span class="Comment">** outer labels; if the <a href="#L1087" title="lparser.c:1087">block</a> being exited has upvalues, and<br/></li>
<li></span><span class="Comment">** the goto exits the scope of any variable (which can be the<br/></li>
<li></span><span class="Comment">** upvalue), close those variables being exited.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L416">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">movegotosout</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="#L48" title="lparser.c:48">BlockCnt</a> *bl) {<br/></li>
<li>&nbsp; <span class="Type">int</span> i = bl-&gt;firstgoto;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L74" title="lparser.h:74">Labellist</a> *gl = &amp;fs-&gt;ls-&gt;dyd-&gt;gt;<br/></li>
<li>&nbsp; <span class="Comment">/* correct pending gotos to current <a href="#L1087" title="lparser.c:1087">block</a> and try to close it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; with visible labels */<br/></li>
<li></span>&nbsp; <span class="Statement">while</span> (i &lt; gl-&gt;n) {<br/></li>
<li>&nbsp; &nbsp; <a href="lparser.h.html#L65" title="lparser.h:65">Labeldesc</a> *gt = &amp;gl-&gt;arr[i];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (gt-&gt;nactvar &gt; bl-&gt;nactvar) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bl-&gt;upval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lcode.c.html#L196" title="lcode.c:196">luaK_patchclose</a>(fs, gt-&gt;pc, bl-&gt;nactvar);<br/></li>
<li>&nbsp; &nbsp; &nbsp; gt-&gt;nactvar = bl-&gt;nactvar;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L360" title="lparser.c:360">findlabel</a>(fs-&gt;ls, i))<br/></li>
<li>&nbsp; &nbsp; &nbsp; i++;&nbsp; <span class="Comment">/* move to <a href="llex.c.html#L31" title="llex.c:31">next</a> one */<br/></li>
<li></span>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L434">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">enterblock</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="#L48" title="lparser.c:48">BlockCnt</a> *bl, <a href="llimits.h.html#L35" title="llimits.h:35">lu_byte</a> isloop) {<br/></li>
<li>&nbsp; bl-&gt;isloop = isloop;<br/></li>
<li>&nbsp; bl-&gt;nactvar = fs-&gt;nactvar;<br/></li>
<li>&nbsp; bl-&gt;firstlabel = fs-&gt;ls-&gt;dyd-&gt;label.n;<br/></li>
<li>&nbsp; bl-&gt;firstgoto = fs-&gt;ls-&gt;dyd-&gt;gt.n;<br/></li>
<li>&nbsp; bl-&gt;upval = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; bl-&gt;previous = fs-&gt;bl;<br/></li>
<li>&nbsp; fs-&gt;bl = bl;<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(fs-&gt;<a href="lcode.c.html#L294" title="lcode.c:294">freereg</a> == fs-&gt;nactvar);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** create a label named 'break' to resolve break statements<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L449">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">breaklabel</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *n = <a href="lstring.c.html#L165" title="lstring.c:165">luaS_new</a>(ls-&gt;L, <span class="Constant">&quot;break&quot;</span>);<br/></li>
<li>&nbsp; <span class="Type">int</span> l = <a href="#L380" title="lparser.c:380">newlabelentry</a>(ls, &amp;ls-&gt;dyd-&gt;label, n, <span class="Constant">0</span>, ls-&gt;fs-&gt;pc);<br/></li>
<li>&nbsp; <a href="#L398" title="lparser.c:398">findgotos</a>(ls, &amp;ls-&gt;dyd-&gt;label.arr[l]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** generates an <a href="lundump.c.html#L40" title="lundump.c:40">error</a> for an undefined 'goto'; choose appropriate<br/></li>
<li></span><span class="Comment">** message when label name is a reserved word (which can only be 'break')<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L459">&#x200c;</a></span><span class="Type">static</span> <a href="llimits.h.html#L135" title="llimits.h:135">l_noret</a> <span class="linkable">undefgoto</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L65" title="lparser.h:65">Labeldesc</a> *gt) {<br/></li>
<li>&nbsp; <span class="Type">const</span> <span class="Type">char</span> *msg = <a href="lstring.h.html#L28" title="lstring.h:28">isreserved</a>(gt-&gt;name)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? <span class="Constant">&quot;&lt;</span><span class="Special">%s</span><span class="Constant">&gt; at line </span><span class="Special">%d</span><span class="Constant"> not inside a loop&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : <span class="Constant">&quot;no visible label '</span><span class="Special">%s</span><span class="Constant">' for &lt;goto&gt; at line </span><span class="Special">%d</span><span class="Constant">&quot;</span>;<br/></li>
<li>&nbsp; msg = <a href="lobject.c.html#L416" title="lobject.c:416">luaO_pushfstring</a>(ls-&gt;L, msg, <a href="lobject.h.html#L326" title="lobject.h:326">getstr</a>(gt-&gt;name), gt-&gt;line);<br/></li>
<li>&nbsp; <a href="#L67" title="lparser.c:67">semerror</a>(ls, msg);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L468">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">leaveblock</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs) {<br/></li>
<li>&nbsp; <a href="#L48" title="lparser.c:48">BlockCnt</a> *bl = fs-&gt;bl;<br/></li>
<li>&nbsp; <a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls = fs-&gt;ls;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (bl-&gt;previous &amp;&amp; bl-&gt;upval) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* create a 'jump to here' to close upvalues */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span> j = <a href="lcode.c.html#L76" title="lcode.c:76">luaK_jump</a>(fs);<br/></li>
<li>&nbsp; &nbsp; <a href="lcode.c.html#L196" title="lcode.c:196">luaK_patchclose</a>(fs, j, bl-&gt;nactvar);<br/></li>
<li>&nbsp; &nbsp; <a href="lcode.c.html#L209" title="lcode.c:209">luaK_patchtohere</a>(fs, j);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">if</span> (bl-&gt;isloop)<br/></li>
<li>&nbsp; &nbsp; <a href="#L449" title="lparser.c:449">breaklabel</a>(ls);&nbsp; <span class="Comment">/* close pending breaks */<br/></li>
<li></span>&nbsp; fs-&gt;bl = bl-&gt;previous;<br/></li>
<li>&nbsp; <a href="#L210" title="lparser.c:210">removevars</a>(fs, bl-&gt;nactvar);<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(bl-&gt;nactvar == fs-&gt;nactvar);<br/></li>
<li>&nbsp; fs-&gt;<a href="lcode.c.html#L294" title="lcode.c:294">freereg</a> = fs-&gt;nactvar;&nbsp; <span class="Comment">/* free registers */<br/></li>
<li></span>&nbsp; ls-&gt;dyd-&gt;label.n = bl-&gt;firstlabel;&nbsp; <span class="Comment">/* remove local labels */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (bl-&gt;previous)&nbsp; <span class="Comment">/* inner <a href="#L1087" title="lparser.c:1087">block</a>? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L416" title="lparser.c:416">movegotosout</a>(fs, bl);&nbsp; <span class="Comment">/* update pending gotos to outer <a href="#L1087" title="lparser.c:1087">block</a> */<br/></li>
<li></span>&nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (bl-&gt;firstgoto &lt; ls-&gt;dyd-&gt;gt.n)&nbsp; <span class="Comment">/* pending gotos in outer <a href="#L1087" title="lparser.c:1087">block</a>? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L459" title="lparser.c:459">undefgoto</a>(ls, &amp;ls-&gt;dyd-&gt;gt.arr[bl-&gt;firstgoto]);&nbsp; <span class="Comment">/* <a href="lundump.c.html#L40" title="lundump.c:40">error</a> */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** adds a new prototype into list of prototypes<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L494">&#x200c;</a></span><span class="Type">static</span> <a href="lobject.h.html#L398" title="lobject.h:398">Proto</a> *<span class="linkable">addprototype</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L398" title="lobject.h:398">Proto</a> *clp;<br/></li>
<li>&nbsp; <a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L = ls-&gt;L;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L398" title="lobject.h:398">Proto</a> *f = fs-&gt;f;&nbsp; <span class="Comment">/* prototype of current function */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (fs-&gt;np &gt;= f-&gt;sizep) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> oldsize = f-&gt;sizep;<br/></li>
<li>&nbsp; &nbsp; <a href="lmem.h.html#L52" title="lmem.h:52">luaM_growvector</a>(L, f-&gt;p, fs-&gt;np, f-&gt;sizep, <a href="lobject.h.html#L398" title="lobject.h:398">Proto</a> *, <a href="lopcodes.h.html#L60" title="lopcodes.h:60">MAXARG_Bx</a>, <span class="Constant">&quot;functions&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (oldsize &lt; f-&gt;sizep) f-&gt;p[oldsize++] = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; f-&gt;p[fs-&gt;np++] = clp = <a href="lfunc.c.html#L99" title="lfunc.c:99">luaF_newproto</a>(L);<br/></li>
<li>&nbsp; <a href="lgc.h.html#L117" title="lgc.h:117">luaC_objbarrier</a>(L, f, clp);<br/></li>
<li>&nbsp; <span class="Statement">return</span> clp;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** codes instruction to create new closure in parent function.<br/></li>
<li></span><span class="Comment">** The OP_CLOSURE instruction must use the last available register,<br/></li>
<li></span><span class="Comment">** so that, if it invokes the GC, the GC knows which registers<br/></li>
<li></span><span class="Comment">** are in use at that time.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L516">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">codeclosure</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *v) {<br/></li>
<li>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs-&gt;prev;<br/></li>
<li>&nbsp; <a href="#L144" title="lparser.c:144">init_exp</a>(v, VRELOCABLE, <a href="lcode.c.html#L253" title="lcode.c:253">luaK_codeABx</a>(fs, OP_CLOSURE, <span class="Constant">0</span>, fs-&gt;np - <span class="Constant">1</span>));<br/></li>
<li>&nbsp; <a href="lcode.c.html#L519" title="lcode.c:519">luaK_exp2nextreg</a>(fs, v);&nbsp; <span class="Comment">/* fix it at the last register */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L523">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">open_func</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="#L48" title="lparser.c:48">BlockCnt</a> *bl) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L398" title="lobject.h:398">Proto</a> *f;<br/></li>
<li>&nbsp; fs-&gt;prev = ls-&gt;fs;&nbsp; <span class="Comment">/* linked list of funcstates */<br/></li>
<li></span>&nbsp; fs-&gt;ls = ls;<br/></li>
<li>&nbsp; ls-&gt;fs = fs;<br/></li>
<li>&nbsp; fs-&gt;pc = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; fs-&gt;lasttarget = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; fs-&gt;jpc = <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>;<br/></li>
<li>&nbsp; fs-&gt;<a href="lcode.c.html#L294" title="lcode.c:294">freereg</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; fs-&gt;nk = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; fs-&gt;np = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; fs-&gt;nups = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; fs-&gt;nlocvars = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; fs-&gt;nactvar = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; fs-&gt;firstlocal = ls-&gt;dyd-&gt;actvar.n;<br/></li>
<li>&nbsp; fs-&gt;bl = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; f = fs-&gt;f;<br/></li>
<li>&nbsp; f-&gt;source = ls-&gt;source;<br/></li>
<li>&nbsp; f-&gt;maxstacksize = <span class="Constant">2</span>;&nbsp; <span class="Comment">/* registers 0/1 are always valid */<br/></li>
<li></span>&nbsp; <a href="#L434" title="lparser.c:434">enterblock</a>(fs, bl, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L546">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">close_func</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L = ls-&gt;L;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L398" title="lobject.h:398">Proto</a> *f = fs-&gt;f;<br/></li>
<li>&nbsp; <a href="lcode.c.html#L86" title="lcode.c:86">luaK_ret</a>(fs, <span class="Constant">0</span>, <span class="Constant">0</span>);&nbsp; <span class="Comment">/* final return */<br/></li>
<li></span>&nbsp; <a href="#L468" title="lparser.c:468">leaveblock</a>(fs);<br/></li>
<li>&nbsp; <a href="lmem.h.html#L56" title="lmem.h:56">luaM_reallocvector</a>(L, f-&gt;code, f-&gt;sizecode, fs-&gt;pc, <a href="llimits.h.html#L164" title="llimits.h:164">Instruction</a>);<br/></li>
<li>&nbsp; f-&gt;sizecode = fs-&gt;pc;<br/></li>
<li>&nbsp; <a href="lmem.h.html#L56" title="lmem.h:56">luaM_reallocvector</a>(L, f-&gt;lineinfo, f-&gt;sizelineinfo, fs-&gt;pc, <span class="Type">int</span>);<br/></li>
<li>&nbsp; f-&gt;sizelineinfo = fs-&gt;pc;<br/></li>
<li>&nbsp; <a href="lmem.h.html#L56" title="lmem.h:56">luaM_reallocvector</a>(L, f-&gt;k, f-&gt;sizek, fs-&gt;nk, <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a>);<br/></li>
<li>&nbsp; f-&gt;sizek = fs-&gt;nk;<br/></li>
<li>&nbsp; <a href="lmem.h.html#L56" title="lmem.h:56">luaM_reallocvector</a>(L, f-&gt;p, f-&gt;sizep, fs-&gt;np, <a href="lobject.h.html#L398" title="lobject.h:398">Proto</a> *);<br/></li>
<li>&nbsp; f-&gt;sizep = fs-&gt;np;<br/></li>
<li>&nbsp; <a href="lmem.h.html#L56" title="lmem.h:56">luaM_reallocvector</a>(L, f-&gt;locvars, f-&gt;sizelocvars, fs-&gt;nlocvars, <a href="lobject.h.html#L388" title="lobject.h:388">LocVar</a>);<br/></li>
<li>&nbsp; f-&gt;sizelocvars = fs-&gt;nlocvars;<br/></li>
<li>&nbsp; <a href="lmem.h.html#L56" title="lmem.h:56">luaM_reallocvector</a>(L, f-&gt;upvalues, f-&gt;sizeupvalues, fs-&gt;nups, <a href="lobject.h.html#L377" title="lobject.h:377">Upvaldesc</a>);<br/></li>
<li>&nbsp; f-&gt;sizeupvalues = fs-&gt;nups;<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(fs-&gt;bl == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; ls-&gt;fs = fs-&gt;prev;<br/></li>
<li>&nbsp; <a href="lgc.h.html#L106" title="lgc.h:106">luaC_checkGC</a>(L);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*============================================================*/<br/></li>
<li></span><span class="Comment">/* GRAMMAR RULES */<br/></li>
<li></span><span class="Comment">/*============================================================*/<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** <a href="#L106" title="lparser.c:106">check</a> whether current token is in the follow set of a <a href="#L1087" title="lparser.c:1087">block</a>.<br/></li>
<li></span><span class="Comment">** 'until' closes syntactical blocks, but do not close scope,<br/></li>
<li></span><span class="Comment">** so it is handled in separate.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L581">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">block_follow</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">int</span> withuntil) {<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (ls-&gt;t.token) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_ELSE: <span class="Statement">case</span> TK_ELSEIF:<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_END: <span class="Statement">case</span> TK_EOS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_UNTIL: <span class="Statement">return</span> withuntil;<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L592">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">statlist</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L592" title="lparser.c:592">statlist</a> -&gt; { stat [';'] } */<br/></li>
<li></span>&nbsp; <span class="Statement">while</span> (!<a href="#L581" title="lparser.c:581">block_follow</a>(ls, <span class="Constant">1</span>)) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ls-&gt;t.token == TK_RETURN) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L1534" title="lparser.c:1534">statement</a>(ls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; <span class="Comment">/* 'return' must be last <a href="#L1534" title="lparser.c:1534">statement</a> */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L1534" title="lparser.c:1534">statement</a>(ls);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L604">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">fieldsel</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *v) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L604" title="lparser.c:604">fieldsel</a> -&gt; ['.' | ':'] NAME */<br/></li>
<li></span>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> key;<br/></li>
<li>&nbsp; <a href="lcode.c.html#L541" title="lcode.c:541">luaK_exp2anyregup</a>(fs, v);<br/></li>
<li>&nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);&nbsp; <span class="Comment">/* skip the dot or colon */<br/></li>
<li></span>&nbsp; <a href="#L156" title="lparser.c:156">checkname</a>(ls, &amp;key);<br/></li>
<li>&nbsp; <a href="lcode.c.html#L736" title="lcode.c:736">luaK_indexed</a>(fs, v, &amp;key);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L615">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">yindex</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *v) {<br/></li>
<li>&nbsp; <span class="Comment">/* index -&gt; '[' <a href="#L1072" title="lparser.c:1072">expr</a> ']' */<br/></li>
<li></span>&nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);&nbsp; <span class="Comment">/* skip the '[' */<br/></li>
<li></span>&nbsp; <a href="#L1072" title="lparser.c:1072">expr</a>(ls, v);<br/></li>
<li>&nbsp; <a href="lcode.c.html#L547" title="lcode.c:547">luaK_exp2val</a>(ls-&gt;fs, v);<br/></li>
<li>&nbsp; <a href="#L112" title="lparser.c:112">checknext</a>(ls, <span class="Constant">']'</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** {======================================================================<br/></li>
<li></span><span class="Comment">** Rules for Constructors<br/></li>
<li></span><span class="Comment">** =======================================================================<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L631">&#x200c;</a><span class="Type">struct</span> <span class="linkable">ConsControl</span> {<br/></li>
<li>&nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> v;&nbsp; <span class="Comment">/* last list item read */<br/></li>
<li></span>&nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *t;&nbsp; <span class="Comment">/* table descriptor */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> nh;&nbsp; <span class="Comment">/* total number of 'record' elements */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> na;&nbsp; <span class="Comment">/* total number of array elements */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> tostore;&nbsp; <span class="Comment">/* number of array elements pending to be stored */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L640">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">recfield</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">struct</span> <a href="#L631" title="lparser.c:631">ConsControl</a> *cc) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L640" title="lparser.c:640">recfield</a> -&gt; (NAME | '['<a href="#L1277" title="lparser.c:1277">exp1</a>']') = <a href="#L1277" title="lparser.c:1277">exp1</a> */<br/></li>
<li></span>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <span class="Type">int</span> reg = ls-&gt;fs-&gt;<a href="lcode.c.html#L294" title="lcode.c:294">freereg</a>;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> key, val;<br/></li>
<li>&nbsp; <span class="Type">int</span> rkkey;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (ls-&gt;t.token == TK_NAME) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L92" title="lparser.c:92">checklimit</a>(fs, cc-&gt;nh, <a href="llimits.h.html#L51" title="llimits.h:51">MAX_INT</a>, <span class="Constant">&quot;items in a <a href="#L718" title="lparser.c:718">constructor</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L156" title="lparser.c:156">checkname</a>(ls, &amp;key);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">else</span>&nbsp; <span class="Comment">/* ls-&gt;t.token == '[' */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L615" title="lparser.c:615">yindex</a>(ls, &amp;key);<br/></li>
<li>&nbsp; cc-&gt;nh++;<br/></li>
<li>&nbsp; <a href="#L112" title="lparser.c:112">checknext</a>(ls, <span class="Constant">'='</span>);<br/></li>
<li>&nbsp; rkkey = <a href="lcode.c.html#L555" title="lcode.c:555">luaK_exp2RK</a>(fs, &amp;key);<br/></li>
<li>&nbsp; <a href="#L1072" title="lparser.c:1072">expr</a>(ls, &amp;val);<br/></li>
<li>&nbsp; <a href="lcode.c.html#L244" title="lcode.c:244">luaK_codeABC</a>(fs, OP_SETTABLE, cc-&gt;t-&gt;u.info, rkkey, <a href="lcode.c.html#L555" title="lcode.c:555">luaK_exp2RK</a>(fs, &amp;val));<br/></li>
<li>&nbsp; fs-&gt;<a href="lcode.c.html#L294" title="lcode.c:294">freereg</a> = reg;&nbsp; <span class="Comment">/* free registers */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L661">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">closelistfield</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">struct</span> <a href="#L631" title="lparser.c:631">ConsControl</a> *cc) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (cc-&gt;v.k == VVOID) <span class="Statement">return</span>;&nbsp; <span class="Comment">/* there is no list item */<br/></li>
<li></span>&nbsp; <a href="lcode.c.html#L519" title="lcode.c:519">luaK_exp2nextreg</a>(fs, &amp;cc-&gt;v);<br/></li>
<li>&nbsp; cc-&gt;v.k = VVOID;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (cc-&gt;tostore == <a href="lopcodes.h.html#L292" title="lopcodes.h:292">LFIELDS_PER_FLUSH</a>) {<br/></li>
<li>&nbsp; &nbsp; <a href="lcode.c.html#L940" title="lcode.c:940">luaK_setlist</a>(fs, cc-&gt;t-&gt;u.info, cc-&gt;na, cc-&gt;tostore);&nbsp; <span class="Comment">/* flush */<br/></li>
<li></span>&nbsp; &nbsp; cc-&gt;tostore = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* no more items pending */<br/></li>
<li></span>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L672">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">lastlistfield</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">struct</span> <a href="#L631" title="lparser.c:631">ConsControl</a> *cc) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (cc-&gt;tostore == <span class="Constant">0</span>) <span class="Statement">return</span>;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L37" title="lparser.c:37">hasmultret</a>(cc-&gt;v.k)) {<br/></li>
<li>&nbsp; &nbsp; <a href="lcode.h.html#L47" title="lcode.h:47">luaK_setmultret</a>(fs, &amp;cc-&gt;v);<br/></li>
<li>&nbsp; &nbsp; <a href="lcode.c.html#L940" title="lcode.c:940">luaK_setlist</a>(fs, cc-&gt;t-&gt;u.info, cc-&gt;na, <a href="lua.h.html#L34" title="lua.h:34">LUA_MULTRET</a>);<br/></li>
<li>&nbsp; &nbsp; cc-&gt;na--;&nbsp; <span class="Comment">/* do not count last expression (unknown number of elements) */<br/></li>
<li></span>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cc-&gt;v.k != VVOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lcode.c.html#L519" title="lcode.c:519">luaK_exp2nextreg</a>(fs, &amp;cc-&gt;v);<br/></li>
<li>&nbsp; &nbsp; <a href="lcode.c.html#L940" title="lcode.c:940">luaK_setlist</a>(fs, cc-&gt;t-&gt;u.info, cc-&gt;na, cc-&gt;tostore);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L687">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">listfield</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">struct</span> <a href="#L631" title="lparser.c:631">ConsControl</a> *cc) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L687" title="lparser.c:687">listfield</a> -&gt; exp */<br/></li>
<li></span>&nbsp; <a href="#L1072" title="lparser.c:1072">expr</a>(ls, &amp;cc-&gt;v);<br/></li>
<li>&nbsp; <a href="#L92" title="lparser.c:92">checklimit</a>(ls-&gt;fs, cc-&gt;na, <a href="llimits.h.html#L51" title="llimits.h:51">MAX_INT</a>, <span class="Constant">&quot;items in a <a href="#L718" title="lparser.c:718">constructor</a>&quot;</span>);<br/></li>
<li>&nbsp; cc-&gt;na++;<br/></li>
<li>&nbsp; cc-&gt;tostore++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L696">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">field</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">struct</span> <a href="#L631" title="lparser.c:631">ConsControl</a> *cc) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L696" title="lparser.c:696">field</a> -&gt; <a href="#L687" title="lparser.c:687">listfield</a> | <a href="#L640" title="lparser.c:640">recfield</a> */<br/></li>
<li></span>&nbsp; <span class="Statement">switch</span>(ls-&gt;t.token) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_NAME: {&nbsp; <span class="Comment">/* may be '<a href="#L687" title="lparser.c:687">listfield</a>' or '<a href="#L640" title="lparser.c:640">recfield</a>' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="llex.c.html#L597" title="llex.c:597">luaX_lookahead</a>(ls) != <span class="Constant">'='</span>)&nbsp; <span class="Comment">/* expression? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L687" title="lparser.c:687">listfield</a>(ls, cc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L640" title="lparser.c:640">recfield</a>(ls, cc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'['</span>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L640" title="lparser.c:640">recfield</a>(ls, cc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L687" title="lparser.c:687">listfield</a>(ls, cc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L718">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">constructor</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *t) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L718" title="lparser.c:718">constructor</a> -&gt; '{' [ <a href="#L696" title="lparser.c:696">field</a> { sep <a href="#L696" title="lparser.c:696">field</a> } [sep] ] '}'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; sep -&gt; ',' | ';' */<br/></li>
<li></span>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <span class="Type">int</span> line = ls-&gt;linenumber;<br/></li>
<li>&nbsp; <span class="Type">int</span> pc = <a href="lcode.c.html#L244" title="lcode.c:244">luaK_codeABC</a>(fs, OP_NEWTABLE, <span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L631" title="lparser.c:631">ConsControl</a> cc;<br/></li>
<li>&nbsp; cc.na = cc.nh = cc.tostore = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; cc.t = t;<br/></li>
<li>&nbsp; <a href="#L144" title="lparser.c:144">init_exp</a>(t, VRELOCABLE, pc);<br/></li>
<li>&nbsp; <a href="#L144" title="lparser.c:144">init_exp</a>(&amp;cc.v, VVOID, <span class="Constant">0</span>);&nbsp; <span class="Comment">/* no value (yet) */<br/></li>
<li></span>&nbsp; <a href="lcode.c.html#L519" title="lcode.c:519">luaK_exp2nextreg</a>(ls-&gt;fs, t);&nbsp; <span class="Comment">/* fix it at stack top */<br/></li>
<li></span>&nbsp; <a href="#L112" title="lparser.c:112">checknext</a>(ls, <span class="Constant">'{'</span>);<br/></li>
<li>&nbsp; <span class="Statement">do</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(cc.v.k == VVOID || cc.tostore &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ls-&gt;t.token == <span class="Constant">'}'</span>) <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L661" title="lparser.c:661">closelistfield</a>(fs, &amp;cc);<br/></li>
<li>&nbsp; &nbsp; <a href="#L696" title="lparser.c:696">field</a>(ls, &amp;cc);<br/></li>
<li>&nbsp; } <span class="Statement">while</span> (<a href="#L97" title="lparser.c:97">testnext</a>(ls, <span class="Constant">','</span>) || <a href="#L97" title="lparser.c:97">testnext</a>(ls, <span class="Constant">';'</span>));<br/></li>
<li>&nbsp; <a href="#L122" title="lparser.c:122">check_match</a>(ls, <span class="Constant">'}'</span>, <span class="Constant">'{'</span>, line);<br/></li>
<li>&nbsp; <a href="#L672" title="lparser.c:672">lastlistfield</a>(fs, &amp;cc);<br/></li>
<li>&nbsp; <a href="lopcodes.h.html#L101" title="lopcodes.h:101">SETARG_B</a>(fs-&gt;f-&gt;code[pc], <a href="lobject.c.html#L39" title="lobject.c:39">luaO_int2fb</a>(cc.na)); <span class="Comment">/* set initial array size */<br/></li>
<li></span>&nbsp; <a href="lopcodes.h.html#L104" title="lopcodes.h:104">SETARG_C</a>(fs-&gt;f-&gt;code[pc], <a href="lobject.c.html#L39" title="lobject.c:39">luaO_int2fb</a>(cc.nh));&nbsp; <span class="Comment">/* set initial table size */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* }====================================================================== */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L747">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">parlist</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L747" title="lparser.c:747">parlist</a> -&gt; [ param { ',' param } ] */<br/></li>
<li></span>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L398" title="lobject.h:398">Proto</a> *f = fs-&gt;f;<br/></li>
<li>&nbsp; <span class="Type">int</span> nparams = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; f-&gt;is_vararg = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (ls-&gt;t.token != <span class="Constant">')'</span>) {&nbsp; <span class="Comment">/* is '<a href="#L747" title="lparser.c:747">parlist</a>' not empty? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (ls-&gt;t.token) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TK_NAME: {&nbsp; <span class="Comment">/* param -&gt; NAME */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L174" title="lparser.c:174">new_localvar</a>(ls, <a href="#L135" title="lparser.c:135">str_checkname</a>(ls));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nparams++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TK_DOTS: {&nbsp; <span class="Comment">/* param -&gt; '...' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f-&gt;is_vararg = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> <a href="llex.c.html#L118" title="llex.c:118">luaX_syntaxerror</a>(ls, <span class="Constant">&quot;&lt;name&gt; or '...' expected&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (!f-&gt;is_vararg &amp;&amp; <a href="#L97" title="lparser.c:97">testnext</a>(ls, <span class="Constant">','</span>));<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L201" title="lparser.c:201">adjustlocalvars</a>(ls, nparams);<br/></li>
<li>&nbsp; f-&gt;numparams = <a href="llimits.h.html#L110" title="llimits.h:110">cast_byte</a>(fs-&gt;nactvar);<br/></li>
<li>&nbsp; <a href="lcode.c.html#L288" title="lcode.c:288">luaK_reserveregs</a>(fs, fs-&gt;nactvar);&nbsp; <span class="Comment">/* reserve register for parameters */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L776">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">body</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e, <span class="Type">int</span> ismethod, <span class="Type">int</span> line) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L776" title="lparser.c:776">body</a> -&gt;&nbsp; '(' <a href="#L747" title="lparser.c:747">parlist</a> ')' <a href="#L1087" title="lparser.c:1087">block</a> END */<br/></li>
<li></span>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> new_fs;<br/></li>
<li>&nbsp; <a href="#L48" title="lparser.c:48">BlockCnt</a> bl;<br/></li>
<li>&nbsp; new_fs.f = <a href="#L494" title="lparser.c:494">addprototype</a>(ls);<br/></li>
<li>&nbsp; new_fs.f-&gt;linedefined = line;<br/></li>
<li>&nbsp; <a href="#L523" title="lparser.c:523">open_func</a>(ls, &amp;new_fs, &amp;bl);<br/></li>
<li>&nbsp; <a href="#L112" title="lparser.c:112">checknext</a>(ls, <span class="Constant">'('</span>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (ismethod) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L190" title="lparser.c:190">new_localvarliteral</a>(ls, <span class="Constant">&quot;self&quot;</span>);&nbsp; <span class="Comment">/* create 'self' parameter */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L201" title="lparser.c:201">adjustlocalvars</a>(ls, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L747" title="lparser.c:747">parlist</a>(ls);<br/></li>
<li>&nbsp; <a href="#L112" title="lparser.c:112">checknext</a>(ls, <span class="Constant">')'</span>);<br/></li>
<li>&nbsp; <a href="#L592" title="lparser.c:592">statlist</a>(ls);<br/></li>
<li>&nbsp; new_fs.f-&gt;lastlinedefined = ls-&gt;linenumber;<br/></li>
<li>&nbsp; <a href="#L122" title="lparser.c:122">check_match</a>(ls, TK_END, TK_FUNCTION, line);<br/></li>
<li>&nbsp; <a href="#L516" title="lparser.c:516">codeclosure</a>(ls, e);<br/></li>
<li>&nbsp; <a href="#L546" title="lparser.c:546">close_func</a>(ls);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L798">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">explist</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *v) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L798" title="lparser.c:798">explist</a> -&gt; <a href="#L1072" title="lparser.c:1072">expr</a> { ',' <a href="#L1072" title="lparser.c:1072">expr</a> } */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> n = <span class="Constant">1</span>;&nbsp; <span class="Comment">/* at least one expression */<br/></li>
<li></span>&nbsp; <a href="#L1072" title="lparser.c:1072">expr</a>(ls, v);<br/></li>
<li>&nbsp; <span class="Statement">while</span> (<a href="#L97" title="lparser.c:97">testnext</a>(ls, <span class="Constant">','</span>)) {<br/></li>
<li>&nbsp; &nbsp; <a href="lcode.c.html#L519" title="lcode.c:519">luaK_exp2nextreg</a>(ls-&gt;fs, v);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1072" title="lparser.c:1072">expr</a>(ls, v);<br/></li>
<li>&nbsp; &nbsp; n++;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L811">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">funcargs</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *f, <span class="Type">int</span> line) {<br/></li>
<li>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> args;<br/></li>
<li>&nbsp; <span class="Type">int</span> base, nparams;<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (ls-&gt;t.token) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'('</span>: {&nbsp; <span class="Comment">/* <a href="#L811" title="lparser.c:811">funcargs</a> -&gt; '(' [ <a href="#L798" title="lparser.c:798">explist</a> ] ')' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ls-&gt;t.token == <span class="Constant">')'</span>)&nbsp; <span class="Comment">/* arg list is empty? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; args.k = VVOID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L798" title="lparser.c:798">explist</a>(ls, &amp;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lcode.h.html#L47" title="lcode.h:47">luaK_setmultret</a>(fs, &amp;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L122" title="lparser.c:122">check_match</a>(ls, <span class="Constant">')'</span>, <span class="Constant">'('</span>, line);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'{'</span>: {&nbsp; <span class="Comment">/* <a href="#L811" title="lparser.c:811">funcargs</a> -&gt; <a href="#L718" title="lparser.c:718">constructor</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L718" title="lparser.c:718">constructor</a>(ls, &amp;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_STRING: {&nbsp; <span class="Comment">/* <a href="#L811" title="lparser.c:811">funcargs</a> -&gt; STRING */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L151" title="lparser.c:151">codestring</a>(ls, &amp;args, ls-&gt;t.seminfo.ts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);&nbsp; <span class="Comment">/* must use 'seminfo' before '<a href="llex.c.html#L31" title="llex.c:31">next</a>' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="llex.c.html#L118" title="llex.c:118">luaX_syntaxerror</a>(ls, <span class="Constant">&quot;function arguments expected&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(f-&gt;k == VNONRELOC);<br/></li>
<li>&nbsp; base = f-&gt;u.info;&nbsp; <span class="Comment">/* base register for call */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="#L37" title="lparser.c:37">hasmultret</a>(args.k))<br/></li>
<li>&nbsp; &nbsp; nparams = <a href="lua.h.html#L34" title="lua.h:34">LUA_MULTRET</a>;&nbsp; <span class="Comment">/* open call */<br/></li>
<li></span>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (args.k != VVOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lcode.c.html#L519" title="lcode.c:519">luaK_exp2nextreg</a>(fs, &amp;args);&nbsp; <span class="Comment">/* close last argument */<br/></li>
<li></span>&nbsp; &nbsp; nparams = fs-&gt;<a href="lcode.c.html#L294" title="lcode.c:294">freereg</a> - (base+<span class="Constant">1</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L144" title="lparser.c:144">init_exp</a>(f, VCALL, <a href="lcode.c.html#L244" title="lcode.c:244">luaK_codeABC</a>(fs, OP_CALL, base, nparams+<span class="Constant">1</span>, <span class="Constant">2</span>));<br/></li>
<li>&nbsp; <a href="lcode.c.html#L935" title="lcode.c:935">luaK_fixline</a>(fs, line);<br/></li>
<li>&nbsp; fs-&gt;<a href="lcode.c.html#L294" title="lcode.c:294">freereg</a> = base+<span class="Constant">1</span>;&nbsp; <span class="Comment">/* call remove function and arguments and leaves<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (unless changed) one result */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** {======================================================================<br/></li>
<li></span><span class="Comment">** Expression parsing<br/></li>
<li></span><span class="Comment">** =======================================================================<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L865">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">primaryexp</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *v) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L865" title="lparser.c:865">primaryexp</a> -&gt; NAME | '(' <a href="#L1072" title="lparser.c:1072">expr</a> ')' */<br/></li>
<li></span>&nbsp; <span class="Statement">switch</span> (ls-&gt;t.token) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'('</span>: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">int</span> line = ls-&gt;linenumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L1072" title="lparser.c:1072">expr</a>(ls, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L122" title="lparser.c:122">check_match</a>(ls, <span class="Constant">')'</span>, <span class="Constant">'('</span>, line);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lcode.c.html#L406" title="lcode.c:406">luaK_dischargevars</a>(ls-&gt;fs, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_NAME: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L293" title="lparser.c:293">singlevar</a>(ls, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="llex.c.html#L118" title="llex.c:118">luaX_syntaxerror</a>(ls, <span class="Constant">&quot;unexpected symbol&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L887">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">suffixedexp</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *v) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L887" title="lparser.c:887">suffixedexp</a> -&gt;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp;&nbsp; <a href="#L865" title="lparser.c:865">primaryexp</a> { '.' NAME | '[' exp ']' | ':' NAME <a href="#L811" title="lparser.c:811">funcargs</a> | <a href="#L811" title="lparser.c:811">funcargs</a> } */<br/></li>
<li></span>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <span class="Type">int</span> line = ls-&gt;linenumber;<br/></li>
<li>&nbsp; <a href="#L865" title="lparser.c:865">primaryexp</a>(ls, v);<br/></li>
<li>&nbsp; <span class="Statement">for</span> (;;) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (ls-&gt;t.token) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'.'</span>: {&nbsp; <span class="Comment">/* <a href="#L604" title="lparser.c:604">fieldsel</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L604" title="lparser.c:604">fieldsel</a>(ls, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'['</span>: {&nbsp; <span class="Comment">/* '[' <a href="#L1277" title="lparser.c:1277">exp1</a> ']' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lcode.c.html#L541" title="lcode.c:541">luaK_exp2anyregup</a>(fs, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L615" title="lparser.c:615">yindex</a>(ls, &amp;key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lcode.c.html#L736" title="lcode.c:736">luaK_indexed</a>(fs, v, &amp;key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">':'</span>: {&nbsp; <span class="Comment">/* ':' NAME <a href="#L811" title="lparser.c:811">funcargs</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L156" title="lparser.c:156">checkname</a>(ls, &amp;key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lcode.c.html#L618" title="lcode.c:618">luaK_self</a>(fs, v, &amp;key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L811" title="lparser.c:811">funcargs</a>(ls, v, line);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'('</span>: <span class="Statement">case</span> TK_STRING: <span class="Statement">case</span> <span class="Constant">'{'</span>: {&nbsp; <span class="Comment">/* <a href="#L811" title="lparser.c:811">funcargs</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lcode.c.html#L519" title="lcode.c:519">luaK_exp2nextreg</a>(fs, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L811" title="lparser.c:811">funcargs</a>(ls, v, line);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L925">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">simpleexp</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *v) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L925" title="lparser.c:925">simpleexp</a> -&gt; FLT | INT | STRING | NIL | TRUE | FALSE | ... |<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L718" title="lparser.c:718">constructor</a> | <a href="luac.c.html#L120" title="luac.c:120">FUNCTION</a> <a href="#L776" title="lparser.c:776">body</a> | <a href="#L887" title="lparser.c:887">suffixedexp</a> */<br/></li>
<li></span>&nbsp; <span class="Statement">switch</span> (ls-&gt;t.token) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_FLT: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L144" title="lparser.c:144">init_exp</a>(v, VKFLT, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; v-&gt;u.nval = ls-&gt;t.seminfo.r;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_INT: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L144" title="lparser.c:144">init_exp</a>(v, VKINT, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; v-&gt;u.ival = ls-&gt;t.seminfo.i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_STRING: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L151" title="lparser.c:151">codestring</a>(ls, v, ls-&gt;t.seminfo.ts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_NIL: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L144" title="lparser.c:144">init_exp</a>(v, VNIL, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_TRUE: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L144" title="lparser.c:144">init_exp</a>(v, VTRUE, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_FALSE: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L144" title="lparser.c:144">init_exp</a>(v, VFALSE, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_DOTS: {&nbsp; <span class="Comment">/* vararg */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L118" title="lparser.c:118">check_condition</a>(ls, fs-&gt;f-&gt;is_vararg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="luac.c.html#L44" title="luac.c:44">cannot</a> use '...' outside a vararg function&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L144" title="lparser.c:144">init_exp</a>(v, VVARARG, <a href="lcode.c.html#L244" title="lcode.c:244">luaK_codeABC</a>(fs, OP_VARARG, <span class="Constant">0</span>, <span class="Constant">1</span>, <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'{'</span>: {&nbsp; <span class="Comment">/* <a href="#L718" title="lparser.c:718">constructor</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L718" title="lparser.c:718">constructor</a>(ls, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_FUNCTION: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L776" title="lparser.c:776">body</a>(ls, v, <span class="Constant">0</span>, ls-&gt;linenumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L887" title="lparser.c:887">suffixedexp</a>(ls, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L980">&#x200c;</a><span class="Type">static</span> <a href="lcode.h.html#L40" title="lcode.h:40">UnOpr</a> <span class="linkable">getunopr</span> (<span class="Type">int</span> op) {<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (op) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_NOT: <span class="Statement">return</span> OPR_NOT;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'-'</span>: <span class="Statement">return</span> OPR_MINUS;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'~'</span>: <span class="Statement">return</span> OPR_BNOT;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'#'</span>: <span class="Statement">return</span> OPR_LEN;<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> <span class="Statement">return</span> OPR_NOUNOPR;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L991">&#x200c;</a><span class="Type">static</span> <a href="lcode.h.html#L26" title="lcode.h:26">BinOpr</a> <span class="linkable">getbinopr</span> (<span class="Type">int</span> op) {<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (op) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'+'</span>: <span class="Statement">return</span> OPR_ADD;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'-'</span>: <span class="Statement">return</span> OPR_SUB;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'*'</span>: <span class="Statement">return</span> OPR_MUL;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'%'</span>: <span class="Statement">return</span> OPR_MOD;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'^'</span>: <span class="Statement">return</span> OPR_POW;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'/'</span>: <span class="Statement">return</span> OPR_DIV;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_IDIV: <span class="Statement">return</span> OPR_IDIV;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'&amp;'</span>: <span class="Statement">return</span> OPR_BAND;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'|'</span>: <span class="Statement">return</span> OPR_BOR;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'~'</span>: <span class="Statement">return</span> OPR_BXOR;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_SHL: <span class="Statement">return</span> OPR_SHL;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_SHR: <span class="Statement">return</span> OPR_SHR;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_CONCAT: <span class="Statement">return</span> OPR_CONCAT;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_NE: <span class="Statement">return</span> OPR_NE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_EQ: <span class="Statement">return</span> OPR_EQ;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'&lt;'</span>: <span class="Statement">return</span> OPR_LT;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_LE: <span class="Statement">return</span> OPR_LE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'&gt;'</span>: <span class="Statement">return</span> OPR_GT;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_GE: <span class="Statement">return</span> OPR_GE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_AND: <span class="Statement">return</span> OPR_AND;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_OR: <span class="Statement">return</span> OPR_OR;<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> <span class="Statement">return</span> OPR_NOBINOPR;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">const</span> <span class="Type">struct</span> {<br/></li>
<li>&nbsp; <a href="llimits.h.html#L35" title="llimits.h:35">lu_byte</a> left;&nbsp; <span class="Comment">/* left <a href="#L1022" title="lparser.c:1022">priority</a> for each binary operator */<br/></li>
<li></span>&nbsp; <a href="llimits.h.html#L35" title="llimits.h:35">lu_byte</a> right; <span class="Comment">/* right <a href="#L1022" title="lparser.c:1022">priority</a> */<br/></li>
<li><a id="L1022">&#x200c;</a></span>} <span class="linkable">priority</span>[] = {&nbsp; <span class="Comment">/* ORDER OPR */<br/></li>
<li></span>&nbsp;&nbsp; {<span class="Constant">10</span>, <span class="Constant">10</span>}, {<span class="Constant">10</span>, <span class="Constant">10</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* '+' '-' */<br/></li>
<li></span>&nbsp;&nbsp; {<span class="Constant">11</span>, <span class="Constant">11</span>}, {<span class="Constant">11</span>, <span class="Constant">11</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* '*' '%' */<br/></li>
<li></span>&nbsp;&nbsp; {<span class="Constant">14</span>, <span class="Constant">13</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* '^' (right associative) */<br/></li>
<li></span>&nbsp;&nbsp; {<span class="Constant">11</span>, <span class="Constant">11</span>}, {<span class="Constant">11</span>, <span class="Constant">11</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* '/' '//' */<br/></li>
<li></span>&nbsp;&nbsp; {<span class="Constant">6</span>, <span class="Constant">6</span>}, {<span class="Constant">4</span>, <span class="Constant">4</span>}, {<span class="Constant">5</span>, <span class="Constant">5</span>},&nbsp;&nbsp; <span class="Comment">/* '&amp;' '|' '~' */<br/></li>
<li></span>&nbsp;&nbsp; {<span class="Constant">7</span>, <span class="Constant">7</span>}, {<span class="Constant">7</span>, <span class="Constant">7</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* '&lt;&lt;' '&gt;&gt;' */<br/></li>
<li></span>&nbsp;&nbsp; {<span class="Constant">9</span>, <span class="Constant">8</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Comment">/* '..' (right associative) */<br/></li>
<li></span>&nbsp;&nbsp; {<span class="Constant">3</span>, <span class="Constant">3</span>}, {<span class="Constant">3</span>, <span class="Constant">3</span>}, {<span class="Constant">3</span>, <span class="Constant">3</span>},&nbsp;&nbsp; <span class="Comment">/* ==, &lt;, &lt;= */<br/></li>
<li></span>&nbsp;&nbsp; {<span class="Constant">3</span>, <span class="Constant">3</span>}, {<span class="Constant">3</span>, <span class="Constant">3</span>}, {<span class="Constant">3</span>, <span class="Constant">3</span>},&nbsp;&nbsp; <span class="Comment">/* ~=, &gt;, &gt;= */<br/></li>
<li></span>&nbsp;&nbsp; {<span class="Constant">2</span>, <span class="Constant">2</span>}, {<span class="Constant">1</span>, <span class="Constant">1</span>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and, or */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><a id="L1035">&#x200c;</a><span class="PreProc">#define <span class="linkable">UNARY_PRIORITY</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">12</span><span class="PreProc">&nbsp; </span><span class="Comment">/* <a href="#L1022" title="lparser.c:1022">priority</a> for unary operators */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** <a href="#L1042" title="lparser.c:1042">subexpr</a> -&gt; (<a href="#L925" title="lparser.c:925">simpleexp</a> | unop <a href="#L1042" title="lparser.c:1042">subexpr</a>) { binop <a href="#L1042" title="lparser.c:1042">subexpr</a> }<br/></li>
<li></span><span class="Comment">** where 'binop' is any binary operator with a <a href="#L1022" title="lparser.c:1022">priority</a> higher than 'limit'<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L1042">&#x200c;</a></span><span class="Type">static</span> <a href="lcode.h.html#L26" title="lcode.h:26">BinOpr</a> <span class="linkable">subexpr</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *v, <span class="Type">int</span> limit) {<br/></li>
<li>&nbsp; <a href="lcode.h.html#L26" title="lcode.h:26">BinOpr</a> op;<br/></li>
<li>&nbsp; <a href="lcode.h.html#L40" title="lcode.h:40">UnOpr</a> uop;<br/></li>
<li>&nbsp; <a href="#L326" title="lparser.c:326">enterlevel</a>(ls);<br/></li>
<li>&nbsp; uop = <a href="#L980" title="lparser.c:980">getunopr</a>(ls-&gt;t.token);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (uop != OPR_NOUNOPR) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> line = ls-&gt;linenumber;<br/></li>
<li>&nbsp; &nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1042" title="lparser.c:1042">subexpr</a>(ls, v, <a href="#L1035" title="lparser.c:1035">UNARY_PRIORITY</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="lcode.c.html#L840" title="lcode.c:840">luaK_prefix</a>(ls-&gt;fs, uop, v, line);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">else</span> <a href="#L925" title="lparser.c:925">simpleexp</a>(ls, v);<br/></li>
<li>&nbsp; <span class="Comment">/* expand while operators have priorities higher than 'limit' */<br/></li>
<li></span>&nbsp; op = <a href="#L991" title="lparser.c:991">getbinopr</a>(ls-&gt;t.token);<br/></li>
<li>&nbsp; <span class="Statement">while</span> (op != OPR_NOBINOPR &amp;&amp; <a href="#L1022" title="lparser.c:1022">priority</a>[op].left &gt; limit) {<br/></li>
<li>&nbsp; &nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> v2;<br/></li>
<li>&nbsp; &nbsp; <a href="lcode.h.html#L26" title="lcode.h:26">BinOpr</a> nextop;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> line = ls-&gt;linenumber;<br/></li>
<li>&nbsp; &nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);<br/></li>
<li>&nbsp; &nbsp; <a href="lcode.c.html#L854" title="lcode.c:854">luaK_infix</a>(ls-&gt;fs, op, v);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read sub-expression with higher <a href="#L1022" title="lparser.c:1022">priority</a> */<br/></li>
<li></span>&nbsp; &nbsp; nextop = <a href="#L1042" title="lparser.c:1042">subexpr</a>(ls, &amp;v2, <a href="#L1022" title="lparser.c:1022">priority</a>[op].right);<br/></li>
<li>&nbsp; &nbsp; <a href="lcode.c.html#L884" title="lcode.c:884">luaK_posfix</a>(ls-&gt;fs, op, v, &amp;v2, line);<br/></li>
<li>&nbsp; &nbsp; op = nextop;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L333" title="lparser.c:333">leavelevel</a>(ls);<br/></li>
<li>&nbsp; <span class="Statement">return</span> op;&nbsp; <span class="Comment">/* return first untreated operator */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1072">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">expr</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *v) {<br/></li>
<li>&nbsp; <a href="#L1042" title="lparser.c:1042">subexpr</a>(ls, v, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* }==================================================================== */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** {======================================================================<br/></li>
<li></span><span class="Comment">** Rules for Statements<br/></li>
<li></span><span class="Comment">** =======================================================================<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L1087">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">block</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L1087" title="lparser.c:1087">block</a> -&gt; <a href="#L592" title="lparser.c:592">statlist</a> */<br/></li>
<li></span>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <a href="#L48" title="lparser.c:48">BlockCnt</a> bl;<br/></li>
<li>&nbsp; <a href="#L434" title="lparser.c:434">enterblock</a>(fs, &amp;bl, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <a href="#L592" title="lparser.c:592">statlist</a>(ls);<br/></li>
<li>&nbsp; <a href="#L468" title="lparser.c:468">leaveblock</a>(fs);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** structure to chain all variables in the left-hand side of an<br/></li>
<li></span><span class="Comment">** <a href="#L1141" title="lparser.c:1141">assignment</a><br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L1101">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">LHS_assign</span> {<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L1101" title="lparser.c:1101">LHS_assign</a> *prev;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> v;&nbsp; <span class="Comment">/* variable (global, local, upvalue, or indexed) */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** <a href="#L106" title="lparser.c:106">check</a> whether, in an <a href="#L1141" title="lparser.c:1141">assignment</a> to an upvalue/local variable, the<br/></li>
<li></span><span class="Comment">** upvalue/local variable is begin used in a previous <a href="#L1141" title="lparser.c:1141">assignment</a> to a<br/></li>
<li></span><span class="Comment">** table. If so, <a href="llex.c.html#L56" title="llex.c:56">save</a> original upvalue/local value in a safe place and<br/></li>
<li></span><span class="Comment">** use this safe copy in the previous <a href="#L1141" title="lparser.c:1141">assignment</a>.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L1113">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">check_conflict</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">struct</span> <a href="#L1101" title="lparser.c:1101">LHS_assign</a> *lh, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *v) {<br/></li>
<li>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <span class="Type">int</span> extra = fs-&gt;<a href="lcode.c.html#L294" title="lcode.c:294">freereg</a>;&nbsp; <span class="Comment">/* eventual position to <a href="llex.c.html#L56" title="llex.c:56">save</a> local variable */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> conflict = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (; lh; lh = lh-&gt;prev) {&nbsp; <span class="Comment">/* <a href="#L106" title="lparser.c:106">check</a> all previous assignments */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lh-&gt;v.k == VINDEXED) {&nbsp; <span class="Comment">/* assigning to a table? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Comment">/* table is the upvalue/local being assigned now? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lh-&gt;v.u.ind.vt == v-&gt;k &amp;&amp; lh-&gt;v.u.ind.t == v-&gt;u.info) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; conflict = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lh-&gt;v.u.ind.vt = VLOCAL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lh-&gt;v.u.ind.t = extra;&nbsp; <span class="Comment">/* previous <a href="#L1141" title="lparser.c:1141">assignment</a> will use safe copy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* index is the local being assigned? (index <a href="luac.c.html#L44" title="luac.c:44">cannot</a> be upvalue) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v-&gt;k == VLOCAL &amp;&amp; lh-&gt;v.u.ind.idx == v-&gt;u.info) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; conflict = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lh-&gt;v.u.ind.idx = extra;&nbsp; <span class="Comment">/* previous <a href="#L1141" title="lparser.c:1141">assignment</a> will use safe copy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">if</span> (conflict) {<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy upvalue/local value to a temporary (in position 'extra') */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lopcodes.h.html#L232" title="lopcodes.h:232">OpCode</a> op = (v-&gt;k == VLOCAL) ? OP_MOVE : OP_GETUPVAL;<br/></li>
<li>&nbsp; &nbsp; <a href="lcode.c.html#L244" title="lcode.c:244">luaK_codeABC</a>(fs, op, extra, v-&gt;u.info, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="lcode.c.html#L288" title="lcode.c:288">luaK_reserveregs</a>(fs, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1141">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">assignment</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">struct</span> <a href="#L1101" title="lparser.c:1101">LHS_assign</a> *lh, <span class="Type">int</span> nvars) {<br/></li>
<li>&nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> e;<br/></li>
<li>&nbsp; <a href="#L118" title="lparser.c:118">check_condition</a>(ls, <a href="lparser.h.html#L38" title="lparser.h:38">vkisvar</a>(lh-&gt;v.k), <span class="Constant">&quot;syntax <a href="lundump.c.html#L40" title="lundump.c:40">error</a>&quot;</span>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L97" title="lparser.c:97">testnext</a>(ls, <span class="Constant">','</span>)) {&nbsp; <span class="Comment">/* <a href="#L1141" title="lparser.c:1141">assignment</a> -&gt; ',' <a href="#L887" title="lparser.c:887">suffixedexp</a> <a href="#L1141" title="lparser.c:1141">assignment</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L1101" title="lparser.c:1101">LHS_assign</a> nv;<br/></li>
<li>&nbsp; &nbsp; nv.prev = lh;<br/></li>
<li>&nbsp; &nbsp; <a href="#L887" title="lparser.c:887">suffixedexp</a>(ls, &amp;nv.v);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nv.v.k != VINDEXED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L1113" title="lparser.c:1113">check_conflict</a>(ls, lh, &amp;nv.v);<br/></li>
<li>&nbsp; &nbsp; <a href="#L92" title="lparser.c:92">checklimit</a>(ls-&gt;fs, nvars + ls-&gt;L-&gt;nCcalls, <a href="llimits.h.html#L149" title="llimits.h:149">LUAI_MAXCCALLS</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;C levels&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1141" title="lparser.c:1141">assignment</a>(ls, &amp;nv, nvars+<span class="Constant">1</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">else</span> {&nbsp; <span class="Comment">/* <a href="#L1141" title="lparser.c:1141">assignment</a> -&gt; '=' <a href="#L798" title="lparser.c:798">explist</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span> nexps;<br/></li>
<li>&nbsp; &nbsp; <a href="#L112" title="lparser.c:112">checknext</a>(ls, <span class="Constant">'='</span>);<br/></li>
<li>&nbsp; &nbsp; nexps = <a href="#L798" title="lparser.c:798">explist</a>(ls, &amp;e);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nexps != nvars) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L306" title="lparser.c:306">adjust_assign</a>(ls, nvars, nexps, &amp;e);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nexps &gt; nvars)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ls-&gt;fs-&gt;<a href="lcode.c.html#L294" title="lcode.c:294">freereg</a> -= nexps - nvars;&nbsp; <span class="Comment">/* remove extra values */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lcode.c.html#L394" title="lcode.c:394">luaK_setoneret</a>(ls-&gt;fs, &amp;e);&nbsp; <span class="Comment">/* close last expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="lcode.c.html#L591" title="lcode.c:591">luaK_storevar</a>(ls-&gt;fs, &amp;lh-&gt;v, &amp;e);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; <span class="Comment">/* avoid default */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L144" title="lparser.c:144">init_exp</a>(&amp;e, VNONRELOC, ls-&gt;fs-&gt;<a href="lcode.c.html#L294" title="lcode.c:294">freereg</a>-<span class="Constant">1</span>);&nbsp; <span class="Comment">/* default <a href="#L1141" title="lparser.c:1141">assignment</a> */<br/></li>
<li></span>&nbsp; <a href="lcode.c.html#L591" title="lcode.c:591">luaK_storevar</a>(ls-&gt;fs, &amp;lh-&gt;v, &amp;e);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1174">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">cond</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L1174" title="lparser.c:1174">cond</a> -&gt; exp */<br/></li>
<li></span>&nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> v;<br/></li>
<li>&nbsp; <a href="#L1072" title="lparser.c:1072">expr</a>(ls, &amp;v);&nbsp; <span class="Comment">/* read condition */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (v.k == VNIL) v.k = VFALSE;&nbsp; <span class="Comment">/* 'falses' are all equal here */<br/></li>
<li></span>&nbsp; <a href="lcode.c.html#L654" title="lcode.c:654">luaK_goiftrue</a>(ls-&gt;fs, &amp;v);<br/></li>
<li>&nbsp; <span class="Statement">return</span> v.f;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1184">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">gotostat</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">int</span> pc) {<br/></li>
<li>&nbsp; <span class="Type">int</span> line = ls-&gt;linenumber;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *label;<br/></li>
<li>&nbsp; <span class="Type">int</span> g;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L97" title="lparser.c:97">testnext</a>(ls, TK_GOTO))<br/></li>
<li>&nbsp; &nbsp; label = <a href="#L135" title="lparser.c:135">str_checkname</a>(ls);<br/></li>
<li>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);&nbsp; <span class="Comment">/* skip break */<br/></li>
<li></span>&nbsp; &nbsp; label = <a href="lstring.c.html#L165" title="lstring.c:165">luaS_new</a>(ls-&gt;L, <span class="Constant">&quot;break&quot;</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; g = <a href="#L380" title="lparser.c:380">newlabelentry</a>(ls, &amp;ls-&gt;dyd-&gt;gt, label, line, pc);<br/></li>
<li>&nbsp; <a href="#L360" title="lparser.c:360">findlabel</a>(ls, g);&nbsp; <span class="Comment">/* close it if label already defined */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L106" title="lparser.c:106">check</a> for repeated labels on the same <a href="#L1087" title="lparser.c:1087">block</a> */<br/></li>
<li><a id="L1200">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">checkrepeated</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L74" title="lparser.h:74">Labellist</a> *ll, <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *label) {<br/></li>
<li>&nbsp; <span class="Type">int</span> i;<br/></li>
<li>&nbsp; <span class="Statement">for</span> (i = fs-&gt;bl-&gt;firstlabel; i &lt; ll-&gt;n; i++) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L42" title="lparser.c:42">eqstr</a>(label, ll-&gt;arr[i].name)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *msg = <a href="lobject.c.html#L416" title="lobject.c:416">luaO_pushfstring</a>(fs-&gt;ls-&gt;L,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;label '</span><span class="Special">%s</span><span class="Constant">' already defined on line </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lobject.h.html#L326" title="lobject.h:326">getstr</a>(label), ll-&gt;arr[i].line);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L67" title="lparser.c:67">semerror</a>(fs-&gt;ls, msg);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* skip no-op statements */<br/></li>
<li><a id="L1214">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">skipnoopstat</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls) {<br/></li>
<li>&nbsp; <span class="Statement">while</span> (ls-&gt;t.token == <span class="Constant">';'</span> || ls-&gt;t.token == TK_DBCOLON)<br/></li>
<li>&nbsp; &nbsp; <a href="#L1534" title="lparser.c:1534">statement</a>(ls);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1220">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">labelstat</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *label, <span class="Type">int</span> line) {<br/></li>
<li>&nbsp; <span class="Comment">/* label -&gt; '::' NAME '::' */<br/></li>
<li></span>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L74" title="lparser.h:74">Labellist</a> *ll = &amp;ls-&gt;dyd-&gt;label;<br/></li>
<li>&nbsp; <span class="Type">int</span> l;&nbsp; <span class="Comment">/* index of new label being created */<br/></li>
<li></span>&nbsp; <a href="#L1200" title="lparser.c:1200">checkrepeated</a>(fs, ll, label);&nbsp; <span class="Comment">/* <a href="#L106" title="lparser.c:106">check</a> for repeated labels */<br/></li>
<li></span>&nbsp; <a href="#L112" title="lparser.c:112">checknext</a>(ls, TK_DBCOLON);&nbsp; <span class="Comment">/* skip double colon */<br/></li>
<li></span>&nbsp; <span class="Comment">/* create new entry for this label */<br/></li>
<li></span>&nbsp; l = <a href="#L380" title="lparser.c:380">newlabelentry</a>(ls, ll, label, line, fs-&gt;pc);<br/></li>
<li>&nbsp; <a href="#L1214" title="lparser.c:1214">skipnoopstat</a>(ls);&nbsp; <span class="Comment">/* skip other no-op statements */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="#L581" title="lparser.c:581">block_follow</a>(ls, <span class="Constant">0</span>)) {&nbsp; <span class="Comment">/* label is last no-op <a href="#L1534" title="lparser.c:1534">statement</a> in the <a href="#L1087" title="lparser.c:1087">block</a>? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* assume that locals are already out of scope */<br/></li>
<li></span>&nbsp; &nbsp; ll-&gt;arr[l].nactvar = fs-&gt;bl-&gt;nactvar;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L398" title="lparser.c:398">findgotos</a>(ls, &amp;ll-&gt;arr[l]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1238">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">whilestat</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">int</span> line) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L1238" title="lparser.c:1238">whilestat</a> -&gt; WHILE <a href="#L1174" title="lparser.c:1174">cond</a> DO <a href="#L1087" title="lparser.c:1087">block</a> END */<br/></li>
<li></span>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <span class="Type">int</span> whileinit;<br/></li>
<li>&nbsp; <span class="Type">int</span> condexit;<br/></li>
<li>&nbsp; <a href="#L48" title="lparser.c:48">BlockCnt</a> bl;<br/></li>
<li>&nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);&nbsp; <span class="Comment">/* skip WHILE */<br/></li>
<li></span>&nbsp; whileinit = <a href="lcode.c.html#L111" title="lcode.c:111">luaK_getlabel</a>(fs);<br/></li>
<li>&nbsp; condexit = <a href="#L1174" title="lparser.c:1174">cond</a>(ls);<br/></li>
<li>&nbsp; <a href="#L434" title="lparser.c:434">enterblock</a>(fs, &amp;bl, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; <a href="#L112" title="lparser.c:112">checknext</a>(ls, TK_DO);<br/></li>
<li>&nbsp; <a href="#L1087" title="lparser.c:1087">block</a>(ls);<br/></li>
<li>&nbsp; <a href="lcode.h.html#L49" title="lcode.h:49">luaK_jumpto</a>(fs, whileinit);<br/></li>
<li>&nbsp; <a href="#L122" title="lparser.c:122">check_match</a>(ls, TK_END, TK_WHILE, line);<br/></li>
<li>&nbsp; <a href="#L468" title="lparser.c:468">leaveblock</a>(fs);<br/></li>
<li>&nbsp; <a href="lcode.c.html#L209" title="lcode.c:209">luaK_patchtohere</a>(fs, condexit);&nbsp; <span class="Comment">/* false conditions finish the loop */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1257">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">repeatstat</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">int</span> line) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L1257" title="lparser.c:1257">repeatstat</a> -&gt; REPEAT <a href="#L1087" title="lparser.c:1087">block</a> UNTIL <a href="#L1174" title="lparser.c:1174">cond</a> */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> condexit;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <span class="Type">int</span> repeat_init = <a href="lcode.c.html#L111" title="lcode.c:111">luaK_getlabel</a>(fs);<br/></li>
<li>&nbsp; <a href="#L48" title="lparser.c:48">BlockCnt</a> bl1, bl2;<br/></li>
<li>&nbsp; <a href="#L434" title="lparser.c:434">enterblock</a>(fs, &amp;bl1, <span class="Constant">1</span>);&nbsp; <span class="Comment">/* loop <a href="#L1087" title="lparser.c:1087">block</a> */<br/></li>
<li></span>&nbsp; <a href="#L434" title="lparser.c:434">enterblock</a>(fs, &amp;bl2, <span class="Constant">0</span>);&nbsp; <span class="Comment">/* scope <a href="#L1087" title="lparser.c:1087">block</a> */<br/></li>
<li></span>&nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);&nbsp; <span class="Comment">/* skip REPEAT */<br/></li>
<li></span>&nbsp; <a href="#L592" title="lparser.c:592">statlist</a>(ls);<br/></li>
<li>&nbsp; <a href="#L122" title="lparser.c:122">check_match</a>(ls, TK_UNTIL, TK_REPEAT, line);<br/></li>
<li>&nbsp; condexit = <a href="#L1174" title="lparser.c:1174">cond</a>(ls);&nbsp; <span class="Comment">/* read condition (inside scope <a href="#L1087" title="lparser.c:1087">block</a>) */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (bl2.upval)&nbsp; <span class="Comment">/* upvalues? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lcode.c.html#L196" title="lcode.c:196">luaK_patchclose</a>(fs, condexit, bl2.nactvar);<br/></li>
<li>&nbsp; <a href="#L468" title="lparser.c:468">leaveblock</a>(fs);&nbsp; <span class="Comment">/* finish scope */<br/></li>
<li></span>&nbsp; <a href="lcode.c.html#L186" title="lcode.c:186">luaK_patchlist</a>(fs, condexit, repeat_init);&nbsp; <span class="Comment">/* close the loop */<br/></li>
<li></span>&nbsp; <a href="#L468" title="lparser.c:468">leaveblock</a>(fs);&nbsp; <span class="Comment">/* finish loop */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1277">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">exp1</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls) {<br/></li>
<li>&nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> e;<br/></li>
<li>&nbsp; <span class="Type">int</span> reg;<br/></li>
<li>&nbsp; <a href="#L1072" title="lparser.c:1072">expr</a>(ls, &amp;e);<br/></li>
<li>&nbsp; <a href="lcode.c.html#L519" title="lcode.c:519">luaK_exp2nextreg</a>(ls-&gt;fs, &amp;e);<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(e.k == VNONRELOC);<br/></li>
<li>&nbsp; reg = e.u.info;<br/></li>
<li>&nbsp; <span class="Statement">return</span> reg;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1288">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">forbody</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">int</span> base, <span class="Type">int</span> line, <span class="Type">int</span> nvars, <span class="Type">int</span> isnum) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L1288" title="lparser.c:1288">forbody</a> -&gt; DO <a href="#L1087" title="lparser.c:1087">block</a> */<br/></li>
<li></span>&nbsp; <a href="#L48" title="lparser.c:48">BlockCnt</a> bl;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <span class="Type">int</span> prep, endfor;<br/></li>
<li>&nbsp; <a href="#L201" title="lparser.c:201">adjustlocalvars</a>(ls, <span class="Constant">3</span>);&nbsp; <span class="Comment">/* control variables */<br/></li>
<li></span>&nbsp; <a href="#L112" title="lparser.c:112">checknext</a>(ls, TK_DO);<br/></li>
<li>&nbsp; prep = isnum ? <a href="lcode.h.html#L45" title="lcode.h:45">luaK_codeAsBx</a>(fs, OP_FORPREP, base, <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>) : <a href="lcode.c.html#L76" title="lcode.c:76">luaK_jump</a>(fs);<br/></li>
<li>&nbsp; <a href="#L434" title="lparser.c:434">enterblock</a>(fs, &amp;bl, <span class="Constant">0</span>);&nbsp; <span class="Comment">/* scope for declared variables */<br/></li>
<li></span>&nbsp; <a href="#L201" title="lparser.c:201">adjustlocalvars</a>(ls, nvars);<br/></li>
<li>&nbsp; <a href="lcode.c.html#L288" title="lcode.c:288">luaK_reserveregs</a>(fs, nvars);<br/></li>
<li>&nbsp; <a href="#L1087" title="lparser.c:1087">block</a>(ls);<br/></li>
<li>&nbsp; <a href="#L468" title="lparser.c:468">leaveblock</a>(fs);&nbsp; <span class="Comment">/* end of scope for declared variables */<br/></li>
<li></span>&nbsp; <a href="lcode.c.html#L209" title="lcode.c:209">luaK_patchtohere</a>(fs, prep);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (isnum)&nbsp; <span class="Comment">/* numeric for? */<br/></li>
<li></span>&nbsp; &nbsp; endfor = <a href="lcode.h.html#L45" title="lcode.h:45">luaK_codeAsBx</a>(fs, OP_FORLOOP, base, <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>);<br/></li>
<li>&nbsp; <span class="Statement">else</span> {&nbsp; <span class="Comment">/* generic for */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lcode.c.html#L244" title="lcode.c:244">luaK_codeABC</a>(fs, OP_TFORCALL, base, <span class="Constant">0</span>, nvars);<br/></li>
<li>&nbsp; &nbsp; <a href="lcode.c.html#L935" title="lcode.c:935">luaK_fixline</a>(fs, line);<br/></li>
<li>&nbsp; &nbsp; endfor = <a href="lcode.h.html#L45" title="lcode.h:45">luaK_codeAsBx</a>(fs, OP_TFORLOOP, base + <span class="Constant">2</span>, <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="lcode.c.html#L186" title="lcode.c:186">luaK_patchlist</a>(fs, endfor, prep + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; <a href="lcode.c.html#L935" title="lcode.c:935">luaK_fixline</a>(fs, line);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1314">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">fornum</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *varname, <span class="Type">int</span> line) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L1314" title="lparser.c:1314">fornum</a> -&gt; NAME = <a href="#L1277" title="lparser.c:1277">exp1</a>,<a href="#L1277" title="lparser.c:1277">exp1</a>[,<a href="#L1277" title="lparser.c:1277">exp1</a>] <a href="#L1288" title="lparser.c:1288">forbody</a> */<br/></li>
<li></span>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <span class="Type">int</span> base = fs-&gt;<a href="lcode.c.html#L294" title="lcode.c:294">freereg</a>;<br/></li>
<li>&nbsp; <a href="#L190" title="lparser.c:190">new_localvarliteral</a>(ls, <span class="Constant">&quot;(for index)&quot;</span>);<br/></li>
<li>&nbsp; <a href="#L190" title="lparser.c:190">new_localvarliteral</a>(ls, <span class="Constant">&quot;(for limit)&quot;</span>);<br/></li>
<li>&nbsp; <a href="#L190" title="lparser.c:190">new_localvarliteral</a>(ls, <span class="Constant">&quot;(for step)&quot;</span>);<br/></li>
<li>&nbsp; <a href="#L174" title="lparser.c:174">new_localvar</a>(ls, varname);<br/></li>
<li>&nbsp; <a href="#L112" title="lparser.c:112">checknext</a>(ls, <span class="Constant">'='</span>);<br/></li>
<li>&nbsp; <a href="#L1277" title="lparser.c:1277">exp1</a>(ls);&nbsp; <span class="Comment">/* initial value */<br/></li>
<li></span>&nbsp; <a href="#L112" title="lparser.c:112">checknext</a>(ls, <span class="Constant">','</span>);<br/></li>
<li>&nbsp; <a href="#L1277" title="lparser.c:1277">exp1</a>(ls);&nbsp; <span class="Comment">/* limit */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="#L97" title="lparser.c:97">testnext</a>(ls, <span class="Constant">','</span>))<br/></li>
<li>&nbsp; &nbsp; <a href="#L1277" title="lparser.c:1277">exp1</a>(ls);&nbsp; <span class="Comment">/* optional step */<br/></li>
<li></span>&nbsp; <span class="Statement">else</span> {&nbsp; <span class="Comment">/* default step = 1 */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lcode.c.html#L267" title="lcode.c:267">luaK_codek</a>(fs, fs-&gt;<a href="lcode.c.html#L294" title="lcode.c:294">freereg</a>, <a href="lcode.c.html#L351" title="lcode.c:351">luaK_intK</a>(fs, <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; <a href="lcode.c.html#L288" title="lcode.c:288">luaK_reserveregs</a>(fs, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L1288" title="lparser.c:1288">forbody</a>(ls, base, line, <span class="Constant">1</span>, <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1336">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">forlist</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *indexname) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L1336" title="lparser.c:1336">forlist</a> -&gt; NAME {,NAME} IN <a href="#L798" title="lparser.c:798">explist</a> <a href="#L1288" title="lparser.c:1288">forbody</a> */<br/></li>
<li></span>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> e;<br/></li>
<li>&nbsp; <span class="Type">int</span> nvars = <span class="Constant">4</span>;&nbsp; <span class="Comment">/* gen, state, control, plus at least one declared var */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> line;<br/></li>
<li>&nbsp; <span class="Type">int</span> base = fs-&gt;<a href="lcode.c.html#L294" title="lcode.c:294">freereg</a>;<br/></li>
<li>&nbsp; <span class="Comment">/* create control variables */<br/></li>
<li></span>&nbsp; <a href="#L190" title="lparser.c:190">new_localvarliteral</a>(ls, <span class="Constant">&quot;(for generator)&quot;</span>);<br/></li>
<li>&nbsp; <a href="#L190" title="lparser.c:190">new_localvarliteral</a>(ls, <span class="Constant">&quot;(for state)&quot;</span>);<br/></li>
<li>&nbsp; <a href="#L190" title="lparser.c:190">new_localvarliteral</a>(ls, <span class="Constant">&quot;(for control)&quot;</span>);<br/></li>
<li>&nbsp; <span class="Comment">/* create declared variables */<br/></li>
<li></span>&nbsp; <a href="#L174" title="lparser.c:174">new_localvar</a>(ls, indexname);<br/></li>
<li>&nbsp; <span class="Statement">while</span> (<a href="#L97" title="lparser.c:97">testnext</a>(ls, <span class="Constant">','</span>)) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L174" title="lparser.c:174">new_localvar</a>(ls, <a href="#L135" title="lparser.c:135">str_checkname</a>(ls));<br/></li>
<li>&nbsp; &nbsp; nvars++;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L112" title="lparser.c:112">checknext</a>(ls, TK_IN);<br/></li>
<li>&nbsp; line = ls-&gt;linenumber;<br/></li>
<li>&nbsp; <a href="#L306" title="lparser.c:306">adjust_assign</a>(ls, <span class="Constant">3</span>, <a href="#L798" title="lparser.c:798">explist</a>(ls, &amp;e), &amp;e);<br/></li>
<li>&nbsp; <a href="lcode.c.html#L278" title="lcode.c:278">luaK_checkstack</a>(fs, <span class="Constant">3</span>);&nbsp; <span class="Comment">/* extra space to call generator */<br/></li>
<li></span>&nbsp; <a href="#L1288" title="lparser.c:1288">forbody</a>(ls, base, line, nvars - <span class="Constant">3</span>, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1361">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">forstat</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">int</span> line) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L1361" title="lparser.c:1361">forstat</a> -&gt; FOR (<a href="#L1314" title="lparser.c:1314">fornum</a> | <a href="#L1336" title="lparser.c:1336">forlist</a>) END */<br/></li>
<li></span>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *varname;<br/></li>
<li>&nbsp; <a href="#L48" title="lparser.c:48">BlockCnt</a> bl;<br/></li>
<li>&nbsp; <a href="#L434" title="lparser.c:434">enterblock</a>(fs, &amp;bl, <span class="Constant">1</span>);&nbsp; <span class="Comment">/* scope for loop and control variables */<br/></li>
<li></span>&nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);&nbsp; <span class="Comment">/* skip 'for' */<br/></li>
<li></span>&nbsp; varname = <a href="#L135" title="lparser.c:135">str_checkname</a>(ls);&nbsp; <span class="Comment">/* first variable name */<br/></li>
<li></span>&nbsp; <span class="Statement">switch</span> (ls-&gt;t.token) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'='</span>: <a href="#L1314" title="lparser.c:1314">fornum</a>(ls, varname, line); <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">','</span>: <span class="Statement">case</span> TK_IN: <a href="#L1336" title="lparser.c:1336">forlist</a>(ls, varname); <span class="Statement">break</span>;<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> <a href="llex.c.html#L118" title="llex.c:118">luaX_syntaxerror</a>(ls, <span class="Constant">&quot;'=' or 'in' expected&quot;</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L122" title="lparser.c:122">check_match</a>(ls, TK_END, TK_FOR, line);<br/></li>
<li>&nbsp; <a href="#L468" title="lparser.c:468">leaveblock</a>(fs);&nbsp; <span class="Comment">/* loop scope ('break' jumps to this point) */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1379">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">test_then_block</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">int</span> *escapelist) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L1379" title="lparser.c:1379">test_then_block</a> -&gt; [IF | ELSEIF] <a href="#L1174" title="lparser.c:1174">cond</a> THEN <a href="#L1087" title="lparser.c:1087">block</a> */<br/></li>
<li></span>&nbsp; <a href="#L48" title="lparser.c:48">BlockCnt</a> bl;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> v;<br/></li>
<li>&nbsp; <span class="Type">int</span> jf;&nbsp; <span class="Comment">/* instruction to skip 'then' code (if condition is false) */<br/></li>
<li></span>&nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);&nbsp; <span class="Comment">/* skip IF or ELSEIF */<br/></li>
<li></span>&nbsp; <a href="#L1072" title="lparser.c:1072">expr</a>(ls, &amp;v);&nbsp; <span class="Comment">/* read condition */<br/></li>
<li></span>&nbsp; <a href="#L112" title="lparser.c:112">checknext</a>(ls, TK_THEN);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (ls-&gt;t.token == TK_GOTO || ls-&gt;t.token == TK_BREAK) {<br/></li>
<li>&nbsp; &nbsp; <a href="lcode.c.html#L678" title="lcode.c:678">luaK_goiffalse</a>(ls-&gt;fs, &amp;v);&nbsp; <span class="Comment">/* will jump to label if condition is true */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L434" title="lparser.c:434">enterblock</a>(fs, &amp;bl, <span class="Constant">0</span>);&nbsp; <span class="Comment">/* must enter <a href="#L1087" title="lparser.c:1087">block</a> before 'goto' */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1184" title="lparser.c:1184">gotostat</a>(ls, v.t);&nbsp; <span class="Comment">/* handle goto/break */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1214" title="lparser.c:1214">skipnoopstat</a>(ls);&nbsp; <span class="Comment">/* skip other no-op statements */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L581" title="lparser.c:581">block_follow</a>(ls, <span class="Constant">0</span>)) {&nbsp; <span class="Comment">/* 'goto' is the entire <a href="#L1087" title="lparser.c:1087">block</a>? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L468" title="lparser.c:468">leaveblock</a>(fs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; <span class="Comment">/* and that is it */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span>&nbsp; <span class="Comment">/* must skip over 'then' part if condition is false */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; jf = <a href="lcode.c.html#L76" title="lcode.c:76">luaK_jump</a>(fs);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">else</span> {&nbsp; <span class="Comment">/* regular case (not goto/break) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lcode.c.html#L654" title="lcode.c:654">luaK_goiftrue</a>(ls-&gt;fs, &amp;v);&nbsp; <span class="Comment">/* skip over <a href="#L1087" title="lparser.c:1087">block</a> if condition is false */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L434" title="lparser.c:434">enterblock</a>(fs, &amp;bl, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; jf = v.f;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L592" title="lparser.c:592">statlist</a>(ls);&nbsp; <span class="Comment">/* 'then' part */<br/></li>
<li></span>&nbsp; <a href="#L468" title="lparser.c:468">leaveblock</a>(fs);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (ls-&gt;t.token == TK_ELSE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; ls-&gt;t.token == TK_ELSEIF)&nbsp; <span class="Comment">/* followed by 'else'/'elseif'? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lcode.c.html#L215" title="lcode.c:215">luaK_concat</a>(fs, escapelist, <a href="lcode.c.html#L76" title="lcode.c:76">luaK_jump</a>(fs));&nbsp; <span class="Comment">/* must jump over it */<br/></li>
<li></span>&nbsp; <a href="lcode.c.html#L209" title="lcode.c:209">luaK_patchtohere</a>(fs, jf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1414">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">ifstat</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">int</span> line) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L1414" title="lparser.c:1414">ifstat</a> -&gt; IF <a href="#L1174" title="lparser.c:1174">cond</a> THEN <a href="#L1087" title="lparser.c:1087">block</a> {ELSEIF <a href="#L1174" title="lparser.c:1174">cond</a> THEN <a href="#L1087" title="lparser.c:1087">block</a>} [ELSE <a href="#L1087" title="lparser.c:1087">block</a>] END */<br/></li>
<li></span>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <span class="Type">int</span> escapelist = <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>;&nbsp; <span class="Comment">/* exit list for finished parts */<br/></li>
<li></span>&nbsp; <a href="#L1379" title="lparser.c:1379">test_then_block</a>(ls, &amp;escapelist);&nbsp; <span class="Comment">/* IF <a href="#L1174" title="lparser.c:1174">cond</a> THEN <a href="#L1087" title="lparser.c:1087">block</a> */<br/></li>
<li></span>&nbsp; <span class="Statement">while</span> (ls-&gt;t.token == TK_ELSEIF)<br/></li>
<li>&nbsp; &nbsp; <a href="#L1379" title="lparser.c:1379">test_then_block</a>(ls, &amp;escapelist);&nbsp; <span class="Comment">/* ELSEIF <a href="#L1174" title="lparser.c:1174">cond</a> THEN <a href="#L1087" title="lparser.c:1087">block</a> */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="#L97" title="lparser.c:97">testnext</a>(ls, TK_ELSE))<br/></li>
<li>&nbsp; &nbsp; <a href="#L1087" title="lparser.c:1087">block</a>(ls);&nbsp; <span class="Comment">/* 'else' part */<br/></li>
<li></span>&nbsp; <a href="#L122" title="lparser.c:122">check_match</a>(ls, TK_END, TK_IF, line);<br/></li>
<li>&nbsp; <a href="lcode.c.html#L209" title="lcode.c:209">luaK_patchtohere</a>(fs, escapelist);&nbsp; <span class="Comment">/* patch escape list to 'if' end */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1428">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">localfunc</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls) {<br/></li>
<li>&nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> b;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <a href="#L174" title="lparser.c:174">new_localvar</a>(ls, <a href="#L135" title="lparser.c:135">str_checkname</a>(ls));&nbsp; <span class="Comment">/* new local variable */<br/></li>
<li></span>&nbsp; <a href="#L201" title="lparser.c:201">adjustlocalvars</a>(ls, <span class="Constant">1</span>);&nbsp; <span class="Comment">/* enter its scope */<br/></li>
<li></span>&nbsp; <a href="#L776" title="lparser.c:776">body</a>(ls, &amp;b, <span class="Constant">0</span>, ls-&gt;linenumber);&nbsp; <span class="Comment">/* function created in <a href="llex.c.html#L31" title="llex.c:31">next</a> register */<br/></li>
<li></span>&nbsp; <span class="Comment">/* debug information will only see the variable after this point! */<br/></li>
<li></span>&nbsp; <a href="#L194" title="lparser.c:194">getlocvar</a>(fs, b.u.info)-&gt;startpc = fs-&gt;pc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1439">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">localstat</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls) {<br/></li>
<li>&nbsp; <span class="Comment">/* stat -&gt; LOCAL NAME {',' NAME} ['=' <a href="#L798" title="lparser.c:798">explist</a>] */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> nvars = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Type">int</span> nexps;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> e;<br/></li>
<li>&nbsp; <span class="Statement">do</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="#L174" title="lparser.c:174">new_localvar</a>(ls, <a href="#L135" title="lparser.c:135">str_checkname</a>(ls));<br/></li>
<li>&nbsp; &nbsp; nvars++;<br/></li>
<li>&nbsp; } <span class="Statement">while</span> (<a href="#L97" title="lparser.c:97">testnext</a>(ls, <span class="Constant">','</span>));<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L97" title="lparser.c:97">testnext</a>(ls, <span class="Constant">'='</span>))<br/></li>
<li>&nbsp; &nbsp; nexps = <a href="#L798" title="lparser.c:798">explist</a>(ls, &amp;e);<br/></li>
<li>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; e.k = VVOID;<br/></li>
<li>&nbsp; &nbsp; nexps = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L306" title="lparser.c:306">adjust_assign</a>(ls, nvars, nexps, &amp;e);<br/></li>
<li>&nbsp; <a href="#L201" title="lparser.c:201">adjustlocalvars</a>(ls, nvars);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1459">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">funcname</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *v) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L1459" title="lparser.c:1459">funcname</a> -&gt; NAME {<a href="#L604" title="lparser.c:604">fieldsel</a>} [':' NAME] */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> ismethod = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <a href="#L293" title="lparser.c:293">singlevar</a>(ls, v);<br/></li>
<li>&nbsp; <span class="Statement">while</span> (ls-&gt;t.token == <span class="Constant">'.'</span>)<br/></li>
<li>&nbsp; &nbsp; <a href="#L604" title="lparser.c:604">fieldsel</a>(ls, v);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (ls-&gt;t.token == <span class="Constant">':'</span>) {<br/></li>
<li>&nbsp; &nbsp; ismethod = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L604" title="lparser.c:604">fieldsel</a>(ls, v);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> ismethod;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1473">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">funcstat</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <span class="Type">int</span> line) {<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="#L1473" title="lparser.c:1473">funcstat</a> -&gt; <a href="luac.c.html#L120" title="luac.c:120">FUNCTION</a> <a href="#L1459" title="lparser.c:1459">funcname</a> <a href="#L776" title="lparser.c:776">body</a> */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> ismethod;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> v, b;<br/></li>
<li>&nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);&nbsp; <span class="Comment">/* skip <a href="luac.c.html#L120" title="luac.c:120">FUNCTION</a> */<br/></li>
<li></span>&nbsp; ismethod = <a href="#L1459" title="lparser.c:1459">funcname</a>(ls, &amp;v);<br/></li>
<li>&nbsp; <a href="#L776" title="lparser.c:776">body</a>(ls, &amp;b, ismethod, line);<br/></li>
<li>&nbsp; <a href="lcode.c.html#L591" title="lcode.c:591">luaK_storevar</a>(ls-&gt;fs, &amp;v, &amp;b);<br/></li>
<li>&nbsp; <a href="lcode.c.html#L935" title="lcode.c:935">luaK_fixline</a>(ls-&gt;fs, line);&nbsp; <span class="Comment">/* definition &quot;happens&quot; in the first line */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1485">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">exprstat</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls) {<br/></li>
<li>&nbsp; <span class="Comment">/* stat -&gt; func | <a href="#L1141" title="lparser.c:1141">assignment</a> */<br/></li>
<li></span>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <span class="Type">struct</span> <a href="#L1101" title="lparser.c:1101">LHS_assign</a> v;<br/></li>
<li>&nbsp; <a href="#L887" title="lparser.c:887">suffixedexp</a>(ls, &amp;v.v);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (ls-&gt;t.token == <span class="Constant">'='</span> || ls-&gt;t.token == <span class="Constant">','</span>) { <span class="Comment">/* stat -&gt; <a href="#L1141" title="lparser.c:1141">assignment</a> ? */<br/></li>
<li></span>&nbsp; &nbsp; v.prev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1141" title="lparser.c:1141">assignment</a>(ls, &amp;v, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">else</span> {&nbsp; <span class="Comment">/* stat -&gt; func */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L118" title="lparser.c:118">check_condition</a>(ls, v.v.k == VCALL, <span class="Constant">&quot;syntax <a href="lundump.c.html#L40" title="lundump.c:40">error</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="lopcodes.h.html#L104" title="lopcodes.h:104">SETARG_C</a>(<a href="lcode.h.html#L43" title="lcode.h:43">getcode</a>(fs, &amp;v.v), <span class="Constant">1</span>);&nbsp; <span class="Comment">/* call <a href="#L1534" title="lparser.c:1534">statement</a> uses no results */<br/></li>
<li></span>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1501">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">retstat</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls) {<br/></li>
<li>&nbsp; <span class="Comment">/* stat -&gt; RETURN [<a href="#L798" title="lparser.c:798">explist</a>] [';'] */<br/></li>
<li></span>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs = ls-&gt;fs;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> e;<br/></li>
<li>&nbsp; <span class="Type">int</span> first, nret;&nbsp; <span class="Comment">/* registers with returned values */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="#L581" title="lparser.c:581">block_follow</a>(ls, <span class="Constant">1</span>) || ls-&gt;t.token == <span class="Constant">';'</span>)<br/></li>
<li>&nbsp; &nbsp; first = nret = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* return no values */<br/></li>
<li></span>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; nret = <a href="#L798" title="lparser.c:798">explist</a>(ls, &amp;e);&nbsp; <span class="Comment">/* optional return values */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L37" title="lparser.c:37">hasmultret</a>(e.k)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lcode.h.html#L47" title="lcode.h:47">luaK_setmultret</a>(fs, &amp;e);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (e.k == VCALL &amp;&amp; nret == <span class="Constant">1</span>) {&nbsp; <span class="Comment">/* tail call? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lopcodes.h.html#L90" title="lopcodes.h:90">SET_OPCODE</a>(<a href="lcode.h.html#L43" title="lcode.h:43">getcode</a>(fs,&amp;e), OP_TAILCALL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<a href="lopcodes.h.html#L97" title="lopcodes.h:97">GETARG_A</a>(<a href="lcode.h.html#L43" title="lcode.h:43">getcode</a>(fs,&amp;e)) == fs-&gt;nactvar);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; first = fs-&gt;nactvar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; nret = <a href="lua.h.html#L34" title="lua.h:34">LUA_MULTRET</a>;&nbsp; <span class="Comment">/* return all values */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nret == <span class="Constant">1</span>)&nbsp; <span class="Comment">/* only one single value? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; first = <a href="lcode.c.html#L527" title="lcode.c:527">luaK_exp2anyreg</a>(fs, &amp;e);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lcode.c.html#L519" title="lcode.c:519">luaK_exp2nextreg</a>(fs, &amp;e);&nbsp; <span class="Comment">/* values must go to the stack */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; first = fs-&gt;nactvar;&nbsp; <span class="Comment">/* return all active values */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(nret == fs-&gt;<a href="lcode.c.html#L294" title="lcode.c:294">freereg</a> - first);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="lcode.c.html#L86" title="lcode.c:86">luaK_ret</a>(fs, first, nret);<br/></li>
<li>&nbsp; <a href="#L97" title="lparser.c:97">testnext</a>(ls, <span class="Constant">';'</span>);&nbsp; <span class="Comment">/* skip optional semicolon */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1534">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">statement</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls) {<br/></li>
<li>&nbsp; <span class="Type">int</span> line = ls-&gt;linenumber;&nbsp; <span class="Comment">/* may be needed for <a href="lundump.c.html#L40" title="lundump.c:40">error</a> messages */<br/></li>
<li></span>&nbsp; <a href="#L326" title="lparser.c:326">enterlevel</a>(ls);<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (ls-&gt;t.token) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">';'</span>: {&nbsp; <span class="Comment">/* stat -&gt; ';' (empty <a href="#L1534" title="lparser.c:1534">statement</a>) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);&nbsp; <span class="Comment">/* skip ';' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_IF: {&nbsp; <span class="Comment">/* stat -&gt; <a href="#L1414" title="lparser.c:1414">ifstat</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L1414" title="lparser.c:1414">ifstat</a>(ls, line);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_WHILE: {&nbsp; <span class="Comment">/* stat -&gt; <a href="#L1238" title="lparser.c:1238">whilestat</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L1238" title="lparser.c:1238">whilestat</a>(ls, line);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_DO: {&nbsp; <span class="Comment">/* stat -&gt; DO <a href="#L1087" title="lparser.c:1087">block</a> END */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);&nbsp; <span class="Comment">/* skip DO */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L1087" title="lparser.c:1087">block</a>(ls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L122" title="lparser.c:122">check_match</a>(ls, TK_END, TK_DO, line);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_FOR: {&nbsp; <span class="Comment">/* stat -&gt; <a href="#L1361" title="lparser.c:1361">forstat</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L1361" title="lparser.c:1361">forstat</a>(ls, line);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_REPEAT: {&nbsp; <span class="Comment">/* stat -&gt; <a href="#L1257" title="lparser.c:1257">repeatstat</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L1257" title="lparser.c:1257">repeatstat</a>(ls, line);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_FUNCTION: {&nbsp; <span class="Comment">/* stat -&gt; <a href="#L1473" title="lparser.c:1473">funcstat</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L1473" title="lparser.c:1473">funcstat</a>(ls, line);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_LOCAL: {&nbsp; <span class="Comment">/* stat -&gt; <a href="#L1439" title="lparser.c:1439">localstat</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);&nbsp; <span class="Comment">/* skip LOCAL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L97" title="lparser.c:97">testnext</a>(ls, TK_FUNCTION))&nbsp; <span class="Comment">/* local function? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1428" title="lparser.c:1428">localfunc</a>(ls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1439" title="lparser.c:1439">localstat</a>(ls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_DBCOLON: {&nbsp; <span class="Comment">/* stat -&gt; label */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);&nbsp; <span class="Comment">/* skip double colon */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L1220" title="lparser.c:1220">labelstat</a>(ls, <a href="#L135" title="lparser.c:135">str_checkname</a>(ls), line);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_RETURN: {&nbsp; <span class="Comment">/* stat -&gt; <a href="#L1501" title="lparser.c:1501">retstat</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);&nbsp; <span class="Comment">/* skip RETURN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L1501" title="lparser.c:1501">retstat</a>(ls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> TK_BREAK:&nbsp;&nbsp; <span class="Comment">/* stat -&gt; breakstat */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">case</span> TK_GOTO: {&nbsp; <span class="Comment">/* stat -&gt; 'goto' NAME */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L1184" title="lparser.c:1184">gotostat</a>(ls, <a href="lcode.c.html#L76" title="lcode.c:76">luaK_jump</a>(ls-&gt;fs));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> {&nbsp; <span class="Comment">/* stat -&gt; func | <a href="#L1141" title="lparser.c:1141">assignment</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L1485" title="lparser.c:1485">exprstat</a>(ls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(ls-&gt;fs-&gt;f-&gt;maxstacksize &gt;= ls-&gt;fs-&gt;<a href="lcode.c.html#L294" title="lcode.c:294">freereg</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ls-&gt;fs-&gt;<a href="lcode.c.html#L294" title="lcode.c:294">freereg</a> &gt;= ls-&gt;fs-&gt;nactvar);<br/></li>
<li>&nbsp; ls-&gt;fs-&gt;<a href="lcode.c.html#L294" title="lcode.c:294">freereg</a> = ls-&gt;fs-&gt;nactvar;&nbsp; <span class="Comment">/* free registers */<br/></li>
<li></span>&nbsp; <a href="#L333" title="lparser.c:333">leavelevel</a>(ls);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* }====================================================================== */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** compiles the <a href="lua.c.html#L595" title="lua.c:595">main</a> function, which is a regular vararg function with an<br/></li>
<li></span><span class="Comment">** upvalue named <a href="llex.h.html#L18" title="llex.h:18">LUA_ENV</a><br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L1609">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">mainfunc</span> (<a href="llex.h.html#L58" title="llex.h:58">LexState</a> *ls, <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs) {<br/></li>
<li>&nbsp; <a href="#L48" title="lparser.c:48">BlockCnt</a> bl;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> v;<br/></li>
<li>&nbsp; <a href="#L523" title="lparser.c:523">open_func</a>(ls, fs, &amp;bl);<br/></li>
<li>&nbsp; fs-&gt;f-&gt;is_vararg = <span class="Constant">1</span>;&nbsp; <span class="Comment">/* <a href="lua.c.html#L595" title="lua.c:595">main</a> function is always vararg */<br/></li>
<li></span>&nbsp; <a href="#L144" title="lparser.c:144">init_exp</a>(&amp;v, VLOCAL, <span class="Constant">0</span>);&nbsp; <span class="Comment">/* create and... */<br/></li>
<li></span>&nbsp; <a href="#L227" title="lparser.c:227">newupvalue</a>(fs, ls-&gt;envn, &amp;v);&nbsp; <span class="Comment">/* ...set environment upvalue */<br/></li>
<li></span>&nbsp; <a href="llex.c.html#L586" title="llex.c:586">luaX_next</a>(ls);&nbsp; <span class="Comment">/* read first token */<br/></li>
<li></span>&nbsp; <a href="#L592" title="lparser.c:592">statlist</a>(ls);&nbsp; <span class="Comment">/* parse <a href="lua.c.html#L595" title="lua.c:595">main</a> <a href="#L776" title="lparser.c:776">body</a> */<br/></li>
<li></span>&nbsp; <a href="#L106" title="lparser.c:106">check</a>(ls, TK_EOS);<br/></li>
<li>&nbsp; <a href="#L546" title="lparser.c:546">close_func</a>(ls);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L1623">&#x200c;</a><a href="lobject.h.html#L444" title="lobject.h:444">LClosure</a> *<span class="linkable">luaY_parser</span> (<a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L, <a href="lzio.h.html#L18" title="lzio.h:18">ZIO</a> *z, <a href="lzio.h.html#L23" title="lzio.h:23">Mbuffer</a> *buff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="lparser.h.html#L82" title="lparser.h:82">Dyndata</a> *dyd, <span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type">int</span> firstchar) {<br/></li>
<li>&nbsp; <a href="llex.h.html#L58" title="llex.h:58">LexState</a> lexstate;<br/></li>
<li>&nbsp; <a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> funcstate;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L444" title="lobject.h:444">LClosure</a> *cl = <a href="lfunc.c.html#L33" title="lfunc.c:33">luaF_newLclosure</a>(L, <span class="Constant">1</span>);&nbsp; <span class="Comment">/* create <a href="lua.c.html#L595" title="lua.c:595">main</a> closure */<br/></li>
<li></span>&nbsp; <a href="lobject.h.html#L226" title="lobject.h:226">setclLvalue</a>(L, L-&gt;top, cl);&nbsp; <span class="Comment">/* anchor it (to avoid being collected) */<br/></li>
<li></span>&nbsp; <a href="ldo.h.html#L20" title="ldo.h:20">incr_top</a>(L);<br/></li>
<li>&nbsp; lexstate.h = <a href="ltable.c.html#L403" title="ltable.c:403">luaH_new</a>(L);&nbsp; <span class="Comment">/* create table for scanner */<br/></li>
<li></span>&nbsp; <a href="lobject.h.html#L236" title="lobject.h:236">sethvalue</a>(L, L-&gt;top, lexstate.h);&nbsp; <span class="Comment">/* anchor it */<br/></li>
<li></span>&nbsp; <a href="ldo.h.html#L20" title="ldo.h:20">incr_top</a>(L);<br/></li>
<li>&nbsp; funcstate.f = cl-&gt;p = <a href="lfunc.c.html#L99" title="lfunc.c:99">luaF_newproto</a>(L);<br/></li>
<li>&nbsp; funcstate.f-&gt;source = <a href="lstring.c.html#L165" title="lstring.c:165">luaS_new</a>(L, name);&nbsp; <span class="Comment">/* create and anchor <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> */<br/></li>
<li></span>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<a href="lgc.h.html#L87" title="lgc.h:87">iswhite</a>(funcstate.f));&nbsp; <span class="Comment">/* do not need barrier here */<br/></li>
<li></span>&nbsp; lexstate.buff = buff;<br/></li>
<li>&nbsp; lexstate.dyd = dyd;<br/></li>
<li>&nbsp; dyd-&gt;actvar.n = dyd-&gt;gt.n = dyd-&gt;label.n = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <a href="llex.c.html#L163" title="llex.c:163">luaX_setinput</a>(L, &amp;lexstate, z, funcstate.f-&gt;source, firstchar);<br/></li>
<li>&nbsp; <a href="#L1609" title="lparser.c:1609">mainfunc</a>(&amp;lexstate, &amp;funcstate);<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(!funcstate.prev &amp;&amp; funcstate.nups == <span class="Constant">1</span> &amp;&amp; !lexstate.fs);<br/></li>
<li>&nbsp; <span class="Comment">/* all scopes should be correctly finished */<br/></li>
<li></span>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(dyd-&gt;actvar.n == <span class="Constant">0</span> &amp;&amp; dyd-&gt;gt.n == <span class="Constant">0</span> &amp;&amp; dyd-&gt;label.n == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; L-&gt;top--;&nbsp; <span class="Comment">/* remove scanner's table */<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> cl;&nbsp; <span class="Comment">/* closure is on the stack, too */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
</ol></code>
 </body>
</html>
