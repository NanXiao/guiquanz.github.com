<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>lcode.c - src</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

code {
    font-family: consolas, monospace;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
  <h3>lcode.c - src</h3>
   <a href="../index.html"> Table of Contents </a>
 <h4>Functions defined</h4>
 <ul>
<li><a href="#L312">addk</a></li>
<li><a href="#L366">boolK</a></li>
<li><a href="#L438">code_label</a></li>
<li><a href="#L824">codecomp</a></li>
<li><a href="#L793">codeexpval</a></li>
<li><a href="#L261">codeextraarg</a></li>
<li><a href="#L701">codenot</a></li>
<li><a href="#L91">condjump</a></li>
<li><a href="#L766">constfolding</a></li>
<li><a href="#L487">discharge2anyreg</a></li>
<li><a href="#L444">discharge2reg</a></li>
<li><a href="#L180">dischargejpc</a></li>
<li><a href="#L495">exp2reg</a></li>
<li><a href="#L97">fixjump</a></li>
<li><a href="#L302">freeexp</a></li>
<li><a href="#L294">freereg</a></li>
<li><a href="#L117">getjump</a></li>
<li><a href="#L126">getjumpcontrol</a></li>
<li><a href="#L631">invertjump</a></li>
<li><a href="#L639">jumponcond</a></li>
<li><a href="#L278">luaK_checkstack</a></li>
<li><a href="#L229">luaK_code</a></li>
<li><a href="#L244">luaK_codeABC</a></li>
<li><a href="#L253">luaK_codeABx</a></li>
<li><a href="#L267">luaK_codek</a></li>
<li><a href="#L215">luaK_concat</a></li>
<li><a href="#L406">luaK_dischargevars</a></li>
<li><a href="#L555">luaK_exp2RK</a></li>
<li><a href="#L527">luaK_exp2anyreg</a></li>
<li><a href="#L541">luaK_exp2anyregup</a></li>
<li><a href="#L519">luaK_exp2nextreg</a></li>
<li><a href="#L547">luaK_exp2val</a></li>
<li><a href="#L935">luaK_fixline</a></li>
<li><a href="#L111">luaK_getlabel</a></li>
<li><a href="#L678">luaK_goiffalse</a></li>
<li><a href="#L654">luaK_goiftrue</a></li>
<li><a href="#L736">luaK_indexed</a></li>
<li><a href="#L854">luaK_infix</a></li>
<li><a href="#L351">luaK_intK</a></li>
<li><a href="#L76">luaK_jump</a></li>
<li><a href="#L54">luaK_nil</a></li>
<li><a href="#L359">luaK_numberK</a></li>
<li><a href="#L196">luaK_patchclose</a></li>
<li><a href="#L186">luaK_patchlist</a></li>
<li><a href="#L209">luaK_patchtohere</a></li>
<li><a href="#L884">luaK_posfix</a></li>
<li><a href="#L840">luaK_prefix</a></li>
<li><a href="#L288">luaK_reserveregs</a></li>
<li><a href="#L86">luaK_ret</a></li>
<li><a href="#L618">luaK_self</a></li>
<li><a href="#L940">luaK_setlist</a></li>
<li><a href="#L394">luaK_setoneret</a></li>
<li><a href="#L382">luaK_setreturns</a></li>
<li><a href="#L591">luaK_storevar</a></li>
<li><a href="#L339">luaK_stringK</a></li>
<li><a href="#L139">need_value</a></li>
<li><a href="#L373">nilK</a></li>
<li><a href="#L167">patchlistaux</a></li>
<li><a href="#L148">patchtestreg</a></li>
<li><a href="#L161">removevalues</a></li>
<li><a href="#L39">tonumeral</a></li>
<li><a href="#L749">validop</a></li>
</ul>
 <h4>Macros defined</h4>
 <ul>
<li><a href="#L8">LUA_CORE</a></li>
<li><a href="#L33">MAXREGS</a></li>
<li><a href="#L36">hasjumps</a></li>
<li><a href="#L7">lcode_c</a></li>
</ul>
 <h4>Source code</h4>

  <code><ol><li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** $Id: lcode.c,v 2.99 2014/12/29 16:49:25 roberto Exp $<br/></li>
<li></span><span class="Comment">** Code generator for Lua<br/></li>
<li></span><span class="Comment">** See Copyright Notice in lua.h<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><br/></li>
<li><a id="L7">&#x200c;</a><span class="PreProc">#define <span class="linkable">lcode_c</span><br/></li>
<li><a id="L8">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LUA_CORE</span><br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;lprefix.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;stdlib.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;lua.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;lcode.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;ldebug.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;ldo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lgc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;<a href="llex.c.html#L467" title="llex.c:467">llex</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lobject.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lopcodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lparser.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lstring.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;ltable.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lvm.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* Maximum number of registers in a Lua function */<br/></li>
<li><a id="L33">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAXREGS</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">250<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L36">&#x200c;</a><span class="PreProc">#define <span class="linkable">hasjumps</span>(e)&nbsp; &nbsp; &nbsp; &nbsp; ((e)-&gt;t != (e)-&gt;f)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L39">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">tonumeral</span>(<a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e, <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *v) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (e-&gt;t != <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a> || e-&gt;f != <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; <span class="Comment">/* not a numeral */<br/></li>
<li></span>&nbsp; <span class="Statement">switch</span> (e-&gt;k) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VKINT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v) <a href="lobject.h.html#L193" title="lobject.h:193">setivalue</a>(v, e-&gt;u.ival);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VKFLT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (v) <a href="lobject.h.html#L190" title="lobject.h:190">setfltvalue</a>(v, e-&gt;u.nval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L54">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_nil</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> from, <span class="Type">int</span> n) {<br/></li>
<li>&nbsp; <a href="llimits.h.html#L164" title="llimits.h:164">Instruction</a> *previous;<br/></li>
<li>&nbsp; <span class="Type">int</span> l = from + n - <span class="Constant">1</span>;&nbsp; <span class="Comment">/* last register to set nil */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (fs-&gt;pc &gt; fs-&gt;lasttarget) {&nbsp; <span class="Comment">/* no jumps to current position? */<br/></li>
<li></span>&nbsp; &nbsp; previous = &amp;fs-&gt;f-&gt;code[fs-&gt;pc-<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="lopcodes.h.html#L89" title="lopcodes.h:89">GET_OPCODE</a>(*previous) == OP_LOADNIL) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">int</span> pfrom = <a href="lopcodes.h.html#L97" title="lopcodes.h:97">GETARG_A</a>(*previous);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">int</span> pl = pfrom + <a href="lopcodes.h.html#L100" title="lopcodes.h:100">GETARG_B</a>(*previous);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((pfrom &lt;= from &amp;&amp; from &lt;= pl + <span class="Constant">1</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (from &lt;= pfrom &amp;&amp; pfrom &lt;= l + <span class="Constant">1</span>)) {&nbsp; <span class="Comment">/* can connect both? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pfrom &lt; from) from = pfrom;&nbsp; <span class="Comment">/* from = min(from, pfrom) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pl &gt; l) l = pl;&nbsp; <span class="Comment">/* l = max(l, pl) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lopcodes.h.html#L98" title="lopcodes.h:98">SETARG_A</a>(*previous, from);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lopcodes.h.html#L101" title="lopcodes.h:101">SETARG_B</a>(*previous, l - from);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }&nbsp; <span class="Comment">/* else go through */<br/></li>
<li></span>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L244" title="lcode.c:244">luaK_codeABC</a>(fs, OP_LOADNIL, from, n - <span class="Constant">1</span>, <span class="Constant">0</span>);&nbsp; <span class="Comment">/* else no optimization */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L76">&#x200c;</a><span class="Type">int</span> <span class="linkable">luaK_jump</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs) {<br/></li>
<li>&nbsp; <span class="Type">int</span> jpc = fs-&gt;jpc;&nbsp; <span class="Comment">/* <a href="llex.c.html#L56" title="llex.c:56">save</a> list of jumps to here */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> j;<br/></li>
<li>&nbsp; fs-&gt;jpc = <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>;<br/></li>
<li>&nbsp; j = <a href="lcode.h.html#L45" title="lcode.h:45">luaK_codeAsBx</a>(fs, OP_JMP, <span class="Constant">0</span>, <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>);<br/></li>
<li>&nbsp; <a href="#L215" title="lcode.c:215">luaK_concat</a>(fs, &amp;j, jpc);&nbsp; <span class="Comment">/* keep them on hold */<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> j;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L86">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_ret</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> first, <span class="Type">int</span> nret) {<br/></li>
<li>&nbsp; <a href="#L244" title="lcode.c:244">luaK_codeABC</a>(fs, OP_RETURN, first, nret+<span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L91">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">condjump</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lopcodes.h.html#L232" title="lopcodes.h:232">OpCode</a> op, <span class="Type">int</span> A, <span class="Type">int</span> B, <span class="Type">int</span> C) {<br/></li>
<li>&nbsp; <a href="#L244" title="lcode.c:244">luaK_codeABC</a>(fs, op, A, B, C);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L76" title="lcode.c:76">luaK_jump</a>(fs);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L97">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">fixjump</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> pc, <span class="Type">int</span> dest) {<br/></li>
<li>&nbsp; <a href="llimits.h.html#L164" title="llimits.h:164">Instruction</a> *jmp = &amp;fs-&gt;f-&gt;code[pc];<br/></li>
<li>&nbsp; <span class="Type">int</span> offset = dest-(pc+<span class="Constant">1</span>);<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(dest != <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (abs(offset) &gt; <a href="lopcodes.h.html#L61" title="lopcodes.h:61">MAXARG_sBx</a>)<br/></li>
<li>&nbsp; &nbsp; <a href="llex.c.html#L118" title="llex.c:118">luaX_syntaxerror</a>(fs-&gt;ls, <span class="Constant">&quot;control structure too long&quot;</span>);<br/></li>
<li>&nbsp; <a href="lopcodes.h.html#L113" title="lopcodes.h:113">SETARG_sBx</a>(*jmp, offset);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** returns current 'pc' and marks it as a jump target (to avoid wrong<br/></li>
<li></span><span class="Comment">** optimizations with consecutive instructions not in the same basic <a href="lparser.c.html#L1087" title="lparser.c:1087">block</a>).<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L111">&#x200c;</a></span><span class="Type">int</span> <span class="linkable">luaK_getlabel</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs) {<br/></li>
<li>&nbsp; fs-&gt;lasttarget = fs-&gt;pc;<br/></li>
<li>&nbsp; <span class="Statement">return</span> fs-&gt;pc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L117">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">getjump</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> pc) {<br/></li>
<li>&nbsp; <span class="Type">int</span> offset = <a href="lopcodes.h.html#L112" title="lopcodes.h:112">GETARG_sBx</a>(fs-&gt;f-&gt;code[pc]);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (offset == <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>)&nbsp; <span class="Comment">/* point to itself represents end of list */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>;&nbsp; <span class="Comment">/* end of list */<br/></li>
<li></span>&nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (pc+<span class="Constant">1</span>)+offset;&nbsp; <span class="Comment">/* turn offset into absolute position */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L126">&#x200c;</a><span class="Type">static</span> <a href="llimits.h.html#L164" title="llimits.h:164">Instruction</a> *<span class="linkable">getjumpcontrol</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> pc) {<br/></li>
<li>&nbsp; <a href="llimits.h.html#L164" title="llimits.h:164">Instruction</a> *pi = &amp;fs-&gt;f-&gt;code[pc];<br/></li>
<li>&nbsp; <span class="Statement">if</span> (pc &gt;= <span class="Constant">1</span> &amp;&amp; <a href="lopcodes.h.html#L285" title="lopcodes.h:285">testTMode</a>(<a href="lopcodes.h.html#L89" title="lopcodes.h:89">GET_OPCODE</a>(*(pi-<span class="Constant">1</span>))))<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pi-<span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> pi;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** <a href="lparser.c.html#L106" title="lparser.c:106">check</a> whether list has any jump that do not produce a value<br/></li>
<li></span><span class="Comment">** (or produce an inverted value)<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L139">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">need_value</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> list) {<br/></li>
<li>&nbsp; <span class="Statement">for</span> (; list != <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>; list = <a href="#L117" title="lcode.c:117">getjump</a>(fs, list)) {<br/></li>
<li>&nbsp; &nbsp; <a href="llimits.h.html#L164" title="llimits.h:164">Instruction</a> i = *<a href="#L126" title="lcode.c:126">getjumpcontrol</a>(fs, list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="lopcodes.h.html#L89" title="lopcodes.h:89">GET_OPCODE</a>(i) != OP_TESTSET) <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; <span class="Comment">/* not found */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L148">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">patchtestreg</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> node, <span class="Type">int</span> reg) {<br/></li>
<li>&nbsp; <a href="llimits.h.html#L164" title="llimits.h:164">Instruction</a> *i = <a href="#L126" title="lcode.c:126">getjumpcontrol</a>(fs, node);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="lopcodes.h.html#L89" title="lopcodes.h:89">GET_OPCODE</a>(*i) != OP_TESTSET)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; <span class="Comment">/* <a href="luac.c.html#L44" title="luac.c:44">cannot</a> patch other instructions */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (reg != <a href="lopcodes.h.html#L151" title="lopcodes.h:151">NO_REG</a> &amp;&amp; reg != <a href="lopcodes.h.html#L100" title="lopcodes.h:100">GETARG_B</a>(*i))<br/></li>
<li>&nbsp; &nbsp; <a href="lopcodes.h.html#L98" title="lopcodes.h:98">SETARG_A</a>(*i, reg);<br/></li>
<li>&nbsp; <span class="Statement">else</span>&nbsp; <span class="Comment">/* no register to put value or register already has the value */<br/></li>
<li></span>&nbsp; &nbsp; *i = <a href="lopcodes.h.html#L116" title="lopcodes.h:116">CREATE_ABC</a>(OP_TEST, <a href="lopcodes.h.html#L100" title="lopcodes.h:100">GETARG_B</a>(*i), <span class="Constant">0</span>, <a href="lopcodes.h.html#L103" title="lopcodes.h:103">GETARG_C</a>(*i));<br/></li>
<li><br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L161">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">removevalues</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> list) {<br/></li>
<li>&nbsp; <span class="Statement">for</span> (; list != <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>; list = <a href="#L117" title="lcode.c:117">getjump</a>(fs, list))<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L148" title="lcode.c:148">patchtestreg</a>(fs, list, <a href="lopcodes.h.html#L151" title="lopcodes.h:151">NO_REG</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L167">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">patchlistaux</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> list, <span class="Type">int</span> vtarget, <span class="Type">int</span> reg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> dtarget) {<br/></li>
<li>&nbsp; <span class="Statement">while</span> (list != <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> <a href="llex.c.html#L31" title="llex.c:31">next</a> = <a href="#L117" title="lcode.c:117">getjump</a>(fs, list);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L148" title="lcode.c:148">patchtestreg</a>(fs, list, reg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L97" title="lcode.c:97">fixjump</a>(fs, list, vtarget);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L97" title="lcode.c:97">fixjump</a>(fs, list, dtarget);&nbsp; <span class="Comment">/* jump to default target */<br/></li>
<li></span>&nbsp; &nbsp; list = <a href="llex.c.html#L31" title="llex.c:31">next</a>;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L180">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">dischargejpc</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs) {<br/></li>
<li>&nbsp; <a href="#L167" title="lcode.c:167">patchlistaux</a>(fs, fs-&gt;jpc, fs-&gt;pc, <a href="lopcodes.h.html#L151" title="lopcodes.h:151">NO_REG</a>, fs-&gt;pc);<br/></li>
<li>&nbsp; fs-&gt;jpc = <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L186">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_patchlist</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> list, <span class="Type">int</span> target) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (target == fs-&gt;pc)<br/></li>
<li>&nbsp; &nbsp; <a href="#L209" title="lcode.c:209">luaK_patchtohere</a>(fs, list);<br/></li>
<li>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(target &lt; fs-&gt;pc);<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="lcode.c:167">patchlistaux</a>(fs, list, target, <a href="lopcodes.h.html#L151" title="lopcodes.h:151">NO_REG</a>, target);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L196">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_patchclose</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> list, <span class="Type">int</span> level) {<br/></li>
<li>&nbsp; level++;&nbsp; <span class="Comment">/* argument is +1 to reserve 0 as non-op */<br/></li>
<li></span>&nbsp; <span class="Statement">while</span> (list != <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> <a href="llex.c.html#L31" title="llex.c:31">next</a> = <a href="#L117" title="lcode.c:117">getjump</a>(fs, list);<br/></li>
<li>&nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<a href="lopcodes.h.html#L89" title="lopcodes.h:89">GET_OPCODE</a>(fs-&gt;f-&gt;code[list]) == OP_JMP &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="lopcodes.h.html#L97" title="lopcodes.h:97">GETARG_A</a>(fs-&gt;f-&gt;code[list]) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="lopcodes.h.html#L97" title="lopcodes.h:97">GETARG_A</a>(fs-&gt;f-&gt;code[list]) &gt;= level));<br/></li>
<li>&nbsp; &nbsp; <a href="lopcodes.h.html#L98" title="lopcodes.h:98">SETARG_A</a>(fs-&gt;f-&gt;code[list], level);<br/></li>
<li>&nbsp; &nbsp; list = <a href="llex.c.html#L31" title="llex.c:31">next</a>;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L209">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_patchtohere</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> list) {<br/></li>
<li>&nbsp; <a href="#L111" title="lcode.c:111">luaK_getlabel</a>(fs);<br/></li>
<li>&nbsp; <a href="#L215" title="lcode.c:215">luaK_concat</a>(fs, &amp;fs-&gt;jpc, list);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L215">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_concat</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> *l1, <span class="Type">int</span> l2) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (l2 == <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>) <span class="Statement">return</span>;<br/></li>
<li>&nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*l1 == <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>)<br/></li>
<li>&nbsp; &nbsp; *l1 = l2;<br/></li>
<li>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> list = *l1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> <a href="llex.c.html#L31" title="llex.c:31">next</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((<a href="llex.c.html#L31" title="llex.c:31">next</a> = <a href="#L117" title="lcode.c:117">getjump</a>(fs, list)) != <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>)&nbsp; <span class="Comment">/* find last element */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; list = <a href="llex.c.html#L31" title="llex.c:31">next</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L97" title="lcode.c:97">fixjump</a>(fs, list, l2);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L229">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">luaK_code</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="llimits.h.html#L164" title="llimits.h:164">Instruction</a> i) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L398" title="lobject.h:398">Proto</a> *f = fs-&gt;f;<br/></li>
<li>&nbsp; <a href="#L180" title="lcode.c:180">dischargejpc</a>(fs);&nbsp; <span class="Comment">/* 'pc' will change */<br/></li>
<li></span>&nbsp; <span class="Comment">/* put new instruction in code array */<br/></li>
<li></span>&nbsp; <a href="lmem.h.html#L52" title="lmem.h:52">luaM_growvector</a>(fs-&gt;ls-&gt;L, f-&gt;code, fs-&gt;pc, f-&gt;sizecode, <a href="llimits.h.html#L164" title="llimits.h:164">Instruction</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="llimits.h.html#L51" title="llimits.h:51">MAX_INT</a>, <span class="Constant">&quot;opcodes&quot;</span>);<br/></li>
<li>&nbsp; f-&gt;code[fs-&gt;pc] = i;<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="llex.c.html#L56" title="llex.c:56">save</a> corresponding line information */<br/></li>
<li></span>&nbsp; <a href="lmem.h.html#L52" title="lmem.h:52">luaM_growvector</a>(fs-&gt;ls-&gt;L, f-&gt;lineinfo, fs-&gt;pc, f-&gt;sizelineinfo, <span class="Type">int</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="llimits.h.html#L51" title="llimits.h:51">MAX_INT</a>, <span class="Constant">&quot;opcodes&quot;</span>);<br/></li>
<li>&nbsp; f-&gt;lineinfo[fs-&gt;pc] = fs-&gt;ls-&gt;lastline;<br/></li>
<li>&nbsp; <span class="Statement">return</span> fs-&gt;pc++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L244">&#x200c;</a><span class="Type">int</span> <span class="linkable">luaK_codeABC</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lopcodes.h.html#L232" title="lopcodes.h:232">OpCode</a> o, <span class="Type">int</span> a, <span class="Type">int</span> b, <span class="Type">int</span> c) {<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<a href="lopcodes.h.html#L281" title="lopcodes.h:281">getOpMode</a>(o) == iABC);<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<a href="lopcodes.h.html#L282" title="lopcodes.h:282">getBMode</a>(o) != OpArgN || b == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<a href="lopcodes.h.html#L283" title="lopcodes.h:283">getCMode</a>(o) != OpArgN || c == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(a &lt;= <a href="lopcodes.h.html#L74" title="lopcodes.h:74">MAXARG_A</a> &amp;&amp; b &lt;= <a href="lopcodes.h.html#L75" title="lopcodes.h:75">MAXARG_B</a> &amp;&amp; c &lt;= <a href="lopcodes.h.html#L76" title="lopcodes.h:76">MAXARG_C</a>);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L229" title="lcode.c:229">luaK_code</a>(fs, <a href="lopcodes.h.html#L116" title="lopcodes.h:116">CREATE_ABC</a>(o, a, b, c));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L253">&#x200c;</a><span class="Type">int</span> <span class="linkable">luaK_codeABx</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lopcodes.h.html#L232" title="lopcodes.h:232">OpCode</a> o, <span class="Type">int</span> a, <span class="Type">unsigned</span> <span class="Type">int</span> bc) {<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<a href="lopcodes.h.html#L281" title="lopcodes.h:281">getOpMode</a>(o) == iABx || <a href="lopcodes.h.html#L281" title="lopcodes.h:281">getOpMode</a>(o) == iAsBx);<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<a href="lopcodes.h.html#L283" title="lopcodes.h:283">getCMode</a>(o) == OpArgN);<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(a &lt;= <a href="lopcodes.h.html#L74" title="lopcodes.h:74">MAXARG_A</a> &amp;&amp; bc &lt;= <a href="lopcodes.h.html#L60" title="lopcodes.h:60">MAXARG_Bx</a>);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L229" title="lcode.c:229">luaK_code</a>(fs, <a href="lopcodes.h.html#L121" title="lopcodes.h:121">CREATE_ABx</a>(o, a, bc));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L261">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">codeextraarg</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> a) {<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(a &lt;= <a href="lopcodes.h.html#L68" title="lopcodes.h:68">MAXARG_Ax</a>);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L229" title="lcode.c:229">luaK_code</a>(fs, <a href="lopcodes.h.html#L125" title="lopcodes.h:125">CREATE_Ax</a>(OP_EXTRAARG, a));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L267">&#x200c;</a><span class="Type">int</span> <span class="linkable">luaK_codek</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> reg, <span class="Type">int</span> k) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (k &lt;= <a href="lopcodes.h.html#L60" title="lopcodes.h:60">MAXARG_Bx</a>)<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L253" title="lcode.c:253">luaK_codeABx</a>(fs, OP_LOADK, reg, k);<br/></li>
<li>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> p = <a href="#L253" title="lcode.c:253">luaK_codeABx</a>(fs, OP_LOADKX, reg, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L261" title="lcode.c:261">codeextraarg</a>(fs, k);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> p;<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L278">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_checkstack</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> n) {<br/></li>
<li>&nbsp; <span class="Type">int</span> newstack = fs-&gt;<a href="#L294" title="lcode.c:294">freereg</a> + n;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (newstack &gt; fs-&gt;f-&gt;maxstacksize) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newstack &gt;= <a href="#L33" title="lcode.c:33">MAXREGS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="llex.c.html#L118" title="llex.c:118">luaX_syntaxerror</a>(fs-&gt;ls, <span class="Constant">&quot;function or expression too complex&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; fs-&gt;f-&gt;maxstacksize = <a href="llimits.h.html#L110" title="llimits.h:110">cast_byte</a>(newstack);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L288">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_reserveregs</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> n) {<br/></li>
<li>&nbsp; <a href="#L278" title="lcode.c:278">luaK_checkstack</a>(fs, n);<br/></li>
<li>&nbsp; fs-&gt;<a href="#L294" title="lcode.c:294">freereg</a> += n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L294">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">freereg</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> reg) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (!<a href="lopcodes.h.html#L137" title="lopcodes.h:137">ISK</a>(reg) &amp;&amp; reg &gt;= fs-&gt;nactvar) {<br/></li>
<li>&nbsp; &nbsp; fs-&gt;<a href="#L294" title="lcode.c:294">freereg</a>--;<br/></li>
<li>&nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(reg == fs-&gt;<a href="#L294" title="lcode.c:294">freereg</a>);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L302">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">freeexp</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (e-&gt;k == VNONRELOC)<br/></li>
<li>&nbsp; &nbsp; <a href="#L294" title="lcode.c:294">freereg</a>(fs, e-&gt;u.info);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** Use scanner's table to cache position of constants in constant list<br/></li>
<li></span><span class="Comment">** and try to reuse constants<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L312">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">addk</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *key, <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *v) {<br/></li>
<li>&nbsp; <a href="lstate.h.html#L149" title="lstate.h:149">lua_State</a> *L = fs-&gt;ls-&gt;L;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L398" title="lobject.h:398">Proto</a> *f = fs-&gt;f;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *idx = <a href="ltable.c.html#L572" title="ltable.c:572">luaH_set</a>(L, fs-&gt;ls-&gt;h, key);&nbsp; <span class="Comment">/* index scanner table */<br/></li>
<li></span>&nbsp; <span class="Type">int</span> k, oldsize;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="lobject.h.html#L136" title="lobject.h:136">ttisinteger</a>(idx)) {&nbsp; <span class="Comment">/* is there an index there? */<br/></li>
<li></span>&nbsp; &nbsp; k = <a href="llimits.h.html#L112" title="llimits.h:112">cast_int</a>(<a href="lobject.h.html#L155" title="lobject.h:155">ivalue</a>(idx));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* correct value? (warning: must distinguish floats from integers!) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (k &lt; fs-&gt;nk &amp;&amp; <a href="lobject.h.html#L125" title="lobject.h:125">ttype</a>(&amp;f-&gt;k[k]) == <a href="lobject.h.html#L125" title="lobject.h:125">ttype</a>(v) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lvm.h.html#L38" title="lvm.h:38">luaV_rawequalobj</a>(&amp;f-&gt;k[k], v))<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> k;&nbsp; <span class="Comment">/* reuse index */<br/></li>
<li></span>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* constant not found; create a new entry */<br/></li>
<li></span>&nbsp; oldsize = f-&gt;sizek;<br/></li>
<li>&nbsp; k = fs-&gt;nk;<br/></li>
<li>&nbsp; <span class="Comment">/* numerical value does not need GC barrier;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; table has no metatable, so it does not need to invalidate cache */<br/></li>
<li></span>&nbsp; <a href="lobject.h.html#L193" title="lobject.h:193">setivalue</a>(idx, k);<br/></li>
<li>&nbsp; <a href="lmem.h.html#L52" title="lmem.h:52">luaM_growvector</a>(L, f-&gt;k, k, f-&gt;sizek, <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a>, <a href="lopcodes.h.html#L68" title="lopcodes.h:68">MAXARG_Ax</a>, <span class="Constant">&quot;constants&quot;</span>);<br/></li>
<li>&nbsp; <span class="Statement">while</span> (oldsize &lt; f-&gt;sizek) <a href="lobject.h.html#L196" title="lobject.h:196">setnilvalue</a>(&amp;f-&gt;k[oldsize++]);<br/></li>
<li>&nbsp; <a href="lobject.h.html#L245" title="lobject.h:245">setobj</a>(L, &amp;f-&gt;k[k], v);<br/></li>
<li>&nbsp; fs-&gt;nk++;<br/></li>
<li>&nbsp; <a href="lgc.h.html#L109" title="lgc.h:109">luaC_barrier</a>(L, f, v);<br/></li>
<li>&nbsp; <span class="Statement">return</span> k;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L339">&#x200c;</a><span class="Type">int</span> <span class="linkable">luaK_stringK</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lobject.h.html#L303" title="lobject.h:303">TString</a> *s) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> o;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L211" title="lobject.h:211">setsvalue</a>(fs-&gt;ls-&gt;L, &amp;o, s);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L312" title="lcode.c:312">addk</a>(fs, &amp;o, &amp;o);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** Integers use userdata as keys to avoid collision with floats with same<br/></li>
<li></span><span class="Comment">** value; conversion to 'void*' used only for hashing, no &quot;precision&quot;<br/></li>
<li></span><span class="Comment">** problems<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L351">&#x200c;</a></span><span class="Type">int</span> <span class="linkable">luaK_intK</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lua.h.html#L91" title="lua.h:91">lua_Integer</a> n) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> k, o;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L201" title="lobject.h:201">setpvalue</a>(&amp;k, <a href="llimits.h.html#L107" title="llimits.h:107">cast</a>(<span class="Type">void</span>*, <a href="llimits.h.html#L107" title="llimits.h:107">cast</a>(<span class="Type">size_t</span>, n)));<br/></li>
<li>&nbsp; <a href="lobject.h.html#L193" title="lobject.h:193">setivalue</a>(&amp;o, n);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L312" title="lcode.c:312">addk</a>(fs, &amp;k, &amp;o);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L359">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">luaK_numberK</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lua.h.html#L87" title="lua.h:87">lua_Number</a> r) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> o;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L190" title="lobject.h:190">setfltvalue</a>(&amp;o, r);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L312" title="lcode.c:312">addk</a>(fs, &amp;o, &amp;o);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L366">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">boolK</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> b) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> o;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L204" title="lobject.h:204">setbvalue</a>(&amp;o, b);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L312" title="lcode.c:312">addk</a>(fs, &amp;o, &amp;o);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L373">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">nilK</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> k, v;<br/></li>
<li>&nbsp; <a href="lobject.h.html#L196" title="lobject.h:196">setnilvalue</a>(&amp;v);<br/></li>
<li>&nbsp; <span class="Comment">/* <a href="luac.c.html#L44" title="luac.c:44">cannot</a> use nil as key; instead use table itself to represent nil */<br/></li>
<li></span>&nbsp; <a href="lobject.h.html#L236" title="lobject.h:236">sethvalue</a>(fs-&gt;ls-&gt;L, &amp;k, fs-&gt;ls-&gt;h);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L312" title="lcode.c:312">addk</a>(fs, &amp;k, &amp;v);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L382">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_setreturns</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e, <span class="Type">int</span> nresults) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (e-&gt;k == VCALL) {&nbsp; <span class="Comment">/* expression is an open function call? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lopcodes.h.html#L104" title="lopcodes.h:104">SETARG_C</a>(<a href="lcode.h.html#L43" title="lcode.h:43">getcode</a>(fs, e), nresults+<span class="Constant">1</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (e-&gt;k == VVARARG) {<br/></li>
<li>&nbsp; &nbsp; <a href="lopcodes.h.html#L101" title="lopcodes.h:101">SETARG_B</a>(<a href="lcode.h.html#L43" title="lcode.h:43">getcode</a>(fs, e), nresults+<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="lopcodes.h.html#L98" title="lopcodes.h:98">SETARG_A</a>(<a href="lcode.h.html#L43" title="lcode.h:43">getcode</a>(fs, e), fs-&gt;<a href="#L294" title="lcode.c:294">freereg</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L288" title="lcode.c:288">luaK_reserveregs</a>(fs, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L394">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_setoneret</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (e-&gt;k == VCALL) {&nbsp; <span class="Comment">/* expression is an open function call? */<br/></li>
<li></span>&nbsp; &nbsp; e-&gt;k = VNONRELOC;<br/></li>
<li>&nbsp; &nbsp; e-&gt;u.info = <a href="lopcodes.h.html#L97" title="lopcodes.h:97">GETARG_A</a>(<a href="lcode.h.html#L43" title="lcode.h:43">getcode</a>(fs, e));<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (e-&gt;k == VVARARG) {<br/></li>
<li>&nbsp; &nbsp; <a href="lopcodes.h.html#L101" title="lopcodes.h:101">SETARG_B</a>(<a href="lcode.h.html#L43" title="lcode.h:43">getcode</a>(fs, e), <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; e-&gt;k = VRELOCABLE;&nbsp; <span class="Comment">/* can relocate its simple result */<br/></li>
<li></span>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L406">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_dischargevars</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e) {<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (e-&gt;k) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VLOCAL: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; e-&gt;k = VNONRELOC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VUPVAL: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; e-&gt;u.info = <a href="#L244" title="lcode.c:244">luaK_codeABC</a>(fs, OP_GETUPVAL, <span class="Constant">0</span>, e-&gt;u.info, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; e-&gt;k = VRELOCABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VINDEXED: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lopcodes.h.html#L232" title="lopcodes.h:232">OpCode</a> op = OP_GETTABUP;&nbsp; <span class="Comment">/* assume 't' is in an upvalue */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L294" title="lcode.c:294">freereg</a>(fs, e-&gt;u.ind.idx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (e-&gt;u.ind.vt == VLOCAL) {&nbsp; <span class="Comment">/* 't' is in a register? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L294" title="lcode.c:294">freereg</a>(fs, e-&gt;u.ind.t);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; op = OP_GETTABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; e-&gt;u.info = <a href="#L244" title="lcode.c:244">luaK_codeABC</a>(fs, op, <span class="Constant">0</span>, e-&gt;u.ind.t, e-&gt;u.ind.idx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; e-&gt;k = VRELOCABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VVARARG:<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VCALL: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L394" title="lcode.c:394">luaK_setoneret</a>(fs, e);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> <span class="Statement">break</span>;&nbsp; <span class="Comment">/* there is one value available (somewhere) */<br/></li>
<li></span>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L438">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">code_label</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> A, <span class="Type">int</span> b, <span class="Type">int</span> jump) {<br/></li>
<li>&nbsp; <a href="#L111" title="lcode.c:111">luaK_getlabel</a>(fs);&nbsp; <span class="Comment">/* those instructions may be jump targets */<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> <a href="#L244" title="lcode.c:244">luaK_codeABC</a>(fs, OP_LOADBOOL, A, b, jump);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L444">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">discharge2reg</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e, <span class="Type">int</span> reg) {<br/></li>
<li>&nbsp; <a href="#L406" title="lcode.c:406">luaK_dischargevars</a>(fs, e);<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (e-&gt;k) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VNIL: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L54" title="lcode.c:54">luaK_nil</a>(fs, reg, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VFALSE: <span class="Statement">case</span> VTRUE: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L244" title="lcode.c:244">luaK_codeABC</a>(fs, OP_LOADBOOL, reg, e-&gt;k == VTRUE, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VK: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L267" title="lcode.c:267">luaK_codek</a>(fs, reg, e-&gt;u.info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VKFLT: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L267" title="lcode.c:267">luaK_codek</a>(fs, reg, <a href="#L359" title="lcode.c:359">luaK_numberK</a>(fs, e-&gt;u.nval));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VKINT: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L267" title="lcode.c:267">luaK_codek</a>(fs, reg, <a href="#L351" title="lcode.c:351">luaK_intK</a>(fs, e-&gt;u.ival));<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VRELOCABLE: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="llimits.h.html#L164" title="llimits.h:164">Instruction</a> *pc = &amp;<a href="lcode.h.html#L43" title="lcode.h:43">getcode</a>(fs, e);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lopcodes.h.html#L98" title="lopcodes.h:98">SETARG_A</a>(*pc, reg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VNONRELOC: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reg != e-&gt;u.info)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L244" title="lcode.c:244">luaK_codeABC</a>(fs, OP_MOVE, reg, e-&gt;u.info, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(e-&gt;k == VVOID || e-&gt;k == VJMP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; <span class="Comment">/* nothing to do... */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; e-&gt;u.info = reg;<br/></li>
<li>&nbsp; e-&gt;k = VNONRELOC;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L487">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">discharge2anyreg</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (e-&gt;k != VNONRELOC) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L288" title="lcode.c:288">luaK_reserveregs</a>(fs, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L444" title="lcode.c:444">discharge2reg</a>(fs, e, fs-&gt;<a href="#L294" title="lcode.c:294">freereg</a>-<span class="Constant">1</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L495">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">exp2reg</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e, <span class="Type">int</span> reg) {<br/></li>
<li>&nbsp; <a href="#L444" title="lcode.c:444">discharge2reg</a>(fs, e, reg);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (e-&gt;k == VJMP)<br/></li>
<li>&nbsp; &nbsp; <a href="#L215" title="lcode.c:215">luaK_concat</a>(fs, &amp;e-&gt;t, e-&gt;u.info);&nbsp; <span class="Comment">/* put this jump in 't' list */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="#L36" title="lcode.c:36">hasjumps</a>(e)) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> final;&nbsp; <span class="Comment">/* position after whole expression */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span> p_f = <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>;&nbsp; <span class="Comment">/* position of an eventual LOAD false */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span> p_t = <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>;&nbsp; <span class="Comment">/* position of an eventual LOAD true */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L139" title="lcode.c:139">need_value</a>(fs, e-&gt;t) || <a href="#L139" title="lcode.c:139">need_value</a>(fs, e-&gt;f)) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">int</span> fj = (e-&gt;k == VJMP) ? <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a> : <a href="#L76" title="lcode.c:76">luaK_jump</a>(fs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; p_f = <a href="#L438" title="lcode.c:438">code_label</a>(fs, reg, <span class="Constant">0</span>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; p_t = <a href="#L438" title="lcode.c:438">code_label</a>(fs, reg, <span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L209" title="lcode.c:209">luaK_patchtohere</a>(fs, fj);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; final = <a href="#L111" title="lcode.c:111">luaK_getlabel</a>(fs);<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="lcode.c:167">patchlistaux</a>(fs, e-&gt;f, final, reg, p_f);<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="lcode.c:167">patchlistaux</a>(fs, e-&gt;t, final, reg, p_t);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; e-&gt;f = e-&gt;t = <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>;<br/></li>
<li>&nbsp; e-&gt;u.info = reg;<br/></li>
<li>&nbsp; e-&gt;k = VNONRELOC;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L519">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_exp2nextreg</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e) {<br/></li>
<li>&nbsp; <a href="#L406" title="lcode.c:406">luaK_dischargevars</a>(fs, e);<br/></li>
<li>&nbsp; <a href="#L302" title="lcode.c:302">freeexp</a>(fs, e);<br/></li>
<li>&nbsp; <a href="#L288" title="lcode.c:288">luaK_reserveregs</a>(fs, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; <a href="#L495" title="lcode.c:495">exp2reg</a>(fs, e, fs-&gt;<a href="#L294" title="lcode.c:294">freereg</a> - <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L527">&#x200c;</a><span class="Type">int</span> <span class="linkable">luaK_exp2anyreg</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e) {<br/></li>
<li>&nbsp; <a href="#L406" title="lcode.c:406">luaK_dischargevars</a>(fs, e);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (e-&gt;k == VNONRELOC) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L36" title="lcode.c:36">hasjumps</a>(e)) <span class="Statement">return</span> e-&gt;u.info;&nbsp; <span class="Comment">/* exp is already in a register */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (e-&gt;u.info &gt;= fs-&gt;nactvar) {&nbsp; <span class="Comment">/* reg. is not a local? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L495" title="lcode.c:495">exp2reg</a>(fs, e, e-&gt;u.info);&nbsp; <span class="Comment">/* put value on it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> e-&gt;u.info;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L519" title="lcode.c:519">luaK_exp2nextreg</a>(fs, e);&nbsp; <span class="Comment">/* default */<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> e-&gt;u.info;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L541">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_exp2anyregup</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (e-&gt;k != VUPVAL || <a href="#L36" title="lcode.c:36">hasjumps</a>(e))<br/></li>
<li>&nbsp; &nbsp; <a href="#L527" title="lcode.c:527">luaK_exp2anyreg</a>(fs, e);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L547">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_exp2val</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="#L36" title="lcode.c:36">hasjumps</a>(e))<br/></li>
<li>&nbsp; &nbsp; <a href="#L527" title="lcode.c:527">luaK_exp2anyreg</a>(fs, e);<br/></li>
<li>&nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L406" title="lcode.c:406">luaK_dischargevars</a>(fs, e);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L555">&#x200c;</a><span class="Type">int</span> <span class="linkable">luaK_exp2RK</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e) {<br/></li>
<li>&nbsp; <a href="#L547" title="lcode.c:547">luaK_exp2val</a>(fs, e);<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (e-&gt;k) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VTRUE:<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VFALSE:<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VNIL: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fs-&gt;nk &lt;= <a href="lopcodes.h.html#L142" title="lopcodes.h:142">MAXINDEXRK</a>) {&nbsp; <span class="Comment">/* constant fits in RK operand? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; e-&gt;u.info = (e-&gt;k == VNIL) ? <a href="#L373" title="lcode.c:373">nilK</a>(fs) : <a href="#L366" title="lcode.c:366">boolK</a>(fs, (e-&gt;k == VTRUE));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; e-&gt;k = VK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="lopcodes.h.html#L145" title="lopcodes.h:145">RKASK</a>(e-&gt;u.info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VKINT: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; e-&gt;u.info = <a href="#L351" title="lcode.c:351">luaK_intK</a>(fs, e-&gt;u.ival);<br/></li>
<li>&nbsp; &nbsp; &nbsp; e-&gt;k = VK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> vk;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VKFLT: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; e-&gt;u.info = <a href="#L359" title="lcode.c:359">luaK_numberK</a>(fs, e-&gt;u.nval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; e-&gt;k = VK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Comment">/* go through */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VK: {<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp;&nbsp; </span><span class="Statement">vk</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (e-&gt;u.info &lt;= <a href="lopcodes.h.html#L142" title="lopcodes.h:142">MAXINDEXRK</a>)&nbsp; <span class="Comment">/* constant fits in 'argC'? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="lopcodes.h.html#L145" title="lopcodes.h:145">RKASK</a>(e-&gt;u.info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> <span class="Statement">break</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* not a constant in the right range: put it in a register */<br/></li>
<li></span>&nbsp; <span class="Statement">return</span> <a href="#L527" title="lcode.c:527">luaK_exp2anyreg</a>(fs, e);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L591">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_storevar</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *var, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *ex) {<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (var-&gt;k) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VLOCAL: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L302" title="lcode.c:302">freeexp</a>(fs, ex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L495" title="lcode.c:495">exp2reg</a>(fs, ex, var-&gt;u.info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VUPVAL: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">int</span> e = <a href="#L527" title="lcode.c:527">luaK_exp2anyreg</a>(fs, ex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L244" title="lcode.c:244">luaK_codeABC</a>(fs, OP_SETUPVAL, e, var-&gt;u.info, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VINDEXED: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lopcodes.h.html#L232" title="lopcodes.h:232">OpCode</a> op = (var-&gt;u.ind.vt == VLOCAL) ? OP_SETTABLE : OP_SETTABUP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Type">int</span> e = <a href="#L555" title="lcode.c:555">luaK_exp2RK</a>(fs, ex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L244" title="lcode.c:244">luaK_codeABC</a>(fs, op, var-&gt;u.ind.t, var-&gt;u.ind.idx, e);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<span class="Constant">0</span>);&nbsp; <span class="Comment">/* invalid var kind to store */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L302" title="lcode.c:302">freeexp</a>(fs, ex);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L618">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_self</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *key) {<br/></li>
<li>&nbsp; <span class="Type">int</span> ereg;<br/></li>
<li>&nbsp; <a href="#L527" title="lcode.c:527">luaK_exp2anyreg</a>(fs, e);<br/></li>
<li>&nbsp; ereg = e-&gt;u.info;&nbsp; <span class="Comment">/* register where 'e' was placed */<br/></li>
<li></span>&nbsp; <a href="#L302" title="lcode.c:302">freeexp</a>(fs, e);<br/></li>
<li>&nbsp; e-&gt;u.info = fs-&gt;<a href="#L294" title="lcode.c:294">freereg</a>;&nbsp; <span class="Comment">/* base register for op_self */<br/></li>
<li></span>&nbsp; e-&gt;k = VNONRELOC;<br/></li>
<li>&nbsp; <a href="#L288" title="lcode.c:288">luaK_reserveregs</a>(fs, <span class="Constant">2</span>);&nbsp; <span class="Comment">/* function and 'self' produced by op_self */<br/></li>
<li></span>&nbsp; <a href="#L244" title="lcode.c:244">luaK_codeABC</a>(fs, OP_SELF, e-&gt;u.info, ereg, <a href="#L555" title="lcode.c:555">luaK_exp2RK</a>(fs, key));<br/></li>
<li>&nbsp; <a href="#L302" title="lcode.c:302">freeexp</a>(fs, key);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L631">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">invertjump</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e) {<br/></li>
<li>&nbsp; <a href="llimits.h.html#L164" title="llimits.h:164">Instruction</a> *pc = <a href="#L126" title="lcode.c:126">getjumpcontrol</a>(fs, e-&gt;u.info);<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<a href="lopcodes.h.html#L285" title="lopcodes.h:285">testTMode</a>(<a href="lopcodes.h.html#L89" title="lopcodes.h:89">GET_OPCODE</a>(*pc)) &amp;&amp; <a href="lopcodes.h.html#L89" title="lopcodes.h:89">GET_OPCODE</a>(*pc) != OP_TESTSET &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="lopcodes.h.html#L89" title="lopcodes.h:89">GET_OPCODE</a>(*pc) != OP_TEST);<br/></li>
<li>&nbsp; <a href="lopcodes.h.html#L98" title="lopcodes.h:98">SETARG_A</a>(*pc, !(<a href="lopcodes.h.html#L97" title="lopcodes.h:97">GETARG_A</a>(*pc)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L639">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">jumponcond</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e, <span class="Type">int</span> <a href="lparser.c.html#L1174" title="lparser.c:1174">cond</a>) {<br/></li>
<li>&nbsp; <span class="Statement">if</span> (e-&gt;k == VRELOCABLE) {<br/></li>
<li>&nbsp; &nbsp; <a href="llimits.h.html#L164" title="llimits.h:164">Instruction</a> ie = <a href="lcode.h.html#L43" title="lcode.h:43">getcode</a>(fs, e);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="lopcodes.h.html#L89" title="lopcodes.h:89">GET_OPCODE</a>(ie) == OP_NOT) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; fs-&gt;pc--;&nbsp; <span class="Comment">/* remove previous OP_NOT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L91" title="lcode.c:91">condjump</a>(fs, OP_TEST, <a href="lopcodes.h.html#L100" title="lopcodes.h:100">GETARG_B</a>(ie), <span class="Constant">0</span>, !<a href="lparser.c.html#L1174" title="lparser.c:1174">cond</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* else go through */<br/></li>
<li></span>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L487" title="lcode.c:487">discharge2anyreg</a>(fs, e);<br/></li>
<li>&nbsp; <a href="#L302" title="lcode.c:302">freeexp</a>(fs, e);<br/></li>
<li>&nbsp; <span class="Statement">return</span> <a href="#L91" title="lcode.c:91">condjump</a>(fs, OP_TESTSET, <a href="lopcodes.h.html#L151" title="lopcodes.h:151">NO_REG</a>, e-&gt;u.info, <a href="lparser.c.html#L1174" title="lparser.c:1174">cond</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L654">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_goiftrue</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e) {<br/></li>
<li>&nbsp; <span class="Type">int</span> pc;&nbsp; <span class="Comment">/* pc of last jump */<br/></li>
<li></span>&nbsp; <a href="#L406" title="lcode.c:406">luaK_dischargevars</a>(fs, e);<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (e-&gt;k) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VJMP: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L631" title="lcode.c:631">invertjump</a>(fs, e);<br/></li>
<li>&nbsp; &nbsp; &nbsp; pc = e-&gt;u.info;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VK: <span class="Statement">case</span> VKFLT: <span class="Statement">case</span> VKINT: <span class="Statement">case</span> VTRUE: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; pc = <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>;&nbsp; <span class="Comment">/* always true; do nothing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; pc = <a href="#L639" title="lcode.c:639">jumponcond</a>(fs, e, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L215" title="lcode.c:215">luaK_concat</a>(fs, &amp;e-&gt;f, pc);&nbsp; <span class="Comment">/* insert last jump in 'f' list */<br/></li>
<li></span>&nbsp; <a href="#L209" title="lcode.c:209">luaK_patchtohere</a>(fs, e-&gt;t);<br/></li>
<li>&nbsp; e-&gt;t = <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L678">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_goiffalse</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e) {<br/></li>
<li>&nbsp; <span class="Type">int</span> pc;&nbsp; <span class="Comment">/* pc of last jump */<br/></li>
<li></span>&nbsp; <a href="#L406" title="lcode.c:406">luaK_dischargevars</a>(fs, e);<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (e-&gt;k) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VJMP: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; pc = e-&gt;u.info;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VNIL: <span class="Statement">case</span> VFALSE: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; pc = <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>;&nbsp; <span class="Comment">/* always false; do nothing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; pc = <a href="#L639" title="lcode.c:639">jumponcond</a>(fs, e, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <a href="#L215" title="lcode.c:215">luaK_concat</a>(fs, &amp;e-&gt;t, pc);&nbsp; <span class="Comment">/* insert last jump in 't' list */<br/></li>
<li></span>&nbsp; <a href="#L209" title="lcode.c:209">luaK_patchtohere</a>(fs, e-&gt;f);<br/></li>
<li>&nbsp; e-&gt;f = <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L701">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">codenot</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e) {<br/></li>
<li>&nbsp; <a href="#L406" title="lcode.c:406">luaK_dischargevars</a>(fs, e);<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (e-&gt;k) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VNIL: <span class="Statement">case</span> VFALSE: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; e-&gt;k = VTRUE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VK: <span class="Statement">case</span> VKFLT: <span class="Statement">case</span> VKINT: <span class="Statement">case</span> VTRUE: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; e-&gt;k = VFALSE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VJMP: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L631" title="lcode.c:631">invertjump</a>(fs, e);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VRELOCABLE:<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> VNONRELOC: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L487" title="lcode.c:487">discharge2anyreg</a>(fs, e);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L302" title="lcode.c:302">freeexp</a>(fs, e);<br/></li>
<li>&nbsp; &nbsp; &nbsp; e-&gt;u.info = <a href="#L244" title="lcode.c:244">luaK_codeABC</a>(fs, OP_NOT, <span class="Constant">0</span>, e-&gt;u.info, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; e-&gt;k = VRELOCABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<span class="Constant">0</span>);&nbsp; <span class="Comment">/* <a href="luac.c.html#L44" title="luac.c:44">cannot</a> happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Comment">/* interchange true and false lists */<br/></li>
<li></span>&nbsp; { <span class="Type">int</span> temp = e-&gt;f; e-&gt;f = e-&gt;t; e-&gt;t = temp; }<br/></li>
<li>&nbsp; <a href="#L161" title="lcode.c:161">removevalues</a>(fs, e-&gt;f);<br/></li>
<li>&nbsp; <a href="#L161" title="lcode.c:161">removevalues</a>(fs, e-&gt;t);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L736">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_indexed</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *t, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *k) {<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(!<a href="#L36" title="lcode.c:36">hasjumps</a>(t));<br/></li>
<li>&nbsp; t-&gt;u.ind.t = t-&gt;u.info;<br/></li>
<li>&nbsp; t-&gt;u.ind.idx = <a href="#L555" title="lcode.c:555">luaK_exp2RK</a>(fs, k);<br/></li>
<li>&nbsp; t-&gt;u.ind.vt = (t-&gt;k == VUPVAL) ? VUPVAL<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; : <a href="llimits.h.html#L79" title="llimits.h:79">check_exp</a>(<a href="lparser.h.html#L39" title="lparser.h:39">vkisinreg</a>(t-&gt;k), VLOCAL);<br/></li>
<li>&nbsp; t-&gt;k = VINDEXED;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** return false if folding can raise an <a href="lundump.c.html#L40" title="lundump.c:40">error</a><br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L749">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">validop</span> (<span class="Type">int</span> op, <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *v1, <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> *v2) {<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (op) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lua.h.html#L201" title="lua.h:201">LUA_OPBAND</a>: <span class="Statement">case</span> <a href="lua.h.html#L202" title="lua.h:202">LUA_OPBOR</a>: <span class="Statement">case</span> <a href="lua.h.html#L203" title="lua.h:203">LUA_OPBXOR</a>:<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lua.h.html#L204" title="lua.h:204">LUA_OPSHL</a>: <span class="Statement">case</span> <a href="lua.h.html#L205" title="lua.h:205">LUA_OPSHR</a>: <span class="Statement">case</span> <a href="lua.h.html#L207" title="lua.h:207">LUA_OPBNOT</a>: {&nbsp; <span class="Comment">/* conversion errors */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="lua.h.html#L91" title="lua.h:91">lua_Integer</a> i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<a href="lvm.h.html#L33" title="lvm.h:33">tointeger</a>(v1, &amp;i) &amp;&amp; <a href="lvm.h.html#L33" title="lvm.h:33">tointeger</a>(v2, &amp;i));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> <a href="lua.h.html#L199" title="lua.h:199">LUA_OPDIV</a>: <span class="Statement">case</span> <a href="lua.h.html#L200" title="lua.h:200">LUA_OPIDIV</a>: <span class="Statement">case</span> <a href="lua.h.html#L197" title="lua.h:197">LUA_OPMOD</a>:&nbsp; <span class="Comment">/* division by 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<a href="lobject.h.html#L157" title="lobject.h:157">nvalue</a>(v2) != <span class="Constant">0</span>);<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> <span class="Statement">return</span> <span class="Constant">1</span>;&nbsp; <span class="Comment">/* everything else is valid */<br/></li>
<li></span>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** Try to &quot;constant-fold&quot; an operation; return 1 iff successful<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L766">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span> <span class="linkable">constfolding</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> op, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e1, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e2) {<br/></li>
<li>&nbsp; <a href="lobject.h.html#L108" title="lobject.h:108">TValue</a> v1, v2, res;<br/></li>
<li>&nbsp; <span class="Statement">if</span> (!<a href="#L39" title="lcode.c:39">tonumeral</a>(e1, &amp;v1) || !<a href="#L39" title="lcode.c:39">tonumeral</a>(e2, &amp;v2) || !<a href="#L749" title="lcode.c:749">validop</a>(op, &amp;v1, &amp;v2))<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;&nbsp; <span class="Comment">/* non-numeric operands or not safe to fold */<br/></li>
<li></span>&nbsp; <a href="lobject.c.html#L116" title="lobject.c:116">luaO_arith</a>(fs-&gt;ls-&gt;L, op, &amp;v1, &amp;v2, &amp;res);&nbsp; <span class="Comment">/* does operation */<br/></li>
<li></span>&nbsp; <span class="Statement">if</span> (<a href="lobject.h.html#L136" title="lobject.h:136">ttisinteger</a>(&amp;res)) {<br/></li>
<li>&nbsp; &nbsp; e1-&gt;k = VKINT;<br/></li>
<li>&nbsp; &nbsp; e1-&gt;u.ival = <a href="lobject.h.html#L155" title="lobject.h:155">ivalue</a>(&amp;res);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">else</span> {&nbsp; <span class="Comment">/* folds neither NaN nor 0.0 (to avoid collapsing with -0.0) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lua.h.html#L87" title="lua.h:87">lua_Number</a> n = <a href="lobject.h.html#L156" title="lobject.h:156">fltvalue</a>(&amp;res);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="luaconf.h.html#L506" title="luaconf.h:506">luai_numisnan</a>(n) || n == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; e1-&gt;k = VKFLT;<br/></li>
<li>&nbsp; &nbsp; e1-&gt;u.nval = n;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment">** Code for binary and unary expressions that &quot;produce values&quot;<br/></li>
<li></span><span class="Comment">** (arithmetic operations, bitwise operations, concat, length). First<br/></li>
<li></span><span class="Comment">** try to do constant folding (only for numeric [arithmetic and<br/></li>
<li></span><span class="Comment">** bitwise] operations, which is what '<a href="lapi.c.html#L301" title="lapi.c:301">lua_arith</a>' accepts).<br/></li>
<li></span><span class="Comment">** Expression to produce final result will be encoded in 'e1'.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li><a id="L793">&#x200c;</a></span><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">codeexpval</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lopcodes.h.html#L232" title="lopcodes.h:232">OpCode</a> op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e1, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e2, <span class="Type">int</span> line) {<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(op &gt;= OP_ADD);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (op &lt;= OP_BNOT &amp;&amp; <a href="#L766" title="lcode.c:766">constfolding</a>(fs, op - OP_ADD + <a href="lua.h.html#L194" title="lua.h:194">LUA_OPADD</a>, e1, e2))<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; <span class="Comment">/* result has been folded */<br/></li>
<li></span>&nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> o1, o2;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* move operands to registers (if needed) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (op == OP_UNM || op == OP_BNOT || op == OP_LEN) {&nbsp; <span class="Comment">/* unary op? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; o2 = <span class="Constant">0</span>;&nbsp; <span class="Comment">/* no second expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; o1 = <a href="#L527" title="lcode.c:527">luaK_exp2anyreg</a>(fs, e1);&nbsp; <span class="Comment">/* <a href="luac.c.html#L44" title="luac.c:44">cannot</a> operate on constants */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> {&nbsp; <span class="Comment">/* regular case (binary operators) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; o2 = <a href="#L555" title="lcode.c:555">luaK_exp2RK</a>(fs, e2);&nbsp; <span class="Comment">/* both operands are &quot;RK&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; o1 = <a href="#L555" title="lcode.c:555">luaK_exp2RK</a>(fs, e1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (o1 &gt; o2) {&nbsp; <span class="Comment">/* free registers in proper order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L302" title="lcode.c:302">freeexp</a>(fs, e1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L302" title="lcode.c:302">freeexp</a>(fs, e2);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L302" title="lcode.c:302">freeexp</a>(fs, e2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L302" title="lcode.c:302">freeexp</a>(fs, e1);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; e1-&gt;u.info = <a href="#L244" title="lcode.c:244">luaK_codeABC</a>(fs, op, <span class="Constant">0</span>, o1, o2);&nbsp; <span class="Comment">/* generate opcode */<br/></li>
<li></span>&nbsp; &nbsp; e1-&gt;k = VRELOCABLE;&nbsp; <span class="Comment">/* all those operations are relocable */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L935" title="lcode.c:935">luaK_fixline</a>(fs, line);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L824">&#x200c;</a><span class="Type">static</span> <span class="Type">void</span> <span class="linkable">codecomp</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lopcodes.h.html#L232" title="lopcodes.h:232">OpCode</a> op, <span class="Type">int</span> <a href="lparser.c.html#L1174" title="lparser.c:1174">cond</a>, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e2) {<br/></li>
<li>&nbsp; <span class="Type">int</span> o1 = <a href="#L555" title="lcode.c:555">luaK_exp2RK</a>(fs, e1);<br/></li>
<li>&nbsp; <span class="Type">int</span> o2 = <a href="#L555" title="lcode.c:555">luaK_exp2RK</a>(fs, e2);<br/></li>
<li>&nbsp; <a href="#L302" title="lcode.c:302">freeexp</a>(fs, e2);<br/></li>
<li>&nbsp; <a href="#L302" title="lcode.c:302">freeexp</a>(fs, e1);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (<a href="lparser.c.html#L1174" title="lparser.c:1174">cond</a> == <span class="Constant">0</span> &amp;&amp; op != OP_EQ) {<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span> temp;&nbsp; <span class="Comment">/* exchange args to replace by '&lt;' or '&lt;=' */<br/></li>
<li></span>&nbsp; &nbsp; temp = o1; o1 = o2; o2 = temp;&nbsp; <span class="Comment">/* o1 &lt;==&gt; o2 */<br/></li>
<li></span>&nbsp; &nbsp; <a href="lparser.c.html#L1174" title="lparser.c:1174">cond</a> = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; e1-&gt;u.info = <a href="#L91" title="lcode.c:91">condjump</a>(fs, op, <a href="lparser.c.html#L1174" title="lparser.c:1174">cond</a>, o1, o2);<br/></li>
<li>&nbsp; e1-&gt;k = VJMP;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L840">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_prefix</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lcode.h.html#L40" title="lcode.h:40">UnOpr</a> op, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e, <span class="Type">int</span> line) {<br/></li>
<li>&nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> e2;<br/></li>
<li>&nbsp; e2.t = e2.f = <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>; e2.k = VKINT; e2.u.ival = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (op) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> OPR_MINUS: <span class="Statement">case</span> OPR_BNOT: <span class="Statement">case</span> OPR_LEN: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L793" title="lcode.c:793">codeexpval</a>(fs, <a href="llimits.h.html#L107" title="llimits.h:107">cast</a>(<a href="lopcodes.h.html#L232" title="lopcodes.h:232">OpCode</a>, (op - OPR_MINUS) + OP_UNM), e, &amp;e2, line);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> OPR_NOT: <a href="#L701" title="lcode.c:701">codenot</a>(fs, e); <span class="Statement">break</span>;<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L854">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_infix</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lcode.h.html#L26" title="lcode.h:26">BinOpr</a> op, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *v) {<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (op) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> OPR_AND: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L654" title="lcode.c:654">luaK_goiftrue</a>(fs, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> OPR_OR: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L678" title="lcode.c:678">luaK_goiffalse</a>(fs, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> OPR_CONCAT: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L519" title="lcode.c:519">luaK_exp2nextreg</a>(fs, v);&nbsp; <span class="Comment">/* operand must be on the 'stack' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> OPR_ADD: <span class="Statement">case</span> OPR_SUB:<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> OPR_MUL: <span class="Statement">case</span> OPR_DIV: <span class="Statement">case</span> OPR_IDIV:<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> OPR_MOD: <span class="Statement">case</span> OPR_POW:<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> OPR_BAND: <span class="Statement">case</span> OPR_BOR: <span class="Statement">case</span> OPR_BXOR:<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> OPR_SHL: <span class="Statement">case</span> OPR_SHR: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L39" title="lcode.c:39">tonumeral</a>(v, <span class="Constant">NULL</span>)) <a href="#L555" title="lcode.c:555">luaK_exp2RK</a>(fs, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L555" title="lcode.c:555">luaK_exp2RK</a>(fs, v);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L884">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_posfix</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <a href="lcode.h.html#L26" title="lcode.h:26">BinOpr</a> op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e1, <a href="lparser.h.html#L41" title="lparser.h:41">expdesc</a> *e2, <span class="Type">int</span> line) {<br/></li>
<li>&nbsp; <span class="Statement">switch</span> (op) {<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> OPR_AND: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(e1-&gt;t == <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>);&nbsp; <span class="Comment">/* list must be closed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L406" title="lcode.c:406">luaK_dischargevars</a>(fs, e2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L215" title="lcode.c:215">luaK_concat</a>(fs, &amp;e2-&gt;f, e1-&gt;f);<br/></li>
<li>&nbsp; &nbsp; &nbsp; *e1 = *e2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> OPR_OR: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(e1-&gt;f == <a href="lcode.h.html#L20" title="lcode.h:20">NO_JUMP</a>);&nbsp; <span class="Comment">/* list must be closed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; <a href="#L406" title="lcode.c:406">luaK_dischargevars</a>(fs, e2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L215" title="lcode.c:215">luaK_concat</a>(fs, &amp;e2-&gt;t, e1-&gt;t);<br/></li>
<li>&nbsp; &nbsp; &nbsp; *e1 = *e2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> OPR_CONCAT: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L547" title="lcode.c:547">luaK_exp2val</a>(fs, e2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (e2-&gt;k == VRELOCABLE &amp;&amp; <a href="lopcodes.h.html#L89" title="lopcodes.h:89">GET_OPCODE</a>(<a href="lcode.h.html#L43" title="lcode.h:43">getcode</a>(fs, e2)) == OP_CONCAT) {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(e1-&gt;u.info == <a href="lopcodes.h.html#L100" title="lopcodes.h:100">GETARG_B</a>(<a href="lcode.h.html#L43" title="lcode.h:43">getcode</a>(fs, e2))-<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L302" title="lcode.c:302">freeexp</a>(fs, e1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="lopcodes.h.html#L101" title="lopcodes.h:101">SETARG_B</a>(<a href="lcode.h.html#L43" title="lcode.h:43">getcode</a>(fs, e2), e1-&gt;u.info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; e1-&gt;k = VRELOCABLE; e1-&gt;u.info = e2-&gt;u.info;<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">else</span> {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L519" title="lcode.c:519">luaK_exp2nextreg</a>(fs, e2);&nbsp; <span class="Comment">/* operand must be on the 'stack' */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L793" title="lcode.c:793">codeexpval</a>(fs, OP_CONCAT, e1, e2, line);<br/></li>
<li>&nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> OPR_ADD: <span class="Statement">case</span> OPR_SUB: <span class="Statement">case</span> OPR_MUL: <span class="Statement">case</span> OPR_DIV:<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> OPR_IDIV: <span class="Statement">case</span> OPR_MOD: <span class="Statement">case</span> OPR_POW:<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> OPR_BAND: <span class="Statement">case</span> OPR_BOR: <span class="Statement">case</span> OPR_BXOR:<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> OPR_SHL: <span class="Statement">case</span> OPR_SHR: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L793" title="lcode.c:793">codeexpval</a>(fs, <a href="llimits.h.html#L107" title="llimits.h:107">cast</a>(<a href="lopcodes.h.html#L232" title="lopcodes.h:232">OpCode</a>, (op - OPR_ADD) + OP_ADD), e1, e2, line);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> OPR_EQ: <span class="Statement">case</span> OPR_LT: <span class="Statement">case</span> OPR_LE: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L824" title="lcode.c:824">codecomp</a>(fs, <a href="llimits.h.html#L107" title="llimits.h:107">cast</a>(<a href="lopcodes.h.html#L232" title="lopcodes.h:232">OpCode</a>, op - OPR_EQ + OP_EQ), <span class="Constant">1</span>, e1, e2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">case</span> OPR_NE: <span class="Statement">case</span> OPR_GT: <span class="Statement">case</span> OPR_GE: {<br/></li>
<li>&nbsp; &nbsp; &nbsp; <a href="#L824" title="lcode.c:824">codecomp</a>(fs, <a href="llimits.h.html#L107" title="llimits.h:107">cast</a>(<a href="lopcodes.h.html#L232" title="lopcodes.h:232">OpCode</a>, op - OPR_NE + OP_EQ), <span class="Constant">0</span>, e1, e2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="cUserCont">&nbsp; &nbsp; </span><span class="Statement">default</span><span class="cUserCont">:</span> <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L935">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_fixline</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> line) {<br/></li>
<li>&nbsp; fs-&gt;f-&gt;lineinfo[fs-&gt;pc - <span class="Constant">1</span>] = line;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L940">&#x200c;</a><span class="Type">void</span> <span class="linkable">luaK_setlist</span> (<a href="lparser.h.html#L98" title="lparser.h:98">FuncState</a> *fs, <span class="Type">int</span> base, <span class="Type">int</span> nelems, <span class="Type">int</span> tostore) {<br/></li>
<li>&nbsp; <span class="Type">int</span> c =&nbsp; (nelems - <span class="Constant">1</span>)/<a href="lopcodes.h.html#L292" title="lopcodes.h:292">LFIELDS_PER_FLUSH</a> + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; <span class="Type">int</span> b = (tostore == <a href="lua.h.html#L34" title="lua.h:34">LUA_MULTRET</a>) ? <span class="Constant">0</span> : tostore;<br/></li>
<li>&nbsp; <a href="lualib.h.html#L54" title="lualib.h:54">lua_assert</a>(tostore != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; <span class="Statement">if</span> (c &lt;= <a href="lopcodes.h.html#L76" title="lopcodes.h:76">MAXARG_C</a>)<br/></li>
<li>&nbsp; &nbsp; <a href="#L244" title="lcode.c:244">luaK_codeABC</a>(fs, OP_SETLIST, base, b, c);<br/></li>
<li>&nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (c &lt;= <a href="lopcodes.h.html#L68" title="lopcodes.h:68">MAXARG_Ax</a>) {<br/></li>
<li>&nbsp; &nbsp; <a href="#L244" title="lcode.c:244">luaK_codeABC</a>(fs, OP_SETLIST, base, b, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L261" title="lcode.c:261">codeextraarg</a>(fs, c);<br/></li>
<li>&nbsp; }<br/></li>
<li>&nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; <a href="llex.c.html#L118" title="llex.c:118">luaX_syntaxerror</a>(fs-&gt;ls, <span class="Constant">&quot;<a href="lparser.c.html#L718" title="lparser.c:718">constructor</a> too long&quot;</span>);<br/></li>
<li>&nbsp; fs-&gt;<a href="#L294" title="lcode.c:294">freereg</a> = base + <span class="Constant">1</span>;&nbsp; <span class="Comment">/* free registers with list values */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
</ol></code>
 </body>
</html>
